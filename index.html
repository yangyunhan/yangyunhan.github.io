<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="该叫什么好">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="该叫什么好">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="该叫什么好">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>该叫什么好</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">该叫什么好</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">亦方亦圆</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/22/前端框架vs前端框架vs后端框架/" itemprop="url">前端框架vs前端框架vs后端框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-22T16:25:21+08:00">
                2018-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前后端架构设计与框架对比"><a href="#前后端架构设计与框架对比" class="headerlink" title="前后端架构设计与框架对比"></a>前后端架构设计与框架对比</h4><p>首先，MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。前后端都有MVC架构模式的概念，前端的MVC是为了解决前端复杂JS模块化的问题，从后端MVC的V分出来的MVC，与后端MVC并没有直接的关系。前端的MVC中，M占的比例很低，只指代数据。而后端V的比例很低，只有模版的部分。<br><img src="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52" alt="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52"></p>
<p>经典MVC模式下（并非一定在js中），涉及两种设计模式：view和model之间的观察者模式，view观察model，事先在此model上注册，以便view可以了解在数据model上发生的改变。和view和controller之间的策略模式，一个策略是一个表述算法的对象。MVC将响应机制封装在controller对象中。存在着一个controller的类层次结构，使得可以方便地对原有的controller做适当改变而创建新的controller。view使用controller子类的实例来实现一个特定的响应策略。要实现不同的响应的策略只要用不同种类的controller实例替换即可。</p>
<p>经典MVC到jsMVC可以实现1对1的转换，但controller的角色有些许改变。从原来派发用户输入给不同的view和改变model到用户和系统的连接。在js中，controller的职责已经被系统实现了。<br><img src="/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件\blog\source\_posts\前端框架vs前端框架vs后端框架\mvc.png" alt=""></p>
<p>MVP是想改变cotroller与view的捆绑关系，view有用户处理事件的能力。但是用户处理事件统一放到P中，如此，多个view可以公用一个controller。通过Presenter更新model，通过观察者模式更新view。更新方式与MVC一样，但是MVC的更新过程是一个圆，一个循环的过程。MVP依赖Presenter作为核心，负责从model中拿数据，填充到view中。常见的MVP的实现是被动视图，Presenter观察model，不再是view观察model，一旦model发生变化，就会更新view。Presenter有效地绑定了model到view。view暴露了setters接口以便Presenter可以设置数据。对于这种被动视图的结构，没有直接数据绑定的概念。但是他的好处是在view和model直接提供更清晰的分离。但是由于缺乏数据绑定支持，意味着不得不单独关注某个任务。在MVP里，应用程序的逻辑主要在Presenter来实现，其中的view是很薄的一层。<br><img src="/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件\blog\source\_posts\前端框架vs前端框架vs后端框架\mvp.png" alt=""></p>
<p>MVVM的特点是数据绑定，view和model是不知道彼此存在的，同MVP一样，将view和model清晰地分离开来。 其次，view是对viewmodel的外在显示，与viewmodel保持同步，viewmodel对象可以看作是view的上下文。view绑定到viewmodel的属性上，如果viewmodel中的属性值变化了，这些新值通过数据绑定会自动传递给view。反过来viewmodel会暴露model中的数据和特定状态给view。所以，view不知道model的存在，viewmodel和model也觉察不到view。<br><img src="/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件\blog\source\_posts\前端框架vs前端框架vs后端框架\mvvm.png" alt=""></p>
<p>简单来说，<code>MV*</code>的区别在M与V的联系上，Controller负责监听view的用户事件，得到数据做处理，渲染view。由于各个模块耦合性强，无法单独验证应用逻辑正确性，不能判断出问题的模块。所以有MVP调用view层的接口渲染model。如此，P可以做单元测试，结构也更清楚。但是当view变的复杂之后，需要的接口变多，增加了开发调试的成本，所以有了MVVM。VM中构建一组状态数据（view层的抽象），通过双向数据绑定使VM中的状态数据与View中的显示状态保持一致。VM只适合复杂UI交互的项目。</p>
<p>参考：<br>​    - <a href="https://segmentfault.com/a/1190000015310674" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015310674</a><br>​    - <a href="http://efe.baidu.com/blog/mvc-deformation/" target="_blank" rel="noopener">http://efe.baidu.com/blog/mvc-deformation/</a></p>
<p>其次，React的定位是MVC框架中的V，Vue的定位是MVVM框架中的VM，Angular的定位是完整的MVVM框架。</p>
<ul>
<li>React-13：可以非常方便地构建大型网页应用。<ul>
<li>出现：为了降低操作DOM的代价</li>
<li>优点：<ul>
<li>速度快。提出了Virtual Dom这种新颖的思路，并且这种思路衍生出了React Native，有可能会统一Web/Native开发。在性能方面，由于运用了Virtual Dom技术，Reactjs只在调用setState的时候会更新dom，而且还是先更新Virtual Dom，然后和实际Dom比较，最后再更新实际Dom。一是更新dom的次数少，二是更新dom的内容少。</li>
<li>模块化。独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。组件通过组合、嵌套构成更复杂的UI界面。</li>
<li>ReactJS更关注数据的单向更新，但是它更简单直观，所有的状态改变只有一个入口this.setState()。/<em>它提出了FLUX架构的新概念，现在React可以直接用Js ES6语法了，然后通过webpack编译成浏览器兼容的ES5，开发效率上有些优势. </em>/</li>
<li>React Native生成的App不是运行在WebView上，而是系统原生的UI，React通过jsx生成系统原生的UI，iOS和Android的React UI组件还是比较相似的，大量代码可以复用。</li>
<li>同构的JavaScript: 单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</li>
<li>跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</li>
<li>灵活性、轻量级、开源、版本迁移容易</li>
</ul>
</li>
<li>缺点：<br>React是目标是UI组件，通常可以和其它框架组合使用，目前并不适合单独做一个完整的框架。React 即使配上 redux 的组合，也不能称之一个完整的框架，比如你想用Promise化的AJAX？要自己找现成的库。而且第三方组件远远不如Angular多。React本身只是一个V而已，所以如果是大型项目想要一套完整的框架的话，也许还需要引入Redux和route相关的东西。</li>
</ul>
</li>
<li>Vue-13：非常适合用于构架非常灵活的UI和复杂的单页面应用。<ul>
<li>是一个提供 MVVM 数据双向绑定的库，专注于UI 层面，核心思想是：数据驱动、组件系统。</li>
<li>数据观测原理在技术实现上，利用的是 ES5 Object.defineProperty 和存储器属性: getter 和 setter（所以只兼容 IE9 及以上版本）</li>
<li>Vue实现数据和视图保持一致性：每一个指令都会有一个对应的用来观测数据的对象，叫做 watcher，比如v-text=”msg”, ，即为两个 watcher，watcher对象中包含了待渲染的关联 DOM 元素。<ul>
<li>将原生的数据改造成 “可观察对象”，通常为调用 defineProperty 改变 data 对象中数据为存储器属性；一个可观察对象可以被取值 getter，也可以被赋值setter。</li>
<li>解析模板，也就是在 watcher 的求值过程中，每一个被取值的可观察对象都会将当前的 watcher 注册为自己的一个订阅者，并成为当前watcher的一个依赖。</li>
<li>当一个被依赖的可观察对象被赋值时，它会通知 notify 所有订阅自己的 watcher 重新求值，并触发相应的更新，即watcher对象中关联的 DOM 改变渲染。</li>
<li>使用 Virtual DOM；提供了响应式（Reactive）和组件化（Composable）的视图组件；将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库</li>
</ul>
</li>
<li>端对端的数据渲染，react是setState更新组件，父组件更新子组件重新渲染</li>
<li>继承方式不同，react面向对象继承，vue需要遵循很多规则</li>
<li>优点：<ul>
<li>轻便（20多kb），双向绑定</li>
<li>强化的HTML，像Angular</li>
<li>可适用性：可以很快地从其它框架转移到Vue.js</li>
<li>整合性：Vue.js可以同时用于单页面应用和更加复杂的网页应用。主要在于你可以用它编写很小的可交互部件，然后可以很容易地整合到现有的项目中而不会影响到整个系统；</li>
</ul>
</li>
<li>缺点：<ul>
<li>不支持ie8</li>
<li>在整个市场中只占有很小的比例，所以相应的资源、知识要少很多；</li>
<li>灵活性带来的风险：有时候，将其整合到大型项目的时候会有一些问题，但是不见得能够找到解法</li>
</ul>
</li>
</ul>
</li>
<li><p>Angular-09:对于构建高度可交互的网页应用非常方便。</p>
<ul>
<li>出现：AngularJS是为了克服HTML在构建应用上的不足而设计的。使用了不同的方法，它尝试去补足HTML本身在构建应用方面的缺陷。通过使用标识符(directives)的结构，让浏览器能够识别新的语法。例如使用双大括号语法进行数据绑定；使用ng-controller指定每个控制器负责监视视图中的哪一部分；使用ng-model，把输入数据绑定到模型中的一部分属性上。</li>
<li>优点：<ul>
<li>AngularJS是一套完整的框架，angular有自带的数据绑定、render渲染、angularUI库,过滤器,directive(模板),服务q(defer),http，inject(依赖注入),factory,provider……，等等一系列工具，基本上只要你在做web开发用过的东西，它都有一个。</li>
<li>新特性：RXJS，快速编译（3秒内），新的HttpClient；</li>
<li>详细的文档几乎涵盖了所有必须的信息</li>
<li>数据双向绑定，可以减少出错的风险</li>
<li>MVVM(Model-View-ViewModel)使得开发者可以针对同一个App模块同时开发</li>
<li>依赖注入使得模块化和模块中组件引入更加方便；</li>
</ul>
</li>
<li>缺点：<ul>
<li>性能：随着组件增加，项目越来越复杂，双向数据绑定带来性能问题。在JavaScript（ES5）中，并没有实现当变量或对象改变时发出通知的功能，Angular的实现方法被叫做“Dirty-checking（脏检查机制）”，通过跟踪数据的改变再动态更新用户界面（UI）。在Angular的作用域中任何操作的执行都会引发Dirty-checking，随着绑定数量的增加性能就会越低。</li>
<li>学习成本高</li>
<li>迁移问题：从低版本升级到新版本的时候，不兼容导致迁移成本高。</li>
</ul>
</li>
</ul>
</li>
<li><p>在react，angular，vue这三者中，Angular的适用领域相对窄一些，React可以拓展到服务端，移动端Native部分，而Vue因为比较轻量，还能用于业务场景非常轻的页面中。</p>
</li>
<li>在web应用中，要解决三个问题：状态、组织和效率<ul>
<li>状态：在一个业务界面中，可能根据数据生成界面，再通过操作改变数据，影响界面中另一些部分。其中有两种关系：从数据到界面和从界面到数据。能够描述界面当前状况的数据，可称为状态。不同框架采用不同方式做了处理：MVVM流的Angular和Vue，通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后，再根据配置好的规则去，从数据更新界面状态；React走的是另外一个流派，就是所谓的函数式，在这个里面，推崇的是单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）。</li>
<li>组织：模块关系和业务模型。模块关系就是模块化，业务模型指的是所处领域中的业务数据、规则、流程的集合。</li>
<li>效率：开发效率和运行效率。组件化提高开发效率；运行效率在于数据变更检测方式和创建和修改DOM</li>
</ul>
</li>
<li>参考材料：<ul>
<li><a href="https://www.w3cvip.org/topics/93" target="_blank" rel="noopener">https://www.w3cvip.org/topics/93</a></li>
<li><a href="https://segmentfault.com/a/1190000005159165" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005159165</a></li>
<li><a href="https://blog.csdn.net/u012125579/article/details/52744093" target="_blank" rel="noopener">https://blog.csdn.net/u012125579/article/details/52744093</a></li>
<li><a href="https://blog.fundebug.com/2018/07/09/react_vs_angular_vue/" target="_blank" rel="noopener">https://blog.fundebug.com/2018/07/09/react_vs_angular_vue/</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/04/React与类MVVM框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/04/React与类MVVM框架/" itemprop="url">React再整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-04T11:49:26+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React再整理"><a href="#React再整理" class="headerlink" title="React再整理"></a>React再整理</h2><h4 id="React原理及diff理解"><a href="#React原理及diff理解" class="headerlink" title="React原理及diff理解"></a>React原理及diff理解</h4><ul>
<li>DOM diff其实是比较两个虚拟DOM的区别，本质上是比较两个对象（js的树形解构）的区别，对比出不同，创建补丁（补丁是描述改变了的内容），用这个补丁来进行更新，最小化DOM操作。</li>
<li>虚拟DOM+diff算法，使DOM树构建的复杂度从O(n^3)转为O(n)，O(n^3)据说是对比两棵树需要两层嵌套循环，再加一层确认是什么操作（增、删、改等）。</li>
<li>分别对tree、component、element diff进行优化：<ul>
<li>tree：只对同一层次的节点进行比较，发现不同时，直接删除该节点及其子节点，再添加新的节点</li>
<li>component：统一类型的节点，继续比较；不同类型，dirty component，替换整个组件</li>
<li>element：添加唯一key区分同一层级的节点，当修改后的位移小于最右的位置时才会进行位移操作，更新完新集合，遍历老集合删去要删除的节点。</li>
</ul>
</li>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20346379</a></li>
</ul>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul>
<li><p>定位：组件的任何UI改变，可以从state中反映出来，并且是UI呈现的最小状态集，不需要通过其他状态计算而来，需要在render中使用。</p>
</li>
<li><p>与props的区别：state是可变的，是组件内部维护的用于反应组件UI变化的状态集合；props是只读的，修改props只能通过该组件的父组件修改。</p>
</li>
<li><p>适用场合：</p>
<ul>
<li>在componentWillMount中执行无意义，因为组件只挂载一次，而且会和constructor中的初始化state合并执行，对state的初始化可以放在constructor中。</li>
<li>在componentDidMount中执行导致组件在初始化的时候就触发，渲染两次，除了在必要的场合如组件渲染完成获得DOM元素位置或者宽高以外，其他时候避免在该生命周期中设置。</li>
<li>在componentWillUnmount中执行不生效无意义。</li>
<li>在shouldComponentUpdate和componentWillUpdate中调用se’tState，会造成循环调用，直至耗光浏览器内存后崩溃。</li>
<li>在componentDidUpdate中执行setState可能会导致死循环，但在需要重新获取DOM元素宽高时更新某个state就不得不使用，给他设置一个前提条件，避免循环渲染。</li>
</ul>
</li>
<li><p>修改state：</p>
<ul>
<li>购物车点击购买数量时：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//错误，只会更新一次，后面的覆盖前面的，因为setState是异步的，React会做性能优化</div><div class="line">Object.assign(previousState,&#123;</div><div class="line">    &#123;quantity: this.state.quantity + 1&#125;,</div><div class="line">    &#123;quantity: this.state.quantity + 1&#125;</div><div class="line">&#125;)</div><div class="line">//正确</div><div class="line">this.setState((preState, props) =&gt; &#123;</div><div class="line">    counter: preState.quantity + 1;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p>State的更新是一个浅合并的过程，只需要把部分state的更改传入即可。</p>
</li>
<li><p>State应是不可变的对象，即当是引用类型的值时，需要重新创建状态对象，而不是修改原来的对象。有几点考虑：一是不可变对象方便管理和调试，因为从不会更改的数据比在整个应用程序中可以随意更改的数据更容易理解；二是处于性能考虑，当对象组件是不可变对象时，我们在组件的<code>shouldComponentUpdate</code>方法中，仅需要比较状态的引用就可以判断是否真的改变，从而避免不必要的<code>render</code>调用；三是当我们使用React提供的<code>PureComponent</code>时，更要保证组件状态是不可变的，因为<code>PureComponent</code>执行的是浅比较。此处可以借助<code>Immutable.js</code>库实现类似效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> books = <span class="keyword">this</span>.state.books;</div><div class="line"><span class="comment">//concat返回新数组</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">    <span class="attr">books</span>: books.concat([<span class="string">'React Guide'</span>]);</div><div class="line">&#125;)</div><div class="line"><span class="comment">//使用preState\concat创建新数组</span></div><div class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">books</span>: preState.books.concat([<span class="string">'React Guide'</span>]);</div><div class="line">&#125;))</div><div class="line"><span class="comment">//扩展运算符</span></div><div class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">books</span>: [...preState.books, <span class="string">'React Guide'</span>];</div><div class="line">&#125;))</div><div class="line"><span class="comment">//slice创建新数组</span></div><div class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">books</span>: preState.books.slice(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line">&#125;))</div><div class="line"><span class="comment">//filter创建新数组</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">    <span class="attr">books</span>: books.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> item != <span class="string">'React'</span></div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">books</span>: preState.books.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> item != <span class="string">'React'</span></div><div class="line">    &#125;)</div><div class="line">&#125;))</div><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">    <span class="attr">books</span>: <span class="built_in">Object</span>.assign(&#123;&#125;, books, &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>&#125;);</div><div class="line">&#125;)</div><div class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">books</span>: <span class="built_in">Object</span>.assign(&#123;&#125;, preState.books, &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>&#125;);</div><div class="line">&#125;))</div><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">    <span class="attr">books</span>: &#123;...books, &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>&#125;&#125;;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">books</span>: &#123;...preState.books, &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>&#125;&#125;;</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>setState是异步执行的</p>
<ul>
<li>可以设置第二个参数，是回调函数，函数里可以拿到更新的state值</li>
<li>出于性能考虑，当要加载的组件树比较庞大时，更新这段时间内，用户输入或敲击键盘不会获得响应。等更新过程完成后，用户输入又会一下显示出来，造成界面卡顿，体验不好。解决办法是分片，把耗时长的任务分成小片，小片执行完执行其他任务，可以先做紧急任务（维护每个分片的数据结构就是Fiber）。带来的影响是一个更新任务可能没有执行完就被另一个高级任务打断。低级任务会作废，有机会重头再来。React Fiber把更新过程分为两个阶段：第一阶段Reconciliation，找出需要更新的DOM，可以被打断，生命周期函数有<code>componentWillMount</code>、<code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>；第二阶段Commit Phase，一鼓作气更新DOM，不会打断，用到的生命周期函数有<code>componentDidMount</code>，<code>componentDidUpdate</code>，<code>componentWillUnmount</code>。可以被打断意味着在一次加载和更新过程中这些生命周期函数可能会被多次调用。</li>
<li>setState异步更新的关键是<code>batchingStrategy</code>，批量更新，以事务的方式实现。<code>isBatchingUpdates</code>是事务的一个标志，如果为true，表示react正在一个更新组件的事务流中。如果在事务流中，将需要更新的组件放入<code>dirtyComponent</code>中，先将需要更新的组件存起来，稍后更新；否则调用<code>batchedUpdates</code>方法进入更新流程。进入流程后，会将<code>isBatchingUpdates</code>设置为true。这是为什么在<code>componentDidMount</code>中调用setState并不会立即更新state，因为正处于一个更新流程中，只会放入<code>dirtyComponents</code>中等待稍后更新。在事件中调用setState也是异步的，因为react通过合成事件实现对事件绑定。在组件创建和更新的入口方法<code>mountComponent</code>和<code>updateComponent</code>中会将绑定的事件注册到document上，相应的回调函数通过<code>EventPluginHub</code>存储，即也是通过事务完成。</li>
<li>原生事件绑定不会通过合成事件的方式处理，也就不会进入更新事务的处理流程。setTimeout也一样，在setTimeout回调执行时已经完成了原更新组件流程，不会放入<code>dirtyComponent</code>进行异步更新，结果是同步的。</li>
</ul>
</li>
<li><p>参考：</p>
<ul>
<li><p><a href="https://juejin.im/entry/59522bdb6fb9a06b9a516113" target="_blank" rel="noopener">https://juejin.im/entry/59522bdb6fb9a06b9a516113</a></p>
</li>
<li><p><a href="https://redux.js.org/faq/immutabledata#benefits-of-immutability" target="_blank" rel="noopener">https://redux.js.org/faq/immutabledata#benefits-of-immutability</a></p>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/35226897" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35226897</a></li>
</ul>
</li>
</ul>
<h4 id="创建组件的方式"><a href="#创建组件的方式" class="headerlink" title="创建组件的方式"></a>创建组件的方式</h4><ul>
<li>无状态函数组件：只是展示组件，不涉及state，也没有生命周期函数，只有render方法。不会被实例化，不能访问this，生命周期函数，只能访问props。</li>
<li>es5的createClass：每个成员函数的this由React自动绑定，任何时候使用，直接this.method即可，this会被正确的设置；在getInitialState中配置组件相关的状态。</li>
<li>es6的Component：其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。绑定的方式有三种：在构造函数中绑定，如下所示。在调用时使用<code>method.bind(this)</code>绑定。还可以用箭头函数绑定；可以在constructor中统一声明和绑定。最终会呈现<code>React.createClass</code>的形式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputControlES6</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">text</span>: props.initialValue || <span class="string">'placeholder'</span></div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//es6类中函数必须手动绑定，否则this不能获取当前组件实例对象，第一种方式</span></div><div class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    handleChange(event)&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            <span class="attr">text</span>: event.target.value</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">        	&lt;div&gt;</div><div class="line">            	Type something:</div><div class="line">            	&lt;input onChange=&#123;this.handleChange.bind(this)//第二种方式</div><div class="line">    &#125; value=&#123;this.state.text&#125; /&gt;</div><div class="line">				&lt;input onClick=&#123;()=&gt;this.handleClick() //第三种方式绑定</div><div class="line">                &#125;/&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>参考：<a href="http://www.cnblogs.com/wonyun/p/5930333.html" target="_blank" rel="noopener">http://www.cnblogs.com/wonyun/p/5930333.html</a></li>
</ul>
<h4 id="React中的数据流"><a href="#React中的数据流" class="headerlink" title="React中的数据流"></a>React中的数据流</h4><ul>
<li>父子组件沟通：传递props</li>
<li>子父组件沟通：父组件传递回调函数给子组件，子组件调用触发</li>
<li>兄弟组件沟通：一、通过父组件回调函数改变兄弟组件的props；二、通过react中的context</li>
<li>全局事件：redux</li>
<li>ref：在典型数据流外（props）强制修改子组件<ul>
<li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回。</li>
<li>ref更新发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前。</li>
<li>不要在render方法中访问ref，因为这时组件不一定挂载到DOM中或render返回的虚拟DOM不一定会更新到DOM中。</li>
<li>通过<code>ReactDOM.findDOMNode(ref)</code>来获取组件挂载之后真正的DOM节点。</li>
<li>可以设置回调函数或者字符串</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Refs，通过ref属性获得React元素</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.myRef = React.createRef();</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span> &lt;div ref = &#123;this.myRef&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//访问Refs</div><div class="line">const node = this.myRef.current;</div><div class="line">//为DOM元素添加Ref</div><div class="line">class CustomTextInput extends React.Component&#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props);</div><div class="line">        //创建ref存储textInput DOM元素</div><div class="line">        this.textInput = React.createRef();</div><div class="line">        this.focusTextInput = this.focusTextInput.bind(this);</div><div class="line">    &#125;</div><div class="line">    focusTextInput()&#123;</div><div class="line">        //直接使用原生API使text输入框获得焦点</div><div class="line">        //通过current取得DOM节点</div><div class="line">        this.textInput.current.focus();</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        //告诉React我们想把&lt;input&gt;ref关联到构造器里创建的textInput上</div><div class="line">        return (</div><div class="line">        	&lt;div&gt;</div><div class="line">            	&lt;input</div><div class="line">            		type="text"</div><div class="line">            		ref=&#123;this.textInput&#125;</div><div class="line">            	/&gt;</div><div class="line">            	&lt;input</div><div class="line">            		type="button"</div><div class="line">            		value="Focus the text input"</div><div class="line">            		onClick=&#123;this.focusTextInput&#125;</div><div class="line">            	/&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//为类组件添加Ref</div><div class="line">class AutoFocusTextInput extends React.Component&#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props);</div><div class="line">        this.textInput = React.createRef();</div><div class="line">    &#125;</div><div class="line">    componentDidMount()&#123;</div><div class="line">        this.textInput.current.focusTextInput();</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        return (</div><div class="line">        	&lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//回调函数的方式在实例的属性中存储对DOM的引用</div><div class="line">componentDidMount()&#123;</div><div class="line">    Echarts.init(this.element).setOption(pieOption);</div><div class="line">&#125;</div><div class="line">render()&#123;</div><div class="line">    return &lt;div style = &#123;chartStyle&#125; ref = &#123;ref =&gt; this.element = ref&#125; /&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>参考：<a href="https://segmentfault.com/a/1190000006831820" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006831820</a></li>
</ul>
<h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><ul>
<li><p>componentWillMount</p>
<ul>
<li>请求数据会执行两次：服务器端没有did方法，因为涉及到DOM渲染，只能在浏览器端。如果做服务器端渲染，则会执行两次，否则是一样的。</li>
<li>在React16.3中被认为是不安全的方法。使用者常常把首屏数据和事件订阅放在这个生命周期中。但是首屏数据可能是异步的，在这个生命周期里用setState产生的变化可能不会被更新；其次，事件订阅如果放在这个生命周期中，不保证该事件在willUnmount中被撤销。只有放在componentDidMount中才能保证一定会执行componentWillUnmount，可能造成内存泄漏。在新版本中，componentWillMount中可以做的事情建议放在componentDidMount中。</li>
</ul>
</li>
<li><p>componentWillReceiveProps</p>
<p>在React16.3中被认为是不安全的方法。他的问题是多次props改变可能在子组件中多次发送异步请求，造成浪费。getDeivedstateFromProps则是接收到props的变化后，确认state改变了，才在componentDidUpdate中执行异步请求。</p>
</li>
<li><p>getSnapshotBeforeUpdate</p>
<p>在更新之前被调用，返回值将作为第三个参数传递给componentDidUpdate。与componentDidUpdate一起，这个生命周期函数将覆盖旧版componentWillUpdate的所有用例。</p>
</li>
<li><p>参考：<a href="https://github.com/frontend9/fe9-library/issues/6" target="_blank" rel="noopener">https://github.com/frontend9/fe9-library/issues/6</a></p>
</li>
</ul>
<h4 id="受控组建与非受控组件"><a href="#受控组建与非受控组件" class="headerlink" title="受控组建与非受控组件"></a>受控组建与非受控组件</h4><p>引入原生HTML表单元素（input、select、textarea）时，是否应该将所有的数据托管到React组件中还是仍保留在DOM元素中。</p>
<ul>
<li>受控组件：交由React控制并且所有的表单数据统一存放的组件。数据存放在state中，调用setState修改数据；</li>
<li>非数控组件：由DOM存放表单数据，使用refs操控DOM元素。</li>
</ul>
<h4 id="React项目小经验积累"><a href="#React项目小经验积累" class="headerlink" title="React项目小经验积累"></a>React项目小经验积累</h4><ul>
<li>使用 PropTypes 和 getDefaultProps()：非预期情况下，获得警告</li>
<li>component –&gt; pureComponent<ul>
<li>在state和props真正改变的时候重新渲染，减少渲染次数（浅比较）</li>
<li>因为纯组件忽略重新渲染时，不仅会影响它本身，而且会影响它的所有子元素。所以它适合在展示组件，无状态组件中使用。没有子组件和依赖应用的全局状态。</li>
<li>每次更新state时，需返回一个新对象</li>
<li>当有常变化的部分（输入框的改变事件）和一般不变化的部分（列表）在一起时，可以将不变的列表部分抽出用pureComponent表示</li>
<li>使用匿名函数传递props会失去pureComponent的优势，因为每次渲染都会创建一个新的函数</li>
</ul>
</li>
<li>动态多个className：引入库classnames。</li>
<li><code>You cannot set field before registering it.</code>不能在注册之前设置值，是说设置了没有注册的表单，需要删除响应的数据。比如项目中要保留查询条件，通过将查询条件设置到url上实现，要返回到查询结果页面，则从url上取值查询刷新页面。这时查询条件中的分页信息需要先去掉。</li>
<li><code>data.pageNum | 0</code>任何类型转换成数字，<code>+(undefined)</code>是NaN，<code>undefined|0</code>是0。</li>
<li>级联表单思路：在antd中，监听第一个表单的onchange事件，获得改变后的值传入回调函数获取下一个表单应该有的值列表，通过form.setFieldsValue设置给下一个表单。</li>
<li>异步加载组件：不是一开始就全部加载完成所有组件，而是匹配到哪个路由，才去加载这个组件。</li>
<li>参考：<ul>
<li><a href="https://segmentfault.com/a/1190000005013207" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005013207</a></li>
<li><a href="https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs-2344.html" target="_blank" rel="noopener">https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs-2344.html</a></li>
<li><a href="https://segmentfault.com/a/1190000010067597" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010067597</a></li>
</ul>
</li>
</ul>
<p>其他参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/24856035?utm_medium=social&amp;utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24856035?utm_medium=social&amp;utm_source=wechat_session</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24781259?refer=wxyyxc1992" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24781259?refer=wxyyxc1992</a></li>
<li><a href="https://juejin.im/entry/5a0eb032f265da43294da014" target="_blank" rel="noopener">React模式-https://juejin.im/entry/5a0eb032f265da43294da014</a></li>
<li><a href="https://knownsec-fed.com/2018-01-28-fan-yi-react-zu-jian-mo-shi/" target="_blank" rel="noopener">https://knownsec-fed.com/2018-01-28-fan-yi-react-zu-jian-mo-shi/</a></li>
<li><a href="https://tyrmars.gitbooks.io/react-steppitguide/content/React-01" target="_blank" rel="noopener">https://tyrmars.gitbooks.io/react-steppitguide/content/React-01</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/跨域大法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/跨域大法总结/" itemprop="url">跨域大法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T12:05:20+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="跨域的那些事"><a href="#跨域的那些事" class="headerlink" title="跨域的那些事"></a>跨域的那些事</h3><p>跨域问题的出现是因为浏览器有同源策略的限制，制定同源策略是因为防止接口请求和DOM查询中可能出现的危险情况。</p>
<p>举例子：如果没有同源策略</p>
<ul>
<li><p>接口请求：<br>登入淘宝网站，验证成功后，服务器会在响应头加入Set-Cookie字段，再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。在看买什么东西的过程中，有人发来一个链接，出于好奇，打开链接查看内容。下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中。这样一来，如果这个链接是不法网站，就相当于登录了你的账号，可以为所欲为了。(CSRF攻击)</p>
</li>
<li><p>DOM查询：<br>收到长得像安全网站的危险网址，该网址引用安全网站放入框架标签中，使你输入了用户名和密码。他可以获取到安全网站的dom，从而获取到你输入的用户名密码，开始为所欲为。</p>
</li>
</ul>
<p>同源限制的情况下的跨域策略：</p>
<ul>
<li>JSONP<br>  利用了script标签的src这种获取资源的标签没有跨域限制。定义请求成功后要执行的函数，将该函数名做为callback参数传给服务器。服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。（jQuery把它封装进了ajax，但是它们是本质上不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">window</span>.jsonpCb = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(res)</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://localhost:9871/api/jsonp?msg=helloJsonp&amp;cb=jsonpCb'</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>封装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> request = <span class="function">(<span class="params">&#123;url, data&#125;</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">		<span class="keyword">const</span> handleData = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</div><div class="line">     		<span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">     		<span class="keyword">const</span> keysLen = keys.length</div><div class="line">     		<span class="keyword">return</span> keys.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</div><div class="line">       		<span class="keyword">const</span> value = data[cur]</div><div class="line">       		<span class="keyword">const</span> flag = index !== keysLen - <span class="number">1</span> ? <span class="string">'&amp;'</span> : <span class="string">''</span></div><div class="line">       		<span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span><span class="subst">$&#123;cur&#125;</span>=<span class="subst">$&#123;value&#125;</span><span class="subst">$&#123;flag&#125;</span>`</span></div><div class="line">     		&#125;, <span class="string">''</span>)</div><div class="line">     	&#125;</div><div class="line">   	<span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</div><div class="line">    	<span class="built_in">window</span>.jsonpCb = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">      	<span class="built_in">document</span>.body.removeChild(script)</div><div class="line">      	<span class="keyword">delete</span> <span class="built_in">window</span>.jsonpCb</div><div class="line">      	resolve(res)</div><div class="line">    	&#125;</div><div class="line">    	script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;handleData(data)&#125;</span>&amp;cb=jsonpCb`</span></div><div class="line">    	<span class="built_in">document</span>.body.appendChild(script)</div><div class="line">  	&#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用方式</span></div><div class="line">request(&#123;</div><div class="line">	<span class="attr">url</span>: <span class="string">'http://localhost:9871/api/jsonp'</span>,</div><div class="line"> 	<span class="attr">data</span>: &#123;</div><div class="line">   	<span class="attr">msg</span>: <span class="string">'helloJsonp'</span></div><div class="line"> 	&#125;</div><div class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">  	<span class="built_in">console</span>.log(res)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>JSONP的方式是GET请求，如果想使用POST请求，可以用空iframe + form</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> requestPost = <span class="function">(<span class="params">&#123;url, data&#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 首先创建一个用来发送数据的iframe.</span></div><div class="line">  <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</div><div class="line">  iframe.name = <span class="string">'iframePost'</span></div><div class="line">  iframe.style.display = <span class="string">'none'</span></div><div class="line">  <span class="built_in">document</span>.body.appendChild(iframe)</div><div class="line">  <span class="keyword">const</span> form = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>)</div><div class="line">  <span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>)</div><div class="line">  <span class="comment">// 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话.</span></div><div class="line">  iframe.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'post success'</span>)</div><div class="line">  &#125;)</div><div class="line">  form.action = url</div><div class="line">  <span class="comment">// 在指定的iframe中执行form</span></div><div class="line">  form.target = iframe.name</div><div class="line">  form.method = <span class="string">'post'</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> data) &#123;</div><div class="line">    node.name = name</div><div class="line">    node.value = data[name].toString()</div><div class="line">    form.appendChild(node.cloneNode())</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 表单元素需要添加到主文档中.</span></div><div class="line">  form.style.display = <span class="string">'none'</span></div><div class="line">  <span class="built_in">document</span>.body.appendChild(form)</div><div class="line">  form.submit()</div><div class="line">  <span class="comment">// 表单提交后,就可以删除这个表单,不影响下次的数据发送.</span></div><div class="line">  <span class="built_in">document</span>.body.removeChild(form)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用方式</span></div><div class="line">requestPost(&#123;</div><div class="line">  <span class="attr">url</span>: <span class="string">'http://localhost:9871/api/iframePost'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">msg</span>: <span class="string">'helloIframePost'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>总结：他的优势在于兼容性，可以支持老版浏览器，当浏览器不支持CORS的情况下，可以用该方法实现跨域请求。</p>
<ul>
<li>CORS跨域资源共享cross-origin resource sharing</li>
</ul>
<blockquote>
<p>CORS需要浏览器和服务器同时支持。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。</p>
</blockquote>
<p>又分为简单请求和非简单请求：</p>
<p>在简单请求中，前端什么也不用干，浏览器在头信息之中，增加一个Origin字段，服务器根据这个值，决定是否同意这次请求。如果Origin指定的源不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
<p>非简单请求会发出一次预检测请求，返回码是204，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段，”预检”请求用的请求方法是OPTIONS，服务器检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求。如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p>有几种发生错误的情况：</p>
<ol>
<li><code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 404</code>：本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS)；服务器端后台接口没有允许OPTIONS请求,导致无法找到对应接口地址<br> 解决：后端允许options请求</li>
<li><code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 405</code>：这种现象和第一种有区别,这种情况下，后台方法允许OPTIONS请求,但是一些配置文件中(如安全配置),阻止了OPTIONS请求,才会导致这个现象<br> 解决: 后端关闭对应的安全配置</li>
<li><code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且status 200</code>：这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象。比如origin头部检查不匹配,比如少了一些头部的支持(如常见的X-Requested-With头部),然后服务端就会将response返回给前端,前端检测到这个后就触发XHR.onerror,导致前端控制台报错<br> 解决: 后端增加对应的头部支持</li>
<li><code>heade contains multiple values &#39;*,*&#39;</code>：表现现象是，后台响应的http头部信息有两个Access-Control-Allow-Origin:*，重复配置<br> 解决：只用项目配置中的即可</li>
<li>还有request的Accept和response的Content-Type不匹配会出现406的错误。</li>
</ol>
<p>后台node跨域配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</div><div class="line">    res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"X-Requested-With"</span>);</div><div class="line">    res.header(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</div><div class="line">    res.header(<span class="string">"X-Powered-By"</span>, <span class="string">' 3.2.1'</span>)</div><div class="line">    res.header(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</div><div class="line">    <span class="keyword">if</span>(req.method == <span class="string">'OPTIONS'</span>) &#123;</div><div class="line">        <span class="comment">//让options请求快速返回</span></div><div class="line">        res.sendStatus(<span class="number">200</span>); </div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line">        next(); </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>优化：OPTIONS预检的优化<br><code>Access-Control-Max-Age:</code>这个头部加上后，可以缓存此次请求的秒数。在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据。</p>
<p>总结：比JSONP更强大，支持多种请求类型，不考虑兼容性问题（如IE 10），CORS是更通用的做法。</p>
<ul>
<li>代理：有东西帮我们把请求转到真正的后端域名</li>
</ul>
<ol>
<li>使用Nginx，它是一个Linux 容器解决方案（虚拟机就是软件带环境安装的一种解决方案。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。启动容器就相当于启动了本机的一个进程）。Nginx 的最大作用，就是搭建一个 Web Server。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line">    # 监听9099端口</div><div class="line">    listen 9099;</div><div class="line">    # 域名是localhost</div><div class="line">    server_name localhost;</div><div class="line">    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 </div><div class="line">    location ^~ /api &#123;</div><div class="line">        proxy_pass http://localhost:9871;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前端请求时可以用本地的地址做请求，Nginx监听到凡是localhost:9099/api这个样子的，就转发转发到真正的服务端地址上。</p>
<ol>
<li>webpack中引用webpack-dev-server来进行配置跨域方案（线下开发环境）。webpack-dev-server是一个小型的nodejs服务器，是基于express框架的，用于实时监听和打包编译静态资源。其中里面有一个属性是proxy，是专门来配置代理请求接口的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">devServer: &#123;</div><div class="line">   <span class="attr">contentBase</span>: __dirname + <span class="string">"/"</span>,</div><div class="line">   <span class="attr">port</span>: <span class="number">9000</span>,</div><div class="line">   <span class="attr">proxy</span>: &#123;</div><div class="line">     <span class="string">"/users"</span>: &#123;    <span class="comment">//需要代理的路径</span></div><div class="line">       target: <span class="string">"http://jsonplaceholder.typicode.com"</span>,  <span class="comment">//需要代理的域名</span></div><div class="line">       changeOrigin: <span class="literal">true</span>  <span class="comment">//必须配置为true，才能正确代理</span></div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果么有使用webpack做项目自动化，而是其他的如gulp，则直接引入http-proxy-middleware模块。webpack-dev-server就是引入了这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.use(<span class="string">'/users'</span>, proxy(&#123;</div><div class="line">    <span class="attr">target</span>: <span class="string">"http://jsonplaceholder.typicode.com"</span>,</div><div class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span></div><div class="line">&#125;));</div><div class="line"><span class="comment">// 省略各种配置  ... ...</span></div><div class="line">app.listen(..., <span class="number">9000</span>);</div></pre></td></tr></table></figure>
<ol>
<li>自己搭建一个node服务器做代理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>); </div><div class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>); </div><div class="line"><span class="keyword">var</span> app = express(); </div><div class="line">app.use(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; </div><div class="line">	<span class="keyword">var</span> url = <span class="string">'https://www.baidu.com/'</span> + req.url;</div><div class="line">	req.pipe(request(url)).pipe(res); <span class="comment">//关键代码</span></div><div class="line">&#125;); </div><div class="line">app.listen(process.env.PORT || <span class="number">3000</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>总结：Nginx线上线下都需要配置。使用要看场景，如果后端接口是一个公共的API，比如一些公共服务获取天气，前端调用的时候总不能让运维去配置一下Nginx；webpack-dev-server和http-proxy-middleware都是开发环境下需要使用的跨域解决方案，一般说的跨域解决方案还是指线上用CORS。</p>
<ul>
<li>window.postMessage() 是HTML5的一个接口<br>发消息方在页面中定义一个iframe，<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"postMessage"</span>&gt;</span>给http://crossDomain.com:9099发消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"crossDomainIframe"</span> <span class="attr">src</span>=<span class="string">"http://crossdomain.com:9099"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>利用框架向别的窗口发送消息<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  mounted () &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (e.origin === <span class="string">'http://crossdomain.com:9099'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(e.data)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    postMessage () &#123;</div><div class="line">      <span class="keyword">const</span> iframe = <span class="built_in">window</span>.frames[<span class="string">'crossDomainIframe'</span>]</div><div class="line">      iframe.postMessage(<span class="string">'我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom'</span>, <span class="string">'http://crossdomain.com:9099'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收消息方：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  mounted () &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (e.origin === <span class="string">'http://localhost:9099'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(e.data)</div><div class="line">        e.source.postMessage(<span class="string">`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：<span class="subst">$&#123;<span class="built_in">document</span>.getElementById(<span class="string">'app'</span>) ? <span class="string">'有id为app的Dom'</span> : <span class="string">'没有id为app的Dom'</span>&#125;</span>`</span>, e.origin);</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结：window.postMessage() 需要在页面加载完毕后才能进行跨域通信，但是我们无法检测目标页面的onload事件，所以只能使用setTimeout和setInterval来处理。如果不希望从其他网站接收message，不要为message事件添加任何事件侦听器。如果希望从其他网站接收message，始终使用origin和source属性验证发件人的身份。当使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*。</p>
<ul>
<li>document.domain<br>举例：<br>主域名：<a href="http://crossdomain.com:9099，" target="_blank" rel="noopener">http://crossdomain.com:9099，</a><br>子域名：<a href="http://child.crossdomain.com:9099，" target="_blank" rel="noopener">http://child.crossdomain.com:9099，</a><br>给两个页面设置：document.domain = crossdomain.com</li>
</ul>
<p>总结：这种方式只适合主域名相同，但子域名不同的iframe跨域。它有一些副作用：修改了document.domain，则在某些机器上的IE678里，获取location.href有权限异常；它包含的iframe，必须也设domain，才能进行交互。就算是同域的页面也必须要设；也会影响到其它跟iframe有关的功能。</p>
<ul>
<li><p>canvas图片跨域<br>第一步，图片服务器需要配置Access-Control-Allow-Origin信息（一般团队都会有一个专门域名放置静态资源，例如腾讯是gtimg.com，百度是bdimg.com）；<br>第二步，如果想更进一步，通过canvas的getImageData()方法获取图片的完整的像素信息，会因为跨域问题而出错。HTML5的<code>&lt;img&gt;，&lt;video&gt;，&lt;script&gt;</code>提供了支持CORS(Cross-Origin Resource Sharing)（跨域资源共享）的属性：crossOrigin。只需要添加<code>img.crossOrigin = &#39;&#39;（先创建Image实例）;</code>就可以解决问题（IE9/10不支持）；<br>第三步，如果想在IE10中实现跨域，可以借助ajax和URL.createObjectURL()方法解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> url = URL.createObjectURL(<span class="keyword">this</span>.response);</div><div class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        URL.revokeObjectURL(url);</div><div class="line">    &#125;;</div><div class="line">    img.src = url;</div><div class="line">&#125;;</div><div class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">xhr.responseType = <span class="string">'blob'</span>;</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
</li>
<li><p><a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html</a></p>
</li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li><a href="https://www.cnblogs.com/jkisjk/archive/2013/05/30/change_document_domain.html" target="_blank" rel="noopener">https://www.cnblogs.com/jkisjk/archive/2013/05/30/change_document_domain.html</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/</a></li>
<li><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015597029</a></li>
<li><a href="https://www.cnblogs.com/dojo-lzz/p/4265637.html" target="_blank" rel="noopener">https://www.cnblogs.com/dojo-lzz/p/4265637.html</a></li>
<li><a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012469713</a></li>
<li><a href="https://www.cnblogs.com/canfoo/p/6912306.html" target="_blank" rel="noopener">https://www.cnblogs.com/canfoo/p/6912306.html</a></li>
<li><a href="https://www.jianshu.com/p/50d82333b22a" target="_blank" rel="noopener">https://www.jianshu.com/p/50d82333b22a</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/git协作篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/git协作篇/" itemprop="url">git协作篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T19:45:27+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>创建一个新项目分支<br>开发一个新项目，假设新建项目分支名为：sec-projectName，执行步骤如下：</p>
<pre><code>1.    切换到本地主干分支：git checkout master  
2.    拉取主干最新代码：  git pull
3.    从最新主干切出项目分支： git checkout -b sec-projectName
4.    推送到远端 git push -u origin sec-projectName (加上-u 参数表示关联远端，远端分支名和本地保持一致)
</code></pre><p>项目迭代<br>如果sec-projectName这个项目开发完成上线，现需要二期开发，直接从sec-projectName切出一个二期分支sec-projectName-xx<br>二期新功能在sec-projectName-xx分支上开发，开发完成合并到sec-projectName，然后上线。<br>从远端切出一个分支<br>如果远端已经存在一个分支sec-projectName-test，此时你需要从远端拉取这个分支进行开发，操作如下：<br>git checkout –track origin/sec-projectName-test<br>该操作的意思是：直接从远端拉取这个分支到本地，新建一个分支sec-projectName-test，并且和远端保持关联<br>本地分支和远端分支保持关联的作用<br>如果本地分支关联了远端分支，本地分支推送到远端的时候可以不用指定远端分支名，直接git push<br>如果本地分支没有关联远端分支，本地分支推送到远端的时候需要手动指定远端分支名，例如： git push origin xxxName<br>如何关联远端分支</p>
<pre><code>1.    如果在本地新建一个分支名为project-name的分支，首次推送到远端的时候加上 -u 参数，即可和远端建立关联。例如：git push -u origin project-name，下次推送改分支的时候直接git push即可
2.    在从远端切出一个分支的时候可以直接建立关联，使用git checkout --track origin/sec-projectName-test ，本地sec-projectName-test和远端sec-projectName-test就直接建立了关联
</code></pre><p>常用命令：</p>
<pre><code>1.    git branch -a 查看所有分支
2.    git checkout &lt;分支名&gt;  切换到对应分支上
3.    git checkout -b &lt;分支名&gt; 新拉一条&lt;分支名&gt;的分支
4.    git reset --hard 【版本号前4位】回退到对应的版本
5.    git reset --hard HEAD^ 回退到上一个版本，一个^ 表示一个版本，如果为^^^ 则表示，回退到上上上个版本，以此类推
</code></pre><p>git 提交<br>git 最好频繁提交，我们建议多次少量提交，而不是一次巨量的提交，开发完一个小功能，小模块就提交一次，以免代码丢失。<br>不同功能尽量分开分多次提交，不要一次性提交一堆文件<br>提交的时候，提交日志必须写清楚，需要随意写个xxx，要保持良好的规范，大致规范如下<br>提交 commit 的类型，包括以下几种<br>    •    feat: 新功能<br>    •    fix: 修复问题<br>    •    docs: 修改文档<br>    •    style: 修改代码格式，不影响代码逻辑<br>    •    refactor: 重构代码，理论上不影响现有功能<br>    •    perf: 提升性能<br>    •    revert: 回退，建议直接使用Github Desktop回退，而不是使用命令<br>    •    logic 逻辑完善</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/09/好多好多的字符串操作方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/好多好多的字符串操作方法/" itemprop="url">好多好多的字符串操作方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T11:41:11+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/calculate/" itemprop="url" rel="index">
                    <span itemprop="name">calculate</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>concat()</li>
</ul>
<p>用于将一个或多个字符串拼接起来，返回得到新的字符串。多数情况下会用’+’进行字符串的拼接。</p>
<ul>
<li><p>基于子字符串创建新字符串的方法，都会返回新的被操作字符串的一个子字符串，也都接受一个或两个参数。第一个参数指定子字符串的开始位置，第二个参数表示子字符串哪里结束。</p>
<ul>
<li>slice()：第二个参数是最后一个字符后面的位置，传入的负值会与字符串长度相加。该方法中的第一个参数是必需的。</li>
<li>substr()：第二个参数是返回的字符串的长度，第一个负值加上字符串长度，第二个负值转换为0</li>
<li><p>substring()：第二个参数是最后一个字符后面的位置，所有负值转换为0</p>
</li>
<li><p>slice和substring的第二个参数指定是子字符串最后一个字符的后面的位置；substr()的第二个参数指定的是返回的字符个数。</p>
</li>
</ul>
</li>
<li><p>字符串位置方法</p>
<ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
<li>trim():function trim(string){return string.replace(/^\s+|\s+$/g,’’)}</li>
</ul>
</li>
<li><p>大小写转换方法：返回新的字符串</p>
<ul>
<li>toLowerCase()</li>
<li>toLocaleLowerCase()</li>
<li>toUpperCase()</li>
<li>toLocaleUpperCase()</li>
</ul>
</li>
<li><p>字符串的模式匹配方法</p>
<ul>
<li>match():返回数组</li>
<li>search()：返回1/-1</li>
<li>replace():返回新的字符串</li>
<li>split()：返回数组，可接受两个参数，第二个参数指定数组的长度</li>
</ul>
</li>
<li><p>localeCompare()：比较两个字符串的位置，返回-1/0/1</p>
</li>
<li><p>fromCharCode()：String构造函数的静态方法，接受一个或多个字符编码，转换为字符串。</p>
</li>
<li><p>HTML方法，尽量不使用，因为创建的标记无法表达语义。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/09/正则表达式之match与exec/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/正则表达式之match与exec/" itemprop="url">正则表达式之match与exec</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T10:33:57+08:00">
                2018-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js中与正则表达式有关的匹配字符串函数：RegExp的方法exec(string)以及String类的match(regex)。</p>
<p>首先，他们返回的都是数组。</p>
<p>其次，如果没有分组：</p>
<ul>
<li><p>在正则表达式没有g属性的情况下，exec与match得到的结果一致，返回第一个匹配项。</p>
</li>
<li><p>如果有g属性，则match回返回所有匹配项。</p>
</li>
</ul>
<p>如果有分组：</p>
<ul>
<li>没有g属性，match与exec一样，返回的数组中包含多个元素（匹配的子元素，而不是所有的同级元素）。</li>
<li>有g属性，exec不受影响，match返回所有匹配的元素。</li>
</ul>
<p>习题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someText=<span class="string">"web2.0 .net2.0"</span>;</div><div class="line"><span class="keyword">var</span> pattern=<span class="regexp">/(\w+)(\d)\.(\d)/g</span>;</div><div class="line"><span class="keyword">var</span> outCome_exec=pattern.exec(someText);</div><div class="line"><span class="keyword">var</span> outCome_matc=someText.match(pattern);</div><div class="line"></div><div class="line"><span class="comment">//What is outCome_exec[1] and outCome_matc[1]?</span></div></pre></td></tr></table></figure>
<p>总的来说，RegExp对象有3个方法可以用来匹配：test()、exec()和compile(将字符串形式的正则表达式编译为Pattern对象)。<br>String对象有四个方法可以用来匹配：match(pattern)、replace(pattern, replacement)、search(pattern)、split(pattern)。</p>
<p>材料：</p>
<ul>
<li><a href="https://www.cnblogs.com/xiehuiqi220/archive/2008/12/01/1327487.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehuiqi220/archive/2008/12/01/1327487.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/07/结识Vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/结识Vue/" itemprop="url">结识Vue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T15:51:27+08:00">
                2018-04-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h5><p>Vue实例在被创建时要经过一系列初始化过程，如设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等，同时运行一些生命周期钩子函数，让用户可以在不同阶段添加自己的代码。</p>
<p>生命周期钩子的this上下文指向调用它的Vue实例。不要在选项属性或回调上使用箭头函数，比如created:() =&gt; console.log(this.a)。因为箭头函数是和父级上下文绑定在一起的，this不会指向Vue实例。</p>
<p>具体又有：</p>
<ul>
<li>beforeCreate：在实例初始化之后，数据观测(data observer)和event/watcher事件配置之前被调用。</li>
<li>created：在实例创建完成后被立即调用。已完成数据观测和事件配置之后，挂载还没有开始。$el属性目前不可见。</li>
<li>beforeMount：挂载之前被调用。服务器渲染期间不被调用。</li>
<li>mounted：挂载到实例上后调用。服务器渲染期间不调用。</li>
<li>beforeUpdate-nextTick：数据更新时调用，适合在更新之前访问现有的DOM，如手动移除已添加的事件监听器。只有初次渲染会在服务器端进行，其他时间不被调用。</li>
<li>updated-nextTick：数据更新导致虚拟DOM重新渲染和打补丁，之后调用该函数。服务器渲染期间不被调用。</li>
<li>activated：keep-alive组件激活时调用，服务器渲染期间不被调用。</li>
<li>deactivated：keep-alive组件停用时调用。服务器端渲染期间不被调用。</li>
<li>beforeDestroy：实例销毁之前调用，服务器端渲染期间不被调用。</li>
<li>destroyed：实例销毁后调用，子实例也会被销毁。</li>
<li>errorCaptured：捕获一个来自子孙组件的错误时被调用。接收三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。可以返回false阻止错误向上传播。</li>
</ul>
<h5 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h5><p>父子间：单向数据流，prop单向绑定，父组件属性变化，传导给子组件，反之不会。防止子组件无意间修改父组件的状态，避免应用的数据流难以理解。</p>
<p>父组件在使用子组件处传递的参数称为子组件可以获取的数据，子组件显式地用props声明数据。<br>父组件在使用子组件处使用v-on监听子组件触发的事件，子组件通过this.$emit()报告自己的内部事件。<br>子组件不应该在内部修改prop，子组件通过事件给父组件发送消息。</p>
<p>想在某组件的根元素上监听一个原生事件，可以使用v-on修饰符.native。</p>
<p>非父子组件的通信，使用Vue实例作为事件总线：var bus = new Vue();bus.$emit(‘id-selected’,1);bus.$on(‘id-selected’,function(id){})</p>
<h5 id="双向绑定如何实现，有什么缺点？"><a href="#双向绑定如何实现，有什么缺点？" class="headerlink" title="双向绑定如何实现，有什么缺点？"></a>双向绑定如何实现，有什么缺点？</h5><ul>
<li>如何追踪变化？</li>
</ul>
<p>当把一个普通的js对象传给vue实例的data选项，vue将遍历对象的所有属性，用Object.defineProperty把这些属性全部转换为getter/setter.这些getter/setter对用户来说是不可见的，但是在内部它们让vue追踪依赖，在属性被访问和修改时通知变化。（浏览器控制台在打印数据对象的getter/setter的格式并不同，借助vue-devtools获取更加友好的检查接口）。</p>
<p>每个实例都有响应的watcher实例对象，会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。vue不能检测到对象属性的添加或删除。vue会在初始化实例时对属性执行getter/setter转化过程，所以属性必须在data对象上存在才能让vue转化它，这样才是响应的。</p>
<ul>
<li>检测变化注意事项：</li>
</ul>
<p>vue不允许在已经创建的实例上动态添加新的根级响应式属性，然而可以使用Vue.set(object, key, value)方法将响应属性添加到嵌套的对象上。（vm.$set实例方法）。</p>
<p>想向已有对象添加一些属性，如Object.assign()/_.extend()方法添加属性。但是添加到对象上的新属性不会触发更新，这时可以创建一个新的对象，让它包含原对象的属性和新的属性：this.someObject = Object.assign({}, this.someObject, {a:1,b:2})</p>
<p>不能检测以下变动的数组：</p>
<ul>
<li>利用索引直接设置一个项时，vm.items[indexOfItem] = newValue;解决：Vue.set(vm.items, indexOfItem, newValue)/vm.items.splice(indexOfItem, 1, newValue)</li>
<li>当修改数组的长度时，vm.items.length = newLength;解决：vm.items.splice(newLength)</li>
<li>为对象赋予多个新属性，比如用Object.assign()或_.extend()。vm.userProfile = Object.assign({}, vm.userProfile,{age: 27, favoriteColor: ‘Vue Green’}).</li>
</ul>
<ul>
<li><p>声明响应式属性</p>
<ul>
<li>由于Vue不允许动态添加根级响应式属性，所以必须在初始化实例前声明根级响应式属性，哪怕只是一个空值。</li>
<li>这样限制消除了在依赖项跟踪系统中的一类边界情况，也使Vue实例在类型检查系统的帮助下运行的更高效；可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。</li>
</ul>
</li>
<li><p>异步更新队列</p>
<ul>
<li>vue异步执行DOM更新。数据变化，vue开启一个队列，缓冲在同一事件循环中发生的所有数据变化。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常重要。然后在下一个事件循环tick中，vue刷新队列并执行实际（已去重）工作。vue在内部尝试对异步队列使用原生的Promise.then和MessageChannel，如果执行环境不支持，会采用setTimeout(fn,0)代替。</li>
<li>设置vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空的下一个tick更新。如果想在DOM状态更新后做点什么，会比较棘手。为了在数据变化之后等待vue完成更新dom，可以在数据变化之后立即使用Vue.nextTick(callback)。这样回调函数在DOM更新完成后就会调用。</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
</ul>
<p>双向绑定是vue实例中data与其渲染的DOM元素的内容保持一致，通过设置属性访问器实现的。<br>vue中实现双向绑定的指令是v-model，主要用于input、select、textarea这些表单元素上。<br>不知道data什么时候变化，是谁变化，变化后不会通知。有watcher，但是比较复杂。<br><a href="https://blog.csdn.net/zhouziyu2011/article/details/71576677" target="_blank" rel="noopener">https://blog.csdn.net/zhouziyu2011/article/details/71576677</a></p>
<h5 id="计算属性与method"><a href="#计算属性与method" class="headerlink" title="计算属性与method"></a>计算属性与method</h5><p>写法不同：method（）<br>缓存不同：computed是将方法与data对象绑定，只有data对象变化时才触发方法；method是每次进入页面就要执行方法，在利用实时信息时，比如显示进入页面的事件，就用methods。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>指令：v-bind，可接收参数，参数后面有修饰符</li>
<li>条件与循环：v-if;v-for</li>
<li>事件监听：v-on</li>
<li>双向绑定：v-model，在表单输入与应用状态之间</li>
<li>带前缀$的实例属性和方法，为了和用户定义的属性区分开</li>
<li>一次性插入：v-once</li>
<li>输出真正的html：v-html</li>
<li>用在html特性上：v-bind</li>
<li>缩写：v-bind:href–:href; v-on:click–@click</li>
<li>watch：自定义的侦听器，响应数据的变化（数据变化时执行异步或开销较大的操作）</li>
</ul>
<p><a href="https://blog.csdn.net/tashanhongye/article/details/76284373" target="_blank" rel="noopener">https://blog.csdn.net/tashanhongye/article/details/76284373</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/06/网络通讯原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/06/网络通讯原理/" itemprop="url">网络通讯原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-06T20:04:52+08:00">
                2018-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><p>管理和控制计算机硬件和软件的计算机程序，最基本的系统软件，其他软件必须在操作系统支持下运行。</p>
<h5 id="网络通信原理"><a href="#网络通信原理" class="headerlink" title="网络通信原理"></a>网络通信原理</h5><p>硬件 + 操作系统 + 软件 = 个人可用设备 + 网络协议 + 个人可用设备 = 互联网（本质就是一系列的协议）。</p>
<p>互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。</p>
<p>OSI七层协议：按照功能不同可以分为osi七层、tcp/ip五层或tcp/ip四层</p>
<p><img src="/2018/04/06/网络通讯原理/osi协议.png" alt="OSI七层协议"></p>
<p>物理层是电器特性发送高低电压（高电压为1，低电压为0）；</p>
<p>数据链路层规定了电信号多少位一组，每组什么意思，定义了电信号的分组方式（以太网协议）：</p>
<ul>
<li>一组电信号构成一个数据包，叫帧（64-1518字节），超过最大限制就分片发送；</li>
<li>每一数据帧分成：报头head（固定18字节）和数据data（46-1500字节）两部分；</li>
</ul>
<p>网络层采用ip协议区分哪些计算机属于同一个广播网，哪些不是。采取路由的方式，向不同的广播域/子网分发数据包，作用就是引入了新的地址区分不同的广播域/子网，这套地址就是网络地址。</p>
<ul>
<li>IP协议，广泛采用ipv4，32位2进制表示。两部分：网络部分（标识子网） + 主机部分（标识主机）。只有ip地址无法判断两者处于同一个子网。作用：为每一台计算机分配IP地址，确定那些地址在同一个子网络。</li>
<li>子网掩码，表示子网络特征的一个参数，形式上等于ip地址，网络部分为1，主机部分为0.</li>
<li>IP地址 and 子网掩码 = 判断两个ip地址是否同处于一个子网络。</li>
<li>ip数据包：分为head和data部分，无需为ip包定义单独的栏位，直接放入以太网包的data部分。head（20-60）+ data（65515）.ip数据包超过1500字节，就需要分割几个以太网数据包分开发送。</li>
<li>获取目标主机的mac，需要通过arp协议。</li>
</ul>
<p><a href="https://www.cnblogs.com/linhaifeng/articles/5937962.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/articles/5937962.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/03/express问题解决/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/express问题解决/" itemprop="url">express问题解决</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T14:43:32+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在用npm安装了express后，express的命令不能使用，显示错误是express不是内部或外部命令。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul>
<li><p>在node.js安装目录下，新建node_global和node_cache目录</p>
</li>
<li><p>修改node.js安装目录&gt;node_moudules&gt;npmrc文件，修改里面的内容为：</p>
<ul>
<li>prefix=D:\nodejs\node_global</li>
<li>cache=D:\nodejs\node_cache</li>
<li>registry=<a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a></li>
</ul>
</li>
<li><p>修改环境变量让命令行识别命令</p>
<ul>
<li>用户变量：path: D:\nodejs\node_global</li>
<li>系统变量：NODE_PATH: D:\nodejs\node_global\node_modules(全局模块的目录)</li>
</ul>
</li>
</ul>
<p>参考材料：<a href="http://www.cnblogs.com/JennyLin77/p/6808392.html" target="_blank" rel="noopener">http://www.cnblogs.com/JennyLin77/p/6808392.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/js之深浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/js之深浅拷贝/" itemprop="url">js之深浅拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T14:38:38+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>js中存储对象都是存储地址的，浅拷贝都指向同一块内存区域。这样导致改变一个值，其他的也跟着一起改变。只复制一层对象的属性。</p>
<p>现象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = &#123;<span class="attr">t</span>: <span class="number">1</span>, <span class="attr">p</span>: <span class="string">'gg'</span>&#125;;</div><div class="line"><span class="keyword">const</span> b = a;</div><div class="line">b.t = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">/*&#123;t: 3, p: 'gg'&#125;*/</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">/*&#123;t: 3, p: 'gg'&#125;*/</span></div></pre></td></tr></table></figure></p>
<p>实现1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">arr</span>: [<span class="number">2</span>,<span class="number">3</span>]&#125;;</div><div class="line"><span class="keyword">var</span> shallowObj = shallowCopy(obj);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> dst = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src)&#123;</div><div class="line">        <span class="keyword">if</span> (src.hasOwnProperty(prop))&#123;</div><div class="line">            dst[prop] = src[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现2：数组和对象浅拷贝（扩展运算符）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [...arr];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr === arr2)<span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>浅赋值只会将对象的各个属性依次赋值，不会递归复制，而js存储对象都是存地址的，所以浅复制会导致对象指向同一个内存地址。</p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>不仅将元对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上。就不会出现指向同一个对象的问题。开辟了新的空间。</p>
<p>实现1：jquery的extend</p>
<p>实现2：JSON，但是不支持函数、引用、undefined、RegExp、Date<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</div></pre></td></tr></table></figure></p>
<p>实现3：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">object</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> object2;</div><div class="line">    <span class="keyword">if</span>(!(object <span class="keyword">instanceof</span> <span class="built_in">Object</span>))&#123;</div><div class="line">        <span class="keyword">return</span> object;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</div><div class="line">        object2 = [];</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</div><div class="line">        object2 = <span class="built_in">eval</span>(object.toString())</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(object <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</div><div class="line">        object2 = &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> object)&#123;</div><div class="line">        object2[key] = clone(object[key])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> object2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>语法：Object.assign(target, …sources)</p>
<p>概念：将源对象（source）的所有可枚举属性复制到目标对象（target）。至少有两个参数，一个是目标对象，后面是源对象。只要有一个参数不是对象，就会抛出类型错误。如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。</p>
<p>注意：复制的是可被枚举的属性，不可枚举的属性会被自动忽略。只有字符串的包装对象才可能有自身可枚举属性。</p>
<p>用法：</p>
<ul>
<li>合并多个对象，且目标对象也被改变</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> source1 = &#123;<span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">var</span> source2 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line"><span class="comment">/*&#123;a: 1, b: 2, c: 3&#125;*/</span></div><div class="line"><span class="built_in">console</span>.log(target);</div><div class="line"><span class="comment">/*&#123;a: 1, b: 2, c: 3&#125;*/</span></div></pre></td></tr></table></figure>
<ul>
<li>克隆对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</div><div class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></div></pre></td></tr></table></figure>
<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>返回一个又一个给定对象的自身可枚举属性（所有元素为字符串的数组）组成的数组，属性名的排列顺序和使用for…in循环遍历该对象时返回的顺序一致。（for…in还会枚举原型链上的属性）</p>
<p>参考材料：</p>
<ul>
<li><a href="https://www.cnblogs.com/chenyablog/p/6930596.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyablog/p/6930596.html</a></li>
<li><a href="https://cnodejs.org/topic/56c49662db16d3343df34b13" target="_blank" rel="noopener">https://cnodejs.org/topic/56c49662db16d3343df34b13</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/31/Redux初识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/Redux初识/" itemprop="url">Redux初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T21:24:59+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>一个JavaScript库，用于管理应用的前端状态。Redux 并非 React 应用的必须条件。</p>
<h5 id="为什么要用Redux"><a href="#为什么要用Redux" class="headerlink" title="为什么要用Redux"></a>为什么要用Redux</h5><ul>
<li><p>主要优势：处理应用的共享状态（两个组件需要同时访问同一个状态的现象）</p>
</li>
<li><p>父组件在组件树中向上好几个组件的位置，状态向下传递时会变得很繁琐。</p>
</li>
<li><p>在该父组件和该子组件之间的组件不需要访问该状态。</p>
</li>
<li><p>使我们能够以有条理的方式存储数据，而且使我们能够在应用的任何位置快速获取该数据。</p>
</li>
<li><p>只需告诉Redux到底哪个组件需要哪个数据，它就会为你处理后续一切工作。借助Redux，可以控制状态改变的时间、原因和方式。</p>
</li>
</ul>
<h5 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h5><ul>
<li><p>管理共享状态</p>
</li>
<li><p>管理服务器相应</p>
</li>
<li><p>管理缓存的数据（用户）</p>
</li>
<li><p>尚未保存到服务器上的本地数据</p>
</li>
<li><p>跟踪当前路由</p>
</li>
<li><p>跟踪当前选择的标签页</p>
</li>
<li><p>跟踪页码控件</p>
</li>
</ul>
<h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><ul>
<li><p>存在单一数据源：Store，包括应用的全局状态，全存储在一个对象树中。（撤销/重做操作、调试和检测过程变得简单）。</p>
</li>
<li><p>状态是只读的，不能直接写入Redux状态，改变状态的方式是发送一个action，一个对象来描述发生了什么。（view或回调函数不能直接改写状态，所有变化是集中，按照顺序发生。action这个对象可以进行记录、序列化、存储方便后来的调试）</p>
</li>
<li><p>通过reducer的纯函数来更新状态。（参数是之前的状态和一个action，返回下一个状态）</p>
</li>
</ul>
<h5 id="为什么可以改善预测性"><a href="#为什么可以改善预测性" class="headerlink" title="为什么可以改善预测性"></a>为什么可以改善预测性</h5><ul>
<li>将大多数数据整合到一个位置</li>
<li>组件必须请求访问数据</li>
<li>store中的数据流向一个方向</li>
<li>store更新有着严格的规则</li>
</ul>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>Redux并不是管理了React中的所有状态，我们仍然可以使用原来的组件状态。那么怎么区分什么状态用什么管理？</p>
<ul>
<li><p>组件状态：对应用全局没有重要影响，且不会以发杂方式发生变化的短时间状态，例如UI元素或表单input的状态中的toggle</p>
</li>
<li><p>Redux：有全局影响且以复杂方式发生变化的状态（共享或者缓存）</p>
</li>
</ul>
<h5 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h5><ul>
<li><p>actions：只是一个对象，必须有type属性</p>
</li>
<li><p>reducers：创建应用程序的初始状态，之后状态保存在store中。只是一个函数，接受两个参数（当前状态和分派的action）。创建状态副本，修改，返回副本。</p>
</li>
<li><p>store：createStore创建一个store，接受两个参数。reducer作为参数传入，返回一个新的store对象。该对象有三个方法。</p>
<ul>
<li>getState()：不需任何参数，并返回store的当前状态</li>
<li>dispatch(action)：传入action对象，并调用reducer函数，向其传递当前状态和所派遣的action。</li>
<li>subscribe(cb)：传入监听器回调函数，当状态改变时，调用该函数</li>
</ul>
</li>
<li><p>简述关系：store保存着应用的状态，store要获取状态就得使用reducer，要使状态进行变更，store要分派一个action。此action会传递reducer，然后由reducer更新store的状态。</p>
</li>
</ul>
<p><img src="/2018/03/31/Redux初识/Redux元素.png" alt="Redux"></p>
<p>数据流动<br><img src="/2018/03/31/Redux初识/dataFlow.png" alt="数据流动"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/31/傲气的数组方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/31/傲气的数组方法/" itemprop="url">傲气的数组方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T20:55:40+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill-calculate/" itemprop="url" rel="index">
                    <span itemprop="name">skill calculate</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>背景</strong></p>
<p>Redux里介绍到了reduce方法，也是第一次看到。从看到觉得自己可能不适合学编程到现在，不断的在证明不能光用眼睛看，要动手练习，增加难度的练习。</p>
<p>作用：接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.reduce(callback, [initialValue])</div></pre></td></tr></table></figure>
<ul>
<li><p>callback(执行数组中每个值的函数，包含四个参数)</p>
<ul>
<li>previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））</li>
<li>currentValue （数组中当前被处理的元素）</li>
<li>index （当前元素在数组中的索引）</li>
<li>array （调用 reduce 的数组）</li>
</ul>
</li>
<li><p>initialValue （作为第一次调用 callback 的第一个参数）</p>
</li>
</ul>
<p>练习1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> iceCreamStats = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Amanda'</span>,</div><div class="line">    <span class="attr">gallonsEaten</span>: <span class="number">3.8</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Geoff'</span>,</div><div class="line">    <span class="attr">gallonsEaten</span>: <span class="number">5.2</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Tyler'</span>,</div><div class="line">    <span class="attr">gallonsEaten</span>: <span class="number">1.9</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Richard'</span>,</div><div class="line">    <span class="attr">gallonsEaten</span>: <span class="number">7923</span></div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">/*求冰淇淋总的加仑数*/</span></div><div class="line">iceCreamStats.reduce( <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> accumulator + currentValue.gallonsEaten;</div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>练习2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Combining .filter() and .reduce()</span></div><div class="line"> *</div><div class="line"> * Using the musicData array, filter(), and reduce():</div><div class="line"> *   - Filter the musicData array down to just the albums that have a</div><div class="line"> *     combined artist + name string length of less than 25 characters</div><div class="line"> *     (for example, looking at the first album it would be "Adele25" which </div><div class="line"> *     has a length of 7, so it should be included)</div><div class="line"> *   - Then, on the array returned from filter(), call reduce()</div><div class="line"> *   - The value returned reduce() returns the total number of sales</div><div class="line"> *   - Store that returned number in a new totalAlbumSales variable</div><div class="line"> *</div><div class="line"> * Note:</div><div class="line"> *   - You can chain the operations!</div><div class="line"> *   - Do not delete the musicData variable</div><div class="line"> *   - Do not alter any of the musicData content</div><div class="line"> *   - Do not format the sales number; leave it as a long string of digits</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">const</span> musicData = [</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Adele'</span>, <span class="attr">name</span>: <span class="string">'25'</span>, <span class="attr">sales</span>: <span class="number">1731000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Drake'</span>, <span class="attr">name</span>: <span class="string">'Views'</span>, <span class="attr">sales</span>: <span class="number">1608000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Beyonce'</span>, <span class="attr">name</span>: <span class="string">'Lemonade'</span>, <span class="attr">sales</span>: <span class="number">1554000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Chris Stapleton'</span>, <span class="attr">name</span>: <span class="string">'Traveller'</span>, <span class="attr">sales</span>: <span class="number">1085000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Pentatonix'</span>, <span class="attr">name</span>: <span class="string">'A Pentatonix Christmas'</span>, <span class="attr">sales</span>: <span class="number">904000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Original Broadway Cast Recording'</span>, <span class="attr">name</span>: <span class="string">'Hamilton: An American Musical'</span>, <span class="attr">sales</span>: <span class="number">820000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Twenty One Pilots'</span>, <span class="attr">name</span>: <span class="string">'Blurryface'</span>, <span class="attr">sales</span>: <span class="number">738000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Prince'</span>, <span class="attr">name</span>: <span class="string">'The Very Best of Prince'</span>, <span class="attr">sales</span>: <span class="number">668000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Rihanna'</span>, <span class="attr">name</span>: <span class="string">'Anti'</span>, <span class="attr">sales</span>: <span class="number">603000</span> &#125;,</div><div class="line">    &#123; <span class="attr">artist</span>: <span class="string">'Justin Bieber'</span>, <span class="attr">name</span>: <span class="string">'Purpose'</span>, <span class="attr">sales</span>: <span class="number">554000</span> &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> totalAlbumSales = musicData.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item.artist.length + item.name.length &lt; <span class="number">25</span></div><div class="line">&#125;).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,item</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + item.sales</div><div class="line">&#125;,<span class="number">0</span>)</div><div class="line"><span class="built_in">console</span>.log(totalAlbumSales);</div></pre></td></tr></table></figure>
<p>练习3：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Popular Ice Cream Totals Quiz</span></div><div class="line"> *</div><div class="line"> * Using the data array and .reduce():</div><div class="line"> *   - Return an object where each property is the name of an ice cream flavor</div><div class="line"> *     and each value is an integer that's the total count of that flavor</div><div class="line"> *   - Store the returned data in a new iceCreamTotals variable</div><div class="line"> *</div><div class="line"> * Notes:</div><div class="line"> *   - Do not delete the data variable</div><div class="line"> *   - Do not alter any of the data content</div><div class="line"> */</div><div class="line"></div><div class="line"> <span class="keyword">const</span> data = [</div><div class="line">     &#123; <span class="attr">name</span>: <span class="string">'Tyler'</span>, <span class="attr">favoriteIceCreams</span>: [<span class="string">'Strawberry'</span>, <span class="string">'Vanilla'</span>, <span class="string">'Chocolate'</span>, <span class="string">'Cookies &amp; Cream'</span>] &#125;,</div><div class="line">     &#123; <span class="attr">name</span>: <span class="string">'Richard'</span>, <span class="attr">favoriteIceCreams</span>: [<span class="string">'Cookies &amp; Cream'</span>, <span class="string">'Mint Chocolate Chip'</span>, <span class="string">'Chocolate'</span>, <span class="string">'Vanilla'</span>] &#125;,</div><div class="line">     &#123; <span class="attr">name</span>: <span class="string">'Amanda'</span>, <span class="attr">favoriteIceCreams</span>: [<span class="string">'Chocolate'</span>, <span class="string">'Rocky Road'</span>, <span class="string">'Pistachio'</span>, <span class="string">'Banana'</span>] &#125;,</div><div class="line">     &#123; <span class="attr">name</span>: <span class="string">'Andrew'</span>, <span class="attr">favoriteIceCreams</span>: [<span class="string">'Vanilla'</span>, <span class="string">'Chocolate'</span>, <span class="string">'Mint Chocolate Chip'</span>] &#125;,</div><div class="line">     &#123; <span class="attr">name</span>: <span class="string">'David'</span>, <span class="attr">favoriteIceCreams</span>: [<span class="string">'Vanilla'</span>, <span class="string">'French Vanilla'</span>, <span class="string">'Vanilla Bean'</span>, <span class="string">'Strawberry'</span>] &#125;,</div><div class="line">     &#123; <span class="attr">name</span>: <span class="string">'Karl'</span>, <span class="attr">favoriteIceCreams</span>: [<span class="string">'Strawberry'</span>, <span class="string">'Chocolate'</span>, <span class="string">'Mint Chocolate Chip'</span>] &#125;</div><div class="line"> ];</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">var</span> iceCreamTotals = data.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,item</span>)</span>&#123;</div><div class="line">    item.favoriteIceCreams.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ice</span>)</span>&#123;</div><div class="line">        prev[ice] ? prev[ice]++ : prev[ice] = <span class="number">1</span>;</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> prev</div><div class="line">&#125;,&#123;&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iceCreamTotals);</div></pre></td></tr></table></figure>
<p>练习4：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*求词频*/</span></div><div class="line"><span class="keyword">var</span> arrString = <span class="string">'abcdaab'</span>;</div><div class="line">arrString.split(<span class="string">''</span>).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">res, cur</span>) </span>&#123;</div><div class="line">    res[cur]?res[cur]++:res[cur]=<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> res</div><div class="line">&#125;,&#123;&#125;);</div></pre></td></tr></table></figure>
<p>练习5：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*求加权后的分数*/</span></div><div class="line"><span class="keyword">var</span> result = [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">subject</span>: <span class="string">'math'</span>,</div><div class="line">        <span class="attr">score</span>: <span class="number">88</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">subject</span>: <span class="string">'chinese'</span>,</div><div class="line">        <span class="attr">score</span>: <span class="number">95</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">subject</span>: <span class="string">'english'</span>,</div><div class="line">        <span class="attr">score</span>: <span class="number">80</span></div><div class="line">    &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> dis = &#123;</div><div class="line">    <span class="attr">math</span>: <span class="number">0.5</span>,</div><div class="line">    <span class="attr">chinese</span>: <span class="number">0.3</span>,</div><div class="line">    <span class="attr">english</span>: <span class="number">0.2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev,cur</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> cur.score + prev;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> qsum = result.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev,cur</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + cur.score*dis[cur.subject]</div><div class="line">&#125;,<span class="number">0</span>)</div><div class="line"><span class="keyword">var</span> sum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</div><div class="line">    <span class="comment">//console.log(prev);</span></div><div class="line">    <span class="keyword">return</span> cur.score + prev;</div><div class="line">&#125;, <span class="number">-10</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> qsum = result.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + cur.score * dis[cur.subject]</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum, qsum);</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/30/强悍新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/30/强悍新特性/" itemprop="url">强悍新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T19:47:14+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="ES6解构："><a href="#ES6解构：" class="headerlink" title="ES6解构："></a>ES6解构：</h5><p>快速取得数组或对象中的元素或属性，不用传统的index访问赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'this is a string'</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="comment">/*传统方法*/</span></div><div class="line"><span class="keyword">var</span> a = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> b = arr[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> c = arr[<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="comment">/*新方法*/</span></div><div class="line"><span class="keyword">var</span> [a, b, c] = arr;</div></pre></td></tr></table></figure>
<p>新方法可以在变量中、参数中使用。应用场景可以是数组、嵌套数组、函数传参、for循环、对象赋值解构、对象传参解构、变量名与对象属性名不一致解构等等。还有一种特殊应用场景是变量的互换和字符串解构。</p>
<h5 id="扩展运算符："><a href="#扩展运算符：" class="headerlink" title="扩展运算符："></a>扩展运算符：</h5><p>把数组或类数组对象展开成一系列用逗号隔开的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(b);</div><div class="line">    <span class="built_in">console</span>.log(c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="comment">/*传统写法*/</span></div><div class="line">foo(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="comment">/*使用扩展运算符*/</span></div><div class="line">foo(...arr);</div></pre></td></tr></table></figure>
<p>特殊应用场景：</p>
<ul>
<li>数组深拷贝</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr2 = arr;</div><div class="line"><span class="keyword">var</span> arr3 = [...arr];</div><div class="line"><span class="built_in">console</span>.log(arr === arr2);</div><div class="line"><span class="comment">//true，说明arr和arr2指向同一个数组</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr === arr3);</div><div class="line"><span class="comment">//false，说明arr和arr3指向不同的数组</span></div></pre></td></tr></table></figure>
<ul>
<li>把一个数组插入到另一个数组字面量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr4 = [...arr, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line"><span class="built_in">console</span>.log(arr4);</div><div class="line"><span class="comment">//[1,2,3,4,5,6]</span></div></pre></td></tr></table></figure>
<ul>
<li>字符串转数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'love'</span>;</div><div class="line"><span class="keyword">var</span> arr5 = [...str];</div><div class="line"><span class="built_in">console</span>.log(arr5);</div><div class="line"><span class="comment">//['l', 'o', 'v', 'e']</span></div></pre></td></tr></table></figure>
<h5 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a>rest运算符</h5><p>把逗号隔开的值序列组合成一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> args)&#123;</div><div class="line">        <span class="built_in">console</span>.log(el)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">bar(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">bar = <span class="function"><span class="keyword">function</span>(<span class="params">a, ...args</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(args);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">bar(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>配合解构使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [a, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(rest);</div><div class="line"><span class="comment">//[2, 3, 4]</span></div></pre></td></tr></table></figure>
<p>实现浅复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> oldObj1 = &#123;<span class="attr">a</span>: <span class="string">"a"</span>, <span class="attr">b</span>: &#123;<span class="attr">b1</span>: <span class="string">"b1"</span>&#125;&#125;</div><div class="line"><span class="keyword">let</span> oldObj2 = &#123;<span class="attr">a</span>: <span class="string">"a1"</span>, <span class="attr">b</span>: &#123;<span class="attr">b2</span>: <span class="string">"b2"</span>&#125;, <span class="attr">c</span>: <span class="string">"c"</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> newObject = &#123;...oldObj1, ...oldObj2&#125;;</div></pre></td></tr></table></figure>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>如果函数只有一条返回语句，可以省略大括号和return关键字</p>
<p>总结：</p>
<ul>
<li>解构的原理是赋值的两边具有相同的解构，就可以正确去除数组或对象里面的元素或属性值。</li>
<li>扩展运算符与rest运算符，三个点在形参或者等号左边为rest运算符（被赋值一方），三个点在实参或者等号右边为扩展运算符（赋值一方）。</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/chrischjh/p/4848934.html" target="_blank" rel="noopener">https://www.cnblogs.com/chrischjh/p/4848934.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/网络那些捉摸不透的事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/网络那些捉摸不透的事/" itemprop="url">网络那些捉摸不透的事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T23:38:36+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>网络协议</p>
<ul>
<li><p>TCP/IP是协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。</p>
<ul>
<li>网络层有IP协议；</li>
<li><p>传输层有TCP协议、UDP协议；</p>
<ul>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</li>
</ul>
</li>
<li><p>应用层有HTTP、FTP、DNS等协议；</p>
</li>
</ul>
</li>
<li><p>Http</p>
<ul>
<li>特点是客户端发送每次请求都需要服务器回送响应，请求结束后主动释放连接，从建立连接到关闭连接的过程称为一次连接。</li>
<li>明文传输</li>
<li>端口80</li>
<li>连接无状态</li>
<li><p>三次握手四次挥手：</p>
<ul>
<li>三次握手：<ul>
<li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ul>
</li>
<li>四次挥手：<ul>
<li>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</li>
<li>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</li>
<li>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</li>
<li>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</li>
</ul>
</li>
</ul>
</li>
<li><p>报文,构成</p>
<ul>
<li>URI：统一资源标识符，包括URL和URN两个子集</li>
<li>URL：定位资源</li>
</ul>
</li>
<li><p>状态码</p>
<ul>
<li>1xx：指定客户端相应的某些动作</li>
<li>2xx：表示请求成功</li>
<li>3xx：已经移动的文件并且常被包含在定位头信息中指定新的地址信息</li>
<li>4xx：指出客户端的错误</li>
<li>5xx：服务器错误</li>
<li>常用：<ul>
<li>301(moved permanently)：永久重定向。</li>
<li>302(found)：临时重定向，只有当原来的请求是get时浏览器才会自动重定向。</li>
<li>303(see other)：请求是post，重定向的目标文件通过get获取。</li>
<li>307(Temporary Redirect)：只能跟随对get请求的重定向。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存处理</p>
<ul>
<li>二级缓存机制：第一次请求后，服务器发送expires、Cache-Control字段。Cache-Control字段的几个值Public、Private、no-cache、no-store、max-age。当设置为no-cache时，意味着使用Etag或Last-Modified字段控制缓存。只设置Cache-Control的max-age时，请求在这个时间内，直接使用本地缓存。超过max-age，则重新发起请求，这是强缓存。如果设置了Last-Modified值（浏览器携带If-Modified-Since），就是根据服务器时间返回的header判断缓存，如果发现缓存是新的，从客户端缓存加载，返回HTTP 304。当服务器上资源有变化，但最后修改时间没有变化时，使用ETag（浏览器携带If-None-Match）判断缓存的新旧。没有替代Last-Modified的原因是分布式系统会尽量关掉Etag，因为每台机器生成的ETag都会不一样。</li>
<li>无缓存：每次请求查找返回文件，浪费带宽–》有缓存无更新：服务器内容变化，浏览器无法获知新文件–》缓存+更新（Expires）：时间格式容易写错–》缓存+更新机制升级版：设置Cache-Control，没有修改的文件再后续请求时返回文件，浪费带宽。–》缓存+更新机制终极版：二级缓存。</li>
</ul>
</li>
</ul>
</li>
<li><p>http1.1</p>
<ul>
<li>增加了Etag标签，if-unmodified-since\If-Match\If-None-Match等可供选择的缓存头控制缓存策略。</li>
<li>请求头加入了range头域，只请求资源的某个部分，返回状态码206，方便选择和利用带宽和连接。</li>
<li>增加了24个错误状态响应码，409请求资源与当前状态发生冲突；410服务器上某资源被永久删除。</li>
<li>支持了host头域（一台物理服务器上可以存在多个虚拟主机，共享一个ip地址）。</li>
<li>支持长连接和请求的流水线处理，一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
</ul>
</li>
<li><p>http2</p>
<ul>
<li>对html、css、js资源的传输方式进行了优化，不能用于实时传输消息</li>
<li>采用二进制格式传输数据</li>
<li>对消息头采用HPACK压缩传输</li>
<li>多路复用，通过一个连接完成并发请求</li>
<li>server push，服务器可以推送资源给客户端</li>
</ul>
</li>
<li><p>Https</p>
<ul>
<li>http，不安全，中间任何环节都可能是危险的</li>
<li>原理：在对称加密、非对称加密、hash等加密方法+有效的认证基础上实现安全数据的传输。</li>
<li>在http和tcp（传输控制协议）/udp（用户数据报协议）之间有一层安全套接层ssl/tls</li>
<li>需要申请到ca证书</li>
<li>端口443</li>
</ul>
</li>
<li><p>socket</p>
<ul>
<li>通信管道，是一种连接模式，不是协议</li>
<li>优点：1.传输数据字节级；2.传输数据时间短、性能高；3.可加密，数据安全性高</li>
<li>缺点：1.需解析；2.对开发人员要求高；3.增加了开发量</li>
</ul>
</li>
<li><p>websocket</p>
<ul>
<li>出现原因：http不支持长连接，一个request对应一个response；客户端被动传输消息；</li>
<li>最大特点：服务器主动向客户端推送消息，基于http1.1协议，还不能用于http2的链路上。</li>
<li>建立在tcp协议上，与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>请求头里多了两个字段：Upgrade: websocket, Connection: Upgrade, Sec-WebSocket-Key:, Sec-WebSocket-Protocol:,Sec-WebSocket-Version:.</li>
<li>数据格式比较轻量，性能开销小，通信高效。传统的long poll阻塞模型（处理并发的能力，空间要求），ajax轮询需要服务器有很快的处理速度和资源（速度）。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li>
</ul>
</li>
<li><p>与http不同：</p>
<ul>
<li>http协议基于请求应答，只能做单向传输，是半双工协议，而WebSocket是全双工协议，类似于socket通信，双方都可以在任何时刻向另一方发送数据。</li>
<li>WebSocket使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用。</li>
<li>WebSocket的连接不能通过中间人来转发，它必须是一个直接连接。如果通过代理转发，一个代理要承受如此多的websocket连接不释放，就类似于一次DDOS攻击了。</li>
<li>WebSocket在建立握手连接时，数据是通过http协议传输的，但在建立连接之后，真正的数据传输阶段是不需要http协议参与的。</li>
<li>websocket传输的数据是二进制流，是以帧为单位的，http传输的是明文传输，是字符串传输，WebSocket的数据帧有序。</li>
<li>websocket的请求的头部和http请求头部不同，见上文。  </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*客户端的用法*/</span></div><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"wss://echo.websocket.org"</span>);</div><div class="line"></div><div class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection open ..."</span>); </div><div class="line">  ws.send(<span class="string">"Hello WebSockets!"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"Received Message: "</span> + evt.data);</div><div class="line">  ws.close();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Connection closed."</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>参考材料：</li>
<li><a href="https://zhuanlan.zhihu.com/p/23299600?refer=study-fe" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23299600?refer=study-fe</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/带着webpack走上自动化之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/带着webpack走上自动化之路/" itemprop="url">带着webpack走上自动化之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T22:02:16+08:00">
                2018-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>定位：前端资源加载/打包工具</p>
</li>
<li><p>简介<br>  &emsp;&emsp;WebPack是模块打包机，分析项目结构，找到JavaScript模块及其他浏览器不能直接运行的拓展语言，将其打包为合适的格式供浏览器使用。模块化概念盛行，各种各样的扩展语言和各种预处理器或是依赖包提高开发效率的同时，使利用它们开发的文件需要额外的处理才能让浏览器识别，手动处理很繁琐，所以出现了这样的工具。</p>
</li>
<li><p>Gulp/Grunt（优化前端的开发流程的工具）相比：</p>
<ul>
<li><p>Gulp/Grunt是一种能够优化前端的开发流程的工具，WebPack是一种模块化解决方案。</p>
</li>
<li><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/28/带着webpack走上自动化之路/grunt和gulp的工作流程.png" alt="Grunt和Gulp的工作流程"></p>
<ul>
<li><ul>
<li><p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。他的处理速度更快更直接，能打包更多不同类型的文件。</p>
</li>
<li><p>做了哪些事：</p>
<ul>
<li>依赖管理：方便引用第三方模块、让模块更容易复用、避免全局注入导致的冲突、避免重复加载或加载不需要的模块。</li>
<li>合并代码：把各个分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS可以减少、优化代码的体积。</li>
<li>各路插件：babel把ES6+转译成ES5-，eslint可以检查编译期的错误</li>
</ul>
</li>
<li><p>原理：分析代码，找到require、exports、define等关键词，替换成对应模块的“引用”</p>
</li>
<li><p>在配置webpack时参考的博文：<a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a></p>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/28/带着webpack走上自动化之路/webpack工作方式.png" alt="webpack工作方式"></p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作.</p>
</li>
<li><p>可以生成Source Maps（使调试更容易）：帮助找到写错的位置。</p>
</li>
<li><p>更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。资源模块化后，有三个好处：</p>
<ul>
<li><p>依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</p>
</li>
<li><p>资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等。</p>
</li>
<li><p>项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数：<code>dest = webpack(src, config)</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/28/带着webpack走上自动化之路/devtool.png" alt="devtool配置项"></p>
<p>-</p>
<pre><code>- devtool配置项：

    - 正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的的执行有一定影响。

    - 对小到中型的项目中，eval-source-map是一个很好的选项，再次强调你只应该开发阶段使用它.
</code></pre><ul>
<li><p>loader加载器</p>
<ul>
<li><p>webpack把所有静态资源认为是模块，它在打包构建过程中用来处理源文件的（JSX，Scss，Less，js，图片等），一次处理一个。加载器之间可以进行串联，一个加载器的输出可以成为另一个加载器的输入。比如LESS文件先通过less-load处理成css，然后再通过css-loader加载成css模块，最后由style-loader加载器对其做最后的处理，从而运行时可以通过style标签将其应用到最终的浏览器环境。</p>
</li>
<li><p>对于样式表，有两种处理方式：<code>css-loader</code>和<code>style-loader</code>，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p>
</li>
<li><p>CSS module被称为CSS modules的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，可以直接把CSS的类名传递到组件的代码中。</p>
</li>
<li><p>对loader理解的不到位，导致我的css代码没法从html分离出来。一开始我用loader中的css-loader和style-loader处理css文件。配置如图：</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/28/带着webpack走上自动化之路/webpack_config_module.png" alt="loader配置"></p>
<ul>
<li><ul>
<li><p>module是指css module模块，默认是局部范围，如果设置了module:true就使我的css变成了组件内CSS，而不是全局CSS了。</p>
</li>
<li><p>相关文档：<a href="https://www.npmjs.com/package/css-loader#modules" target="_blank" rel="noopener">https://www.npmjs.com/package/css-loader#modules</a></p>
</li>
<li><p>另外，要更好的分离出css文件，可以配置ExtractTextPlugin插件。</p>
</li>
</ul>
</li>
<li><p>插件Plugins</p>
<ul>
<li><p>用来拓展webpack功能，插件不直接操作单个文件，直接作用于整个构建过程。</p>
</li>
<li><p>常用的插件：</p>
<ul>
<li><p>HtmlWebpackPlugin：依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html，创建一个build文件夹存放最终的输出文件。</p>
</li>
<li><p>HotModuleReplacement (HMR): 允许在修改组件代码后，自动刷新实时预览修改后的效果。需要对模块进行额外的配置，在js模块中执行一个webpack提供的api才能实现热加载。如果是React模块，使用Babel(Babel中的react-transform-hrm插件可以在不对React模块进行额外的配置的前提下让HMR正常工作)可以方便的实现热加载。(<small>Babel和webpack是独立的工具；二者可以一起工作，都可以通过插件拓展功能。</small>)</p>
<ul>
<li>配置方法： 在webpack配置文件中添加HMR插件(new webpack.HotModuleReplacementPlugin())；在Webpack Dev Server中添加“hot”参数；</li>
</ul>
</li>
<li><p>OccurenceOrderPlugin: 为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</p>
</li>
<li><p>UglifyJsPlugin：压缩JS代码；</p>
</li>
<li><p>ExtractTextPlugin：分离CSS和JS文件。<code>ExtractTextPlugin.extract(fallback[编译后用什么loader提取css],use[需要什么样的loader编译文件],publicfile[覆盖项目路径，生成该css文件的文件路径])</code></p>
</li>
<li><p>clean-webpack-plugin: 如果使用缓存去存储不同内容版本的文件，则可以使用这个插件去除目标文件中的残余文件。</p>
</li>
<li><p>ProvidePlugin: 这是在项目中用到了另一个插件，可以在里面定制要使用的库，如jQuery，knockout等等</p>
</li>
</ul>
</li>
<li><p>生产阶段的代码和开发阶段的代码不同，一些配置不能同时在两个配置文件中。</p>
</li>
<li><p>开发阶段：</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/28/带着webpack走上自动化之路/webpack_plugins_develop.png" alt="webpack_plugins_develop"></p>
<p>-</p>
<pre><code>- 生产阶段：
</code></pre><p><img src="/2018/03/28/带着webpack走上自动化之路/webpack_plugins_production.png" alt="webpack_plugins_production"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</div><div class="line">            <span class="attr">ko</span>: <span class="string">'knockout'</span>,</div><div class="line">            <span class="attr">$</span>: <span class="string">'jquery'</span>,</div><div class="line">            <span class="attr">axios</span>: <span class="string">'axios'</span></div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p>其他相关问题</p>
<ul>
<li><p>webpack4正式发布了，不必配置文件，通过选择mode类型来选择生产或开发模式。<a href="https://baijiahao.baidu.com/s?id=1593463639501622465&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">相关材料</a></p>
</li>
<li><p>webpack多页面应用配置<a href="http://www.duanliang920.com/learn/web353.html" target="_blank" rel="noopener">http://www.duanliang920.com/learn/web353.html</a></p>
</li>
<li><p>解决webpack编译慢的问题<a href="https://segmentfault.com/a/1190000006087638" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006087638</a></p>
</li>
</ul>
</li>
<li><p>参考材料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a></li>
<li><a href="https://segmentfault.com/q/1010000007581542?_ea=1390552" target="_blank" rel="noopener">https://segmentfault.com/q/1010000007581542?_ea=1390552</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/算法之交换与排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/算法之交换与排序/" itemprop="url">算法之交换与排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T10:24:25+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary-skill/" itemprop="url" rel="index">
                    <span itemprop="name">summary skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="随机排序（洗牌算法）"><a href="#随机排序（洗牌算法）" class="headerlink" title="随机排序（洗牌算法）"></a>随机排序（洗牌算法）</h4><p>目的：生成随机的数组，实现随机功能。</p>
<p>网络中常见的解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方案并不能真正实现随机，大概率会出现在它原来的位置附近。因为给<code>sort</code>方法传递进去的参数，需要返回相同的值。而v8引擎对长度小于10的数组使用插入排序，长度大于10的数组使用快速排序。</p>
<p>真正实现随机且考虑到性能的是经典的Fisher-Yates shuffle算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//ES6版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> i = arr.length;</div><div class="line">    <span class="keyword">while</span>(i)&#123;</div><div class="line">        <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i--);</div><div class="line">        [arr[j], arr[i]] = [arr[i], arr[j]];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ES5版本</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i = arr.length, t, j;</div><div class="line">    <span class="keyword">while</span>(i)&#123;</div><div class="line">        j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i--);</div><div class="line">        t = arr[i];</div><div class="line">        arr[i] = arr[j];</div><div class="line">        arr[j] = t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>换一种写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> shuffle = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</div><div class="line">    arr.forEach(<span class="function">(<span class="params">element, index</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (index + <span class="number">1</span>));</div><div class="line">        </div><div class="line">        swap(arr, index, randomIndex);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, indexA, indexB</span>) =&gt;</span>&#123;</div><div class="line">    [arr[indexA], arr[indexB]] = [arr[indexB], arr[indexA]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是这样的写法有两个小问题：</p>
<ul>
<li>当index=0时，swap(arr, 0, 0)没有必要</li>
<li>const的写法失去自由的逻辑展现（调用不能放在声明前）</li>
</ul>
<p>所以最终版：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">shuffle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    arr.forEach(<span class="function">(<span class="params">element, index</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(index !== <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">const</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (index + <span class="number">1</span>));</div><div class="line">            </div><div class="line">            swap(arr, index, randomIndex);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, indexA, indexB</span>) </span>&#123;</div><div class="line">    [arr[indexA], arr[indexB]] = [arr[indexB], arr[indexA]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考博客：</p>
<ul>
<li><a href="https://www.rayjune.me/2018/03/13/see-code-taste-from-shuffle/" target="_blank" rel="noopener">https://www.rayjune.me/2018/03/13/see-code-taste-from-shuffle/</a></li>
<li><a href="ttps://blog.oldj.net/2017/01/23/shuffle-an-array-in-javascript/" target="_blank" rel="noopener">ttps://blog.oldj.net/2017/01/23/shuffle-an-array-in-javascript/</a></li>
</ul>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ol>
<li>冒泡排序 Bubble Sort</li>
</ol>
<ul>
<li>思路：依次比较、交换相邻的元素大小。</li>
<li>稳定，时间复杂度<code>O(n^2)</code>，交换<code>O(n^2)</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</div><div class="line">                swap(arr, j, j + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>双向排序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> end = arr.length - <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (start &lt; end)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</div><div class="line">                swap(arr, i, i + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        end -= <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = end; i &gt; start; i--)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[i - <span class="number">1</span>] &gt; arr[i])&#123;</div><div class="line">                swap(arr, i - <span class="number">1</span>, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        start += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>给冒泡排序传入第二个参数（参数为函数），来控制升序和降序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr, compareFunc</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(compareFunc(arr[j], arr[j + <span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</div><div class="line">                swap(arr, j, j + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> arr = [<span class="number">91</span>, <span class="number">60</span>, <span class="number">96</span>, <span class="number">7</span>, <span class="number">35</span>, <span class="number">65</span>, <span class="number">10</span>];</div><div class="line"><span class="built_in">console</span>.log(bubbleSort(arr, (a, b) =&gt; a - b));</div><div class="line"><span class="built_in">console</span>.log(bubbleSort(arr, (a, b) =&gt; b - a));</div></pre></td></tr></table></figure>
<ol>
<li>选择排序 Selection Sort</li>
</ol>
<ul>
<li>思想：每一次循环遍历寻找最小的数，记录minIndex，在循环结束后交换minIndex与i的位置。</li>
<li>不稳定，时间复杂度O(n^2)，交换<code>O(n)</code>，是选择排序的唯一优点（减少了swap的次数）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len - <span class="number">1</span>; i++)&#123;</div><div class="line">        <span class="keyword">let</span> minIndex = i;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])&#123;</div><div class="line">                minIndex = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i !== minIndex)&#123;</div><div class="line">            swap(arr, i, minIndex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个改为在每次内循环中找到最大值并把其交换到数据的末尾</p>
<ol>
<li>插入排序 Insertion Sort</li>
</ol>
<ul>
<li>思想：默认a[0]是已排序数组中的元素，从a[1]开始逐渐往已排序数组中插入元素，从后往前一个个比较，如果待插入元素小于已排序元素，则已排序元素后移一位，直到所有元素插入到数组中。</li>
<li>稳定，适合快要排序完成的数组时间复杂度<code>O(n)</code>，开销低。时间复杂度<code>O(n^2)</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>, len = arr.length; i &lt; len; i++)&#123;</div><div class="line">        <span class="keyword">const</span> temp = arr[i];</div><div class="line">        <span class="keyword">let</span> preIndex = i - <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(arr[preIndex] &gt; temp)&#123;</div><div class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</div><div class="line">            preIndex -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        arr[preIndex + <span class="number">1</span>] = temp;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>二分查找</li>
</ol>
<p>思想：折半</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, value</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> min = <span class="number">0</span>;</div><div class="line">    <span class="keyword">let</span> max = arr.length - <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(min &lt;= max)&#123;</div><div class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((min + max) / <span class="number">2</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(arr[mid] === value)&#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; value)&#123;</div><div class="line">            max = mid - <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            min = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="string">'Not Found'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>希尔排序</li>
</ol>
<ul>
<li>思想：插入排序的改进版，克服了插入排序只能移动一个相邻位置的缺陷（希尔排序可以一次移动gap个距离）。</li>
<li>不稳定，快要排序完成的数组有<code>O(n*log(n))</code>的时间复杂度（反转数组的速度非常快）。</li>
<li>gap的选择是希尔排序的重要部分，当gap=1，算法变为插入排序。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//gap = n/2时</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> len = arr.length;</div><div class="line">    <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">            <span class="keyword">const</span> temp = arr[i];</div><div class="line">            <span class="keyword">let</span> preIndex = i - gap;</div><div class="line">            </div><div class="line">            <span class="keyword">while</span>(arr[preIndex] &gt; temp)&#123;</div><div class="line">                arr[preIndex + gap] = arr[preIndex];</div><div class="line">                preIndex -= gap;</div><div class="line">            &#125;</div><div class="line">            arr[preIndex + gap] = temp;</div><div class="line">        &#125;</div><div class="line">        gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>归并排序</li>
</ol>
<ul>
<li>思想：分而治之，折半的方式递归/迭代排序元素。</li>
<li>稳定，时间复杂度<code>O(n*log(n))</code>，需要O(n)的额外空间。</li>
<li>利用空间换时间，适用于次考虑存储空间的场合（数据库内排序），适合于链表排序。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> len = arr.length;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</div><div class="line">    <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, mid);</div><div class="line">    <span class="keyword">const</span> right = arr.slice(mid);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> result = [];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>)&#123;</div><div class="line">        result.push(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] ? left.shift() : right.shift());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result.concat(left, right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>堆排序 Heap Sort</li>
</ol>
<ul>
<li>思想：是选择排序的改进版，像选择排序一样将输入划分为已排序和待排序。将所有数据堆化，移动arr[0]到数组末尾（已排序区域），重新堆化，依次循环排序。</li>
<li>不稳定，时间复杂度O(n*log(n))，平均效率决定了它不如快速排序，适用于数据库内引擎排序（拥有良好的可预测性）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> size = arr.length;</div><div class="line">  <span class="comment">// 初始化堆，i 从最后一个父节点开始调整，直到节点均调整完毕 </span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(size / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    heapify(arr, i, size);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 堆排序：先将第一个元素和已拍好元素前一位作交换，再重新调整，直到排序完毕</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">    swap(arr, <span class="number">0</span>, i);</div><div class="line">    size -= <span class="number">1</span>;</div><div class="line">    heapify(arr, <span class="number">0</span>, size);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, index, size</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> largest = index;</div><div class="line">  <span class="keyword">let</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</div><div class="line">  <span class="keyword">if</span> (left &lt; size &amp;&amp; arr[left] &gt; arr[largest]) &#123;</div><div class="line">    largest = left;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (right &lt; size &amp;&amp; arr[right] &gt; arr[largest]) &#123;</div><div class="line">    largest = right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (largest !== index) &#123;</div><div class="line">    swap(arr, index, largest);</div><div class="line">    heapify(arr, largest, size);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>快速排序 Quick Sort</li>
</ol>
<ul>
<li>思想：从数列中挑出一个元素，称为基准（pivot），比基准小的放前面，大的放后面。递归</li>
<li>不稳定，时间复杂度O(n*log(n))~O(n^2)，需要额外的O(log(n))空间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> pivot = arr[<span class="number">0</span>];</div><div class="line">    <span class="keyword">const</span> left = [];</div><div class="line">    <span class="keyword">const</span> right = [];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>) &#123; <span class="keyword">return</span> arr; &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>, len = arr.length; i &lt; len; i++)&#123;</div><div class="line">        arr[i] &lt; pivot ? left.push(arr[i]) : right.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>数据几乎快排序完成时：插入</li>
<li>数据量小，对效率要求不高，代码简单：按照性能大小：希尔&gt;插入&gt;冒泡&gt;选择排序</li>
<li>数据量大，要求稳定的效率：堆排序</li>
<li>数据量大，要求效率高，要稳定：归并排序</li>
<li>数据量大，要求最好的平均效率：按照性能大小：快速&gt;堆&gt;归并</li>
<li>选择排序没用？只要O(n)次交换，比冒泡好很多</li>
</ul>
<p><img src="/2018/03/27/算法之交换与排序/排序算法比较.png" alt="排序算法比较"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/DOM这个戏精/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/DOM这个戏精/" itemprop="url">DOM这个戏精</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T11:28:06+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/accumulate/" itemprop="url" rel="index">
                    <span itemprop="name">accumulate</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>DOM特性与DOM属性</p>
<ul>
<li>attribute（特性）：是我们赋予某个事物的特质或对象，attribute是HTML标签上的特性，它的值只能够是字符串</li>
<li><p>property（属性）：是早已存在的不需要外界赋予的特质，property是DOM中的属性，是JavaScript里的对象</p>
<p>&emsp;&emsp;访问方式：</p>
<ul>
<li>传统DOM方法getAttribute、setAttribute</li>
<li>使用DOM对象上与之对应的属性</li>
</ul>
</li>
<li><p>有五点要考虑：</p>
<ul>
<li>跨浏览器命名，多数浏览器用class，IE用className</li>
<li><p>命名限制，特性命名自由，属性命名受限制<br><img src="/2018/03/16/DOM这个戏精/属性、特性命名.png" alt="属性名与特性名不同的情况"></p>
</li>
<li><p>HTML、XML差别：处理XML DOM时，不会在元素上自动创建属性值表示特性。需使用传统的DOM特性方法获取特性。elem.ownerDocument只读属性会返回当前节点的顶层的document对象。</p>
</li>
<li>自定义特性的行为：自定义的特性值，使用DOM方法getAttribute()、setAttribute()。自定义特性使用’data-‘前缀。</li>
<li>性能注意事项：属性的访问速度比相应的DOM特性方法的访问速度快，特别在IE中。</li>
</ul>
</li>
<li><p>跨浏览器的Attribute问题</p>
<ul>
<li><p>DOM中的id/name膨胀：</p>
<ul>
<li>将表单input元素的id和name特性作为<form>元素的属性值进行引用。产生的属性会主动覆盖form元素上已经存在的同名属性。IE浏览器还会替换该属性上的特性值。</form></li>
<li>解决办法是获取描述元素特性本身的原始DOM节点，没有被浏览器修改。<code>var action = element.getAttributeNode(&#39;action&#39;).nodeValue</code>。</li>
</ul>
</li>
<li><p>URL规范</p>
<ul>
<li>访问一个引用了URL属性时（src、href、action）,该值会自动将原始值转换成完整规范的URL。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"listing-11.5.html"</span> <span class="attr">id</span>=<span class="string">"testSubject"</span>&gt;</span>Self<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'testSubject'</span>);</div><div class="line"><span class="keyword">var</span> linkHref = link.getAttributeNode(<span class="string">'href'</span>).nodeValue; <span class="comment">//#1</span></div><div class="line"></div><div class="line">assert(linkHref === <span class="string">'listing-11.5.html'</span>,  <span class="string">'link node value is ok'</span>);</div><div class="line">assert(link.href === <span class="string">'listing-11.5.html'</span>,  <span class="string">'link property value is ok'</span>);</div><div class="line">assert(link.getAttribute(<span class="string">'href'</span>) == linkHref, <span class="string">'link attribute not modified'</span>);</div></pre></td></tr></table></figure>
<ul>
<li><ul>
<li><ul>
<li><p>style特性：要获得样式信息可以直接用element.style.color；要获取字符串，getAttribute();</p>
</li>
<li><p>节点名称：HTML文档中nodeName属性返回名称大写；XML或XHTML文档中，自由</p>
</li>
</ul>
</li>
<li><p>element.style的方式只能取到内联样式，不能取到外部链接引入的样式</p>
</li>
<li><p>css特性将多余的单词用连字符分割</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> size = element.style[<span class="string">'font-size'</span>];</div><div class="line"><span class="keyword">var</span> size = element.style.fontSize;</div></pre></td></tr></table></figure>
<p>-</p>
<pre><code>- 点运算符不能设置字符串，多个属性可以用下列方式设置：
</code></pre><pre><code class="javascript">elt.style.cssText = <span class="string">"color: blue;"</span>;
elt.setAttribute(<span class="string">"style"</span>,<span class="string">"color:blue"</span>);
</code></pre>
<ul>
<li><ul>
<li>对于float，大部分浏览器使用cssFloat，IE使用styleFloat。</li>
<li>style设置属性要指定单位</li>
<li>对于display=none的元素，它的元素宽和高是0.为了获取到值，隐藏元素可以换一种方法设置：<ul>
<li>display:block; visibility: hidden; position: absolute; 获取元素尺寸；恢复先前更改的属性。</li>
</ul>
</li>
<li><p>通过不同的计算样式方法访问这些颜色值时，浏览器返回值几乎不一样。</p>
</li>
<li><p>获取元素的计算样式window.getComputedStyle(element)，IE9之前element.currentStyle</p>
</li>
<li><p>IE6/7用getAttribute获取不到值时，可以使用getAttributeNode().nodeValue获取。</p>
</li>
</ul>
</li>
<li><p>HTMLCollection、NodeList及NamedNodeMap动态的集合，类数组</p>
</li>
</ul>
<p>相关材料：</p>
<ul>
<li><a href="https://www.cnblogs.com/chenliyang/p/6554702.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenliyang/p/6554702.html</a></li>
<li><a href="https://www.mxgw.info/coding/javascript-attribute-property.html" target="_blank" rel="noopener">https://www.mxgw.info/coding/javascript-attribute-property.html</a></li>
<li><a href="https://www.cnblogs.com/wangfupeng1988/p/3631853.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangfupeng1988/p/3631853.html</a></li>
<li><a href="https://www.cnblogs.com/wangfupeng1988/p/3626300.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangfupeng1988/p/3626300.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/我会用到的官方文档列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/我会用到的官方文档列表/" itemprop="url">我会用到的官方文档列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T10:07:35+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/accumulate/" itemprop="url" rel="index">
                    <span itemprop="name">accumulate</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目的：希望能够增快查看官方文档的速度</p>
<ul>
<li>XSS攻击游戏:<a href="https://xss-game.appspot.com/" target="_blank" rel="noopener">https://xss-game.appspot.com/</a></li>
<li>HTTP文档：<a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616.html</a></li>
<li>HTTP介绍：<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></li>
<li>jquery中文文档：<a href="https://www.jquery123.com/" target="_blank" rel="noopener">https://www.jquery123.com/</a></li>
<li>knockoutJS文档：<a href="http://knockoutjs.com/" target="_blank" rel="noopener">http://knockoutjs.com/</a></li>
<li>react文档：<a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">https://reactjs.org/docs/hello-world.html</a></li>
<li>HTML字符实体：<a href="http://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/html/html_entities.asp</a></li>
<li>饥人谷课件：<a href="http://book.jirengu.com/fe/" target="_blank" rel="noopener">http://book.jirengu.com/fe/</a></li>
<li>Redux：<a href="https://redux.js.org/introduction" target="_blank" rel="noopener">https://redux.js.org/introduction</a></li>
</ul>
<ul>
<li>好看的图标库:<a href="http://iconfont.cn/" target="_blank" rel="noopener">http://iconfont.cn/</a></li>
<li>背景轮播库:<a href="http://vegas.jaysalvat.com/" target="_blank" rel="noopener">http://vegas.jaysalvat.com/</a></li>
<li>图片库:<a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com/</a></li>
<li>jQuery之家:<a href="http://www.htmleaf.com/" target="_blank" rel="noopener">http://www.htmleaf.com/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T01:07:06+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/一些关于工程、组件、模块的概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/一些关于工程、组件、模块的概念/" itemprop="url">一些关于工程、组件、模块的概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T23:29:05+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;前端与客户端GUI软件有一个很大的不同：</p>
<blockquote>
<p>前端是一种远程部署，运行时增量下载的GUI软件</p>
</blockquote>
<p>&emsp;&emsp;前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。</p>
<h4 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h4><ul>
<li><p>是前端架构中重要的一环，为了解决高效的多人协作，保证项目的可维护性和提高项目的开发质量等。</p>
</li>
<li><p>前端工程本质上是软件工程的一种，可以借鉴软件工程的思想和角度来研究。</p>
</li>
<li><p>从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。</p>
</li>
<li><p>从哪些因素来考虑：</p>
<ul>
<li>模块化</li>
<li>组件化 </li>
<li>规范化</li>
<li>自动化</li>
</ul>
</li>
<li><p>要解决的问题：</p>
<ul>
<li>合理的开发流程及开发规范，包括代码规范、模块化组件化规范(分治)等（提高生产力）</li>
<li>一套自动化代码质量检测方案（提高系统可靠性）</li>
<li>一套自动化及高度适应性的项目 发布／部署 方案（提高系统的伸缩性及灵活性）</li>
<li>极致的性能优化，包括减少冗余的接口请求及资源请求、提高缓存命中率等，简言之就是站点的打开及运行速度（更好的用户体验）</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/11/一些关于工程、组件、模块的概念/前端工程基本架构.png" alt="前端开发的基本工程结构"></p>
<h4 id="模块化-开发效率"><a href="#模块化-开发效率" class="headerlink" title="模块化- 开发效率"></a>模块化- 开发效率</h4><ul>
<li><p>通俗的讲，模块化是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。为多人协作提供可能。</p>
</li>
<li><p>JS模块化</p>
<ul>
<li><p>ES6开始有了模块系统，可以取代CommonJS和AMD规范，可以静态加载。</p>
</li>
<li><p>Webpack + Babel打包所有模块成一个文件同步加载，也可以打成多个chunk异步加载；</p>
</li>
</ul>
</li>
<li><p>CSS模块化</p>
<ul>
<li><p>SASS、LESS、Stylus等预处理器实现CSS文件的拆分，但没有借鉴CSS模块化的一个重要问题：选择器的全局污染问题。</p>
</li>
<li><p>导入一个CSS模块后，已存在的样式有被覆盖的风险，重写样式不利于多人协作。</p>
</li>
<li><p>从工具层面，社区创造出了Shadow DOM、CSS in JS和CSS Modules三种解决方案。</p>
<ul>
<li><p>Shadow DOM是WebComponents的标准，能解决全局污染的问题，但是很多浏览器不兼容；</p>
</li>
<li><p>CSS in JS使用JS/JSON写样式，但是不能利用现有的CSS技术，处理伪类比较困难。</p>
</li>
<li><p>CSS Modules仍然使用CSS，只是让JS来管理依赖，最大化的结合CSS生态和JS模块化能力，目前是最好的解决方案。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>资源模块化</p>
<ul>
<li>主要是Webpack，将所有的资源看作是模块。试依赖关系单一化、资源处理集中化、项目结构清晰化。</li>
</ul>
</li>
</ul>
<h3 id="组件化-效率兼顾性能，分治思想"><a href="#组件化-效率兼顾性能，分治思想" class="headerlink" title="组件化- 效率兼顾性能，分治思想"></a>组件化- 效率兼顾性能，分治思想</h3><blockquote>
<p>Keep simple. Everything can be a component.</p>
</blockquote>
<ul>
<li><p>组件化不等于模块化</p>
</li>
<li><p>模块化是文件层面上的，对代码或资源的拆分；组件是设计层面上的，对UI的拆分。</p>
</li>
<li><p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p>
</li>
<li><p>是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式对面向对象的进一步抽象。</p>
</li>
<li><p>除了封装组件本身，还要合理处理组件之间的关系，比如（逻辑）继承、（样式）扩展、（模板）嵌套和包含等，这些关系都可以归为依赖。</p>
</li>
</ul>
<p><img src="/2018/03/11/一些关于工程、组件、模块的概念/组件化开发.png" alt="组件化开发"></p>
<h3 id="传统前端框架-类库与组件化框架-类库"><a href="#传统前端框架-类库与组件化框架-类库" class="headerlink" title="传统前端框架/类库与组件化框架/类库"></a>传统前端框架/类库与组件化框架/类库</h3><ul>
<li><p>传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；</p>
</li>
<li><p>而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。</p>
</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul>
<li><p>模块化和组件化确定了开发模型，而这些东西的实现就需要规范去落实。</p>
</li>
<li><p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p>
</li>
<li><p>内容：</p>
<ul>
<li>目录结构的制定</li>
<li>编码规范</li>
<li>前后端接口规范</li>
<li>文档规范</li>
<li>组件管理</li>
<li>Git分支管理</li>
<li>Commit描述规范</li>
<li>定期CodeReview</li>
<li>视觉图标规范</li>
</ul>
</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><blockquote>
<p>任何简单机械的重复劳动都应该让机器去完成。</p>
</blockquote>
<h3 id="一些重要的观点"><a href="#一些重要的观点" class="headerlink" title="一些重要的观点"></a>一些重要的观点</h3><ul>
<li><p>前端相比其他软件开发，在基础架构上更加迫切的需要组件化开发和资源管理，而解决资源管理的方法其实一点也不复杂：</p>
<blockquote>
<p>一个通用的资源表生成工具 + 基于表的资源加载框架</p>
</blockquote>
</li>
</ul>
<p>本文参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/24558375" target="_blank" rel="noopener">https://www.zhihu.com/question/24558375</a></li>
<li><a href="https://github.com/fouber/blog/issues/10" target="_blank" rel="noopener">https://github.com/fouber/blog/issues/10</a></li>
<li><a href="https://github.com/kuitos/kuitos.github.io/issues/29" target="_blank" rel="noopener">https://github.com/kuitos/kuitos.github.io/issues/29</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/特殊的元素特殊的你（html篇）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/特殊的元素特殊的你（html篇）/" itemprop="url">特殊的元素特殊的你（html篇）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T15:20:21+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="lt-img-gt-元素的usemap属性和ismap属性："><a href="#lt-img-gt-元素的usemap属性和ismap属性：" class="headerlink" title="&lt;img&gt;元素的usemap属性和ismap属性："></a><code>&lt;img&gt;</code>元素的usemap属性和ismap属性：</h4><pre><code>- ismap被称为服务器端的图像映射，它只可以用在`&lt;a&gt;`标签标识的超链接里面。当用户在ismap图像上单击了某处时，浏览器会自动把鼠标的x、y位置（相对于图像的左上角）发送到服务器端。特殊的服务器端软件（在本例中是/example/map程序）可以根据这些坐标来做出响应。
</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/example/map"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/map.gif"</span> <span class="attr">ismap</span>=<span class="string">"ismap"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>-</p>
<pre><code>- usemap属性提供了一种“客户端”的图像映射机制，有效地消除了服务器端对鼠标坐标的处理，以及由此带来的网络延迟问题。通过特殊的`&lt;map&gt;`和`&lt;area&gt;`标签，HTML创作者可以提供一个描述usemap图像中超链接敏感区域坐标的映射，这个映射同时包含相应的超链接URL。usemap属性的值是一个 URL，它指向特殊的`&lt;map&gt;` 区域。用户计算机上的浏览器将把鼠标在图像上单击时的坐标转换成特定的行为，包括加载和显示另外一个文档。
</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/example/map"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/map.gif"</span> <span class="attr">ismap</span>=<span class="string">"ismap"</span> <span class="attr">usemap</span>=<span class="string">"#map"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">coords</span>=<span class="string">"0,0,49,49"</span> <span class="attr">href</span>=<span class="string">"link1.html"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">coords</span>=<span class="string">"50,0,99,49"</span> <span class="attr">href</span>=<span class="string">"link2.html"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">coords</span>=<span class="string">"0,50,49,99"</span> <span class="attr">href</span>=<span class="string">"link3.html"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">coords</span>=<span class="string">"50,50,99,99"</span> <span class="attr">href</span>=<span class="string">"link4.html"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>usemap客户端处理图像映射的好处是，它不要求有服务器或特殊的服务器软件，与ismap机制不同，它可以用在非web（无网络）环境中。</li>
</ul>
</li>
</ul>
<h4 id="lt-i-gt-、-lt-em-gt"><a href="#lt-i-gt-、-lt-em-gt" class="headerlink" title="&lt;i&gt;、&lt;em&gt;"></a><code>&lt;i&gt;</code>、<code>&lt;em&gt;</code></h4><ul>
<li><p><code>&lt;i&gt;</code></p>
<ul>
<li><p>html5，表示一段普通文本中，因为某种原因和正常文本不同，例如专业术语、外语短语或排版用的文字，其通常表现为斜体，他的出现不会改变语义；</p>
</li>
<li><p>一段文本中如果有插入语言不同的专业术语，需要在<i>标签中加上<lang>属性作为注解，</lang></i></p>
</li>
<li><p>斜体文字</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>There is a certain <span class="tag">&lt;<span class="name">i</span> <span class="attr">lang</span>=<span class="string">"fr"</span>&gt;</span>je ne sais quoi<span class="tag">&lt;/<span class="name">i</span>&gt;</span> in the air.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><p>em</p>
<ul>
<li><p>表达对文本内容的强调；</p>
</li>
<li><p>其强调位置的不同往往带来语义的变化（可以理解为英语口语中针对一句话中不同位置的重度，影响听话人的理解）；</p>
</li>
<li><p>斜体文字</p>
</li>
<li><p><code>&lt;em&gt;</code>不适用于需要传达重要性的内容，传达重要性的语义应该使用<code>&lt;strong&gt;</code>；</p>
</li>
</ul>
</li>
<li><p>标签语义化的好处</p>
</li>
<li><p>html5事件</p>
</li>
</ul>
<p>&emsp;&emsp;面试之后出了两道笔试题目，第一道不用html5原生事件，结果我连html5原生事件有啥都不知道，就比较尴尬了。赶快复习一下。</p>
<ul>
<li><p>windows事件，适用于body标签，常用onblur、onerror、onfocus、onhaschange、onload、onresize、onunload。</p>
</li>
<li><p>表单事件，适用于所有html5元素，常用于表单元素中。常用onblur、onchange、onfocus、oninput、onselect、onreset、onsubmit。</p>
</li>
<li><p>键盘事件，适用于所有html5元素。onkeydown、onkeypress、onkeyup</p>
</li>
<li><p>鼠标事件，适用于所有html5元素。onclick、ondblclick、ondrag、ondragend、ondragenter、ondragleave、ondragover、ondragstart、ondrop、onmousedown、onmousemove、onmouseout、onmouseover、onmouseup、onmousewheel、onscroll</p>
</li>
<li><p>媒体事件，适用于所有html5元素，常用于媒介元素（audio、embed、img、object以及video）。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/小命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/小命令/" itemprop="url">小命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T11:53:22+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>windows查看所有连接和端口号：netstat -ano</p>
</li>
<li><p>linux查看运行进程：ps aux | grep xxx(用户名)</p>
</li>
<li><p>更新包：</p>
<ul>
<li><p>手动跟新：修改package.json中依赖包版本，执行npm install –force</p>
</li>
<li><p>使用第三方插件：</p>
<ul>
<li><p>npm install -g npm-check-updates</p>
</li>
<li><p>ncu // 查看可更新包</p>
</li>
<li><p>ncu -u // 更新package.json</p>
</li>
<li><p>npm install // 升级到最新版本</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改nodejs默认的npm安装目录</p>
<ul>
<li>默认安装路径：C://用户/[用户名]/AppData/Roming/npm/node_meodules</li>
<li><p>CMD中重新设置：</p>
<ul>
<li>npm config set prefix “D:\sw\develop\nodejs\npm”</li>
<li>npm config set cache “D:\sw\develop\nodejs\npm\cache”</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/08/js知识点复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/js知识点复习/" itemprop="url">js知识点复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T15:56:10+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>JavaScript实现</p>
<p>  &emsp;&emsp;JavaScript由3个部分组成：</p>
<ul>
<li><p>核心（ECMAScript）：不依赖web浏览器，是语言基础。Web浏览器是它实现的宿主环境之一，提供它的实现和扩展。其他宿主环境Node（服务器JavaScript平台）和Adobe Flash；2017年6月，ES8或ES2017发布。主要新功能：</p>
<ul>
<li><p>字符串填充：<code>str.padStart(targetLength [, padString])</code>;<code>str.padEnd(targetLength[, padString])</code></p>
</li>
<li><p>Object.value和Object.entries：以与<code>for in</code>循环所提供的顺序相同的顺序返回给定对象自己的枚举属性值/对的数组。IE不支持</p>
</li>
<li><p>Object.getOwnPropertyDescriptors：返回指定对象的所有属性描述符。可配置、枚举、读写、设置。IE未知支持状态</p>
</li>
<li><p>功能参数列表和调用中的逗号不会引发错误</p>
</li>
<li><p>异步功能，工作方式与生成器相似但不会转换为生成器。？？IE未知支持状态。</p>
</li>
<li><p>共享内存和原子：共享存储器时，多个线程可以在内存中读取和写入相同的数据。 原子操作确保可预测的值被写入和读取，在下一个操作开始之前完成操作，并且操作不被中断。？？火狐支持。</p>
</li>
<li><p>博文来自于<a href="http://blog.csdn.net/lihefei_coder/article/details/75068578" target="_blank" rel="noopener">http://blog.csdn.net/lihefei_coder/article/details/75068578</a></p>
</li>
</ul>
</li>
<li><p>文档对象模型（DOM）：针对 XML 但经过扩展用于 HTML 的应用程序编程接口，把整个页面映射为一个多层节点结构。HTML或 XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。为了跨平台。DOM有3级，映射文档结构–&gt;视图、事件、样式、遍历和范围–&gt;加载、保存、验证文档。</p>
</li>
<li><p>浏览器对象模型（BOM）：控制浏览器显示的页面以为的部分，处理浏览器窗口和框架。没有标准，但基本的windows、Navigator都有，它的扩展有location、screen、cookies、XMLHttoRequest/ActiveXObject对象。</p>
</li>
</ul>
</li>
<li><p><code>&lt;script&gt;</code>元素</p>
<ul>
<li><p>async：立即下载脚本，适用于外部脚本文件。不保证按照指定顺序执行。</p>
</li>
<li><p>charset：字符集</p>
</li>
<li><p>defer：延迟到文档完全被解析和显示后执行。不一定会按照顺序执行，最好只有一个延迟脚本，只适用于外部脚本文件。</p>
</li>
<li><p>src</p>
</li>
<li><p>type：默认text/javascript。在元素内部插入另一个script时要用转义符转义/。</p>
</li>
</ul>
</li>
<li><p>文档模式</p>
<ul>
<li><p>混杂模式quirks mode，与IE5相同</p>
</li>
<li><p>标准模式standards mode</p>
</li>
<li><p>准标准模式通过过渡型transitianal或框架集型frameset触发。</p>
<p>&emsp;&emsp;标准模式指除了混杂模式以外的模式。</p>
</li>
</ul>
</li>
<li><p><code>&lt;noscript&gt;</code>元素：包含浏览器不支持的脚本，平稳退化。</p>
</li>
<li><p>基本概念</p>
<ul>
<li><p>标识符区分大小写，驼峰大小写</p>
</li>
<li><p>严格模式：<code>use strict</code>，编译指示，不要乱搞</p>
</li>
<li><p>变量松散类型，可以保存任何类型数据。</p>
</li>
<li><p>5种简单/基本数据类型：Undefined、Null、Boolean、Number、String和1种复杂数据类型：Object。不允许自己创建类型。区分用操作符typeof，不是函数。特殊情况：</p>
<ul>
<li><p><strong>typeof null;</strong> //object, null是空指针对象<br>  typeof null === “object”//true<br>  typeof null === Object//false</p>
</li>
<li><p><strong>typeof undefined</strong> //undefined<br>  typeof undefined === undefined //false<br>  typeof undefined === “undefined” //true</p>
</li>
<li><p><strong>typeof Number</strong> //function<br>  typeof Number === “function”//true<br>  typeof Number === Function//false<br>  typeof Number === function //被当成没写完的函数</p>
</li>
<li><p><strong>typeof String </strong>//function<br>  typeof String === “function”//true</p>
</li>
<li><p><strong>typeof Boolean</strong>//function<br>  typeof Boolean === “function”//true</p>
</li>
<li><p>使用typeof可以区分给定变量的数据类型，以及区分函数和其他对象</p>
</li>
<li><blockquote>
<p>函数也<br>  确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。</p>
</blockquote>
</li>
<li><p>&emsp;&emsp;typeof检测变量时可以检测出具体的基本数据类型还是object。在检测函数的时候，会有些特殊情况。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/08/js知识点复习/typeof检测函数.png" alt="typeof检测函数"></p>
<ul>
<li><ul>
<li><p>Undefined类型</p>
</li>
<li><p>var 声明变量但没有初始化的变量类型</p>
</li>
<li><p>typeof 没定义的或只定义的，结果都是underfined</p>
</li>
<li><p>Null类型</p>
</li>
<li><p>空指针对象，变量准备保存对象，初始化null。</p>
</li>
<li><p>undefined派生自null，<code>null == undefined//true</code>,这里是因为做比较转化为其他操作符; <code>null === undefined//false</code>.相等操作符将两边的值转为数值。</p>
</li>
<li><p>Boolean类型</p>
</li>
<li><p>与数组不一样，true不一定等于1</p>
</li>
<li><p>区分大小写，True和False只是标识符</p>
</li>
<li><p>所有类型值都有与这两个Boolean值等价的值，使用Boolean()</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/03/08/js知识点复习/boolean转换规则.png" alt="Boolean转换规则"></p>
<p>   &emsp;&emsp;也就是说所有数据类型都可以转换为false：0, ‘’, false, null, undefined, NaN.</p>
<ul>
<li><ul>
<li><p>Number类型</p>
<ul>
<li><p>使用IEEE754格式表示整数和浮点数。</p>
</li>
<li><p>保存浮点数值会转换为整数值，浮点数最高精度17位小数，算数计算精度不如整数。</p>
<ul>
<li>0.1 + 0.2 = 0.30…04；</li>
<li>0.1 + 0.7 = 0.777..9;</li>
<li>0.2 + 0.4 = 0.600…01;</li>
<li>0.2 + 0.7 = 0.8999..99;</li>
<li>0.3 + 0.6 = 0.899..99;</li>
</ul>
</li>
<li><p>最小值Number.MIN_VALUE=5e-324;最大值Number.MAX_VALUE=1.7…e+308;超出范围转换为Infinity/-Infinity，不能参与计算。isFinite()判断数值是不是有穷的。Number.NEGATIVE_INFINITY保存-Infinity，Number.POSITIVE_INFINITY保存Infinity。</p>
</li>
<li><p>NaN，非数值。表示一个本来要返回数值的操作数未返回数值的情况，防止抛出错误。涉及NaN的操作返回NaN，与任何值都不想等，包括本身。isNaN()确定参数是否“不是数值”。接收到参数后尝试将这个值转换为数值，不能转换则返回true。</p>
<ul>
<li>0/0 = NaN；</li>
<li>正数/0 = Infinity；</li>
<li>负数/0=-Infinity；</li>
</ul>
</li>
<li><p>非数值转换为数值</p>
<ul>
<li><p>Number()可用于任何数据类型。Boolean被转换为1和0；null–0；undefined–NaN；字符串–直接转、浮点数、十进制、0、NaN；对象–先调用valueOf()方法，然后依照前面的规则转换。效果同一元加操作符。</p>
<ul>
<li>一元+操作符的转换在遇到长度为2以上的数组的时候结果的NaN，数组长度为空、0、1都为0.</li>
<li><code>console.log(+[undefined])</code>结果为0.</li>
</ul>
</li>
<li><p>parseInt()[由于Number()处理字符串比较复杂]，更多的看是否符合数值模式，会忽略字符串前面的空格。第一个字符不是数字或负号，则返回NaN；parseInt()返回NaN(Number()对空字符返回0)；后面的字符被忽略；可以识别出进制，但是在ES3和ES5中对八进制样式的字符转换存在差别，所以它提供了第二个参数。</p>
</li>
<li><p>parseFloat()与parseInt()的差别一是字符串中第一个小数点有效，其他无效；第二是它忽略前导的0，所以十六进制的字符串被转换为0；只解析十进制，没有用第二个参数指定基数的用法；字符串包含是整数，就转换为整数。</p>
</li>
<li><p>字符串转数组的方法：split(‘’);   </p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>String类型</p>
<ul>
<li><p>字符串是不变的，要销毁再创建新的字符串。过程在后台发生。</p>
</li>
<li><p>转换为字符串：</p>
<ul>
<li><p>toString():数值、布尔值、对象和字符串值都有，null和undefined没有。数字转换可以传递基数。</p>
</li>
<li><p>String()：可以在不知道是null或undefined的情况下使用，可以将任何类型的值转换为字符串。类型有toString()方法的，去调用，值是null时返回null，undefined返回undefined。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>object类型，每个object实例都有下面的属性和方法</p>
<ul>
<li><p>constructor</p>
</li>
<li><p>hasOwnProperty(propertyName)：检查给定属性在当前对象实例中是否存在</p>
</li>
<li><p>isPrototypeOf(object)：传入的对象是否是传入对象的原型</p>
</li>
<li><p>propertyIsEnumerable(propertyName)：检查给定属性是否能使用for-in枚举</p>
</li>
<li><p>toLocaleString()：返回对象的字符串表示，与执行环境的地区对应</p>
</li>
<li><p>toString()对象的字符串表示</p>
</li>
<li><p>valueOf()返回对象的字符串、数值或布尔值表示，通常与toString()一致</p>
</li>
<li><p>toString()与valueOf()的区别：toSting返回文本表示；valueOf返回对象本身；除了null、undefined所有数据类型都支持她俩，valueOf()在遇到alert的时候还会调用toString</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>访问变量有按值传递和按引用传递，而参数只能按值传递。</p>
<p>  举例：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">     obj.name = <span class="string">"Nicholas"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">/*"Nicholas"*/</span></div></pre></td></tr></table></figure>
<p>   &emsp;&emsp;和</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    obj.name = <span class="string">"Nicholas"</span>;</div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = <span class="string">"Greg"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<ul>
<li><p>最常用的垃圾收集机制是标记清除</p>
</li>
<li><p>引用类型之数组类型对象：</p>
<ul>
<li><p>先进先出FIFO：push与shift，pop与unshift；</p>
</li>
<li><p>reverse返回反转后的该数组； sort返回排序后的该数组；concat返回粘贴的新数组；slice返回取出的部分新的数组；splice返回删除元素组成的数组；pop和shift返回删除的值；push和unshift返回数组新的长度。</p>
</li>
<li><p>归并方法reduce()与reduceRight()，接收函数和一个初始值。函数又接收4个参数（前一项，后一项，索引，数组本身）。</p>
</li>
</ul>
</li>
<li><p>引用类型之Date类型</p>
<ul>
<li><p>创建日期对象var now = new Date()//Fri Mar 09 2018 10:49:22 GMT+0800 (中国标准时间)</p>
</li>
<li><p>创建指定的日期对象：</p>
<ul>
<li><p>Date.parse():接受字符串参数，返回相应日期的毫秒数。返回UTC格式的话：var someDate = new Date(Date.parse(“May 25, 2004”));</p>
</li>
<li><p>Date.UTC():接受参数不一样，年份，基于0的月份，日期、小时数、分钟和秒。且参数是数字。返回UTC格式的话在外面套new Date.</p>
</li>
<li><p>构造函数可以使用两种方法的参数。</p>
</li>
<li><p>ES5提供了Date.now()</p>
</li>
<li><p>Date类型的valueOf()方法返回日期的毫秒表示</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>引用类型与基本类型的区别是基本类型存的是值，引用类型存的是地址。基本类型值保存在栈内存中；引用类型值保存在堆内存中。  </p>
<p>测试题1 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'jirengu'</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">'jirengu'</span>;</div><div class="line"><span class="built_in">console</span>.log( a === b ); <span class="comment">//true，存值</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log( obj1 === obj2 ); <span class="comment">//false，存地址</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试题2</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">count</span>: <span class="number">10</span>&#125;;</div><div class="line"></div><div class="line">incNumber(count);</div><div class="line"><span class="built_in">console</span>.log( count );  <span class="comment">// 1</span></div><div class="line"></div><div class="line">incObject( obj1 );</div><div class="line"><span class="built_in">console</span>.log( obj1.count );</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;count&#125;;</div><div class="line">incObject( obj2 );</div><div class="line"><span class="built_in">console</span>.log( count );</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incNumber</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> ++count</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incObject</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    obj.count++</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以转换为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incNumber</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> ++count</div><div class="line">&#125;</div><div class="line"><span class="comment">//相当于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incNumber</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> count = <span class="built_in">arguments</span>[<span class="number">0</span>];   <span class="comment">//count 里面存的是内容，拷贝的也是内容</span></div><div class="line">  <span class="keyword">return</span> ++count</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incObject</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  obj.count++</div><div class="line">&#125;</div><div class="line"><span class="comment">//相当于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = <span class="built_in">arguments</span>[<span class="number">0</span>];  <span class="comment">//obj里面存储的是地址，拷贝的也是地址， 操作的是同一地址指向的那片区域</span></div><div class="line">  obj.count++</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>基本包装类型：</p>
<ul>
<li><p>为了便于操作基本类型值， ECMAScript 还提供了 3 个特殊的引用类型： Boolean、 Number 和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。基本类型值不是对象，但确实有方法。</p>
</li>
<li><p>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</div><div class="line">s1.color = <span class="string">"red"</span>;</div><div class="line">alert(s1.color); <span class="comment">/*undefined*/</span></div></pre></td></tr></table></figure>
<ul>
<li><blockquote>
<p>当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</div><div class="line">alert(result); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;falseObject是对象，会被转换成true。</p>
<ul>
<li><p>操作数组的方法：concat()、slice()、splice()；操作基本包装类型中字符串的方法：concat()、slice()、substr()、substring()</p>
</li>
<li><p>单体内置对象指在程序执行之前就有的对象，如Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，web浏览器实现了承担该角色的window对象。全局变量和函数都是global对象的属性。</p>
</li>
<li><p>声明前置<br>example1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( fn );</div><div class="line"><span class="keyword">var</span> fn = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log( fn );</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//应转换为</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> fn;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( fn );<span class="comment">//f</span></div><div class="line">fn = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log( fn );<span class="comment">//1</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;example2<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; <span class="number">3</span>; i++)&#123;</div><div class="line">    <span class="built_in">console</span>.log(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//应转化为</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(i);<span class="comment">//undefined</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">3</span>; i++)&#123;</div><div class="line">    <span class="built_in">console</span>.log(i)<span class="comment">//0,1,2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;example3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    a = <span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">    <span class="built_in">console</span>.log(a)</div><div class="line">&#125;</div><div class="line">fn();</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="comment">//应转换为</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a;</div><div class="line"></div><div class="line">    a = <span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//2</span></div><div class="line">    a = <span class="number">3</span>;</div><div class="line">    <span class="built_in">console</span>.log(a)<span class="comment">//3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">a = <span class="number">1</span>;</div><div class="line">fn();</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>-</p>
<pre><code>- 是var声明在前还是function声明的在前？who care，按先来后到，同名覆盖。当然如果一个变量已经有值，再var是无效的.
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fn)  <span class="comment">//function</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> fn;   <span class="comment">//已经声明过 fn， 再 var 无效，并不会重置为 undefined</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fn)  <span class="comment">//function</span></div></pre></td></tr></table></figure>
<ul>
<li><p>作用域：两种用法</p>
<ul>
<li>词法作用域：描述源代码中的范围，可以使用变量名引用变量。仅代码代码中不同变量名有意义的区域。</li>
</ul>
</li>
<li><p>函数作用域链<br>当代码在一个环境中执行时，会创建对象的一个作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。  </p>
<ul>
<li>测试题目1<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> fn2</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn = fn1();</div><div class="line">fn(); <span class="comment">//2</span></div><div class="line"><span class="comment">//可以转换为</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//声明</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a);<span class="comment">//找不到去fn1里面找</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a;</div><div class="line">    <span class="comment">//执行</span></div><div class="line">    a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> fn2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn;</div><div class="line">a = <span class="number">1</span>;</div><div class="line">fn = fn1();</div><div class="line">fn();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><ul>
<li>测试题2</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> fn2</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a)<span class="comment">//找不到在全局作用域下找</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn = fn1();</div><div class="line">fn(); <span class="comment">//输出1</span></div><div class="line"></div><div class="line"><span class="comment">//可以转换为</span></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a;</div><div class="line">    a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> fn2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn;</div><div class="line"></div><div class="line">a = <span class="number">1</span>; </div><div class="line">fn = fn1();</div><div class="line">fn();</div><div class="line"></div><div class="line"><span class="comment">/*如果改变a赋值的位置，则会发生改变*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> fn2</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn = fn1();</div><div class="line">fn(); <span class="comment">//输出undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>函数在执行的过程中，先从自己内部找变量;如果找不到，再从<strong>创建当前函数所在的作用域</strong>去找, 以此往上。</li>
</ul>
</li>
<li><p>闭包：</p>
<ul>
<li><p>为什么会出现这种写法：为了简写参数。先把第一个参数保存起来，再传其他的不同的参数。</p>
</li>
<li><p>定义：一个函数和声明函数的词法作用域的结合。通俗理解：一个函数内部，有一些变量无法被释放，可以通过他导出的这个函数能够被用起来。这个函数加上变量这一块的东西就是闭包。</p>
</li>
<li><p>执行一次闭包，就会创建一个新的作用域。</p>
</li>
</ul>
</li>
<li><p>跨域</p>
<ul>
<li><p>浏览器禁止访问的情景：</p>
<ul>
<li><p>1.js 里发送 ajax 请求，如果请求的 url 和当前页面的 url 非同域，则浏览器拒绝提供接受的数据并报错。</p>
</li>
<li><p>2.当前页面下引入iframe，如果 iframe 里的页面和当前页面的 url 非同域， 则浏览器禁止当前页面的 js 获取或者操作 iframe下页面的 DOM。</p>
</li>
</ul>
</li>
<li><p>对于禁止访问的场景1， 有两种方法能绕过浏览器的限制，一种是 JSONP，另外一种是 CORS</p>
</li>
<li><p>对于禁止访问的场景2， 如果两个页面拥有相同的一级域名(a.jirengu.com 和 b.jirengu.com)可通过降域的方式。 如果是不同域名，可使用<br>PostMessage</p>
</li>
<li><p>JSONP:</p>
<ul>
<li><p>可以创建一个script 标签<script src="http://api.jirengu.com/weathe.phpr?callback=showData"></script><br>这个请求到达后端后，后端会去解析callback这个参数获取到字符串showData，在发送 天气数据做如下处理：</p>
<ul>
<li><p>之前后端返回数据： {“city”: “hangzhou”, “weather”: “晴天”}</p>
</li>
<li><p>现在后端返回数据： showData({“city”: “hangzhou”, “weather”: “晴天”})</p>
</li>
</ul>
</li>
<li><p>前端script标签在加载数据后会把 showData({“city”: “hangzhou”, “weather”: “晴天”})做为 js 来执行，这实际上就是调用showData这个函数，同时参数是 {“city”: “hangzhou”, “weather”: “晴天”}</p>
</li>
<li><p>用户只需要在加载提前在页面定义好showData这个全局函数，在函数内部处理参数即可</p>
</li>
<li><p>使用前提是后台服务器需要支持处理传递进去的callback参数，并包装好这个数据。</p>
</li>
</ul>
</li>
<li><p>CORS(Cross-Origin-Resource-Sharing):</p>
<ul>
<li><p>ajax跨域请求资源的方式，IE10以上。</p>
</li>
<li><p>实现方式：当你使用 XMLHttpRequest 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; 浏览器判断该相应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据。</p>
</li>
<li><p>CORS 的表象是让你觉得它与同源的 ajax 请求没啥区别，代码完全一样。</p>
</li>
</ul>
</li>
<li><p>cors与JSONP相比，更为先进、方便和可靠</p>
<ul>
<li>jsonp只能实现get请求，cors支持所有类型的http请求</li>
<li>使用cors，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理</li>
<li>JSONP主要被老的浏览器支持，它们往往不支持CORS，绝大多数浏览器支持CORS</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象</p>
<ul>
<li>套路<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;</div><div class="line">    People.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> People(<span class="string">'jirengu'</span>);</div><div class="line">    p.sayName()</div><div class="line"><span class="string">``</span><span class="string">`   </span></div><div class="line">- </div><div class="line">    - 发生了什么</div><div class="line">    当new一个函数时</div><div class="line">        -  创建一个空对象，把一个空的对象的 proto 属性设置为 People.prototype</div><div class="line">        </div><div class="line">        - 执行函数 People， 函数里面的 this 代表刚刚创建的新对象</div><div class="line">        </div><div class="line">        - 返回这个对象</div><div class="line">        </div><div class="line">    &amp;emsp;&amp;emsp;对于第3步，如果构造函数里有 return，分情况讨论。 如果 return 的是基本类型，会忽略不计。 如果 return 的是引用类型，则返回这个引用类型。</div><div class="line">    </div><div class="line">    - 原型图</div><div class="line">    </div><div class="line">![原型图](js知识点复习/原型图.png)</div><div class="line"></div><div class="line">- </div><div class="line">    - 任何函数都有 .prototype 这个属性，对应的值是一个对象叫原型对象，这个原型对象可以被由这个函数 new 的所有对象共享</div><div class="line">    </div><div class="line">- this</div><div class="line"></div><div class="line">    - 基本上在任何情况下都不能确定，它只是个参数，要看他在被调用的时候的情况确定指向谁。</div><div class="line">    </div><div class="line">    - 函数执行的本质是在调用.call或.apply函数，他们的第一个参数就是this。严格模式下传什么指向什么，非严格模式下浏览器会做出判断。call和apply的区别是apply后面的参数会放数组中。</div><div class="line">    </div><div class="line">    - bind的作用和call、apply类似，区别是bind执行的结果返回的是一个绑定了一个对象的新函数。它在绑定的时候就已经创建了新的函数等待被执行。常见的用法是通过bind(this)将作用域绑定到调用的对象上。</div><div class="line">    </div><div class="line">    - 箭头函数下，this指向它上一级所在的环境下的this。</div><div class="line">    </div><div class="line">    - 不错的练习题：[https://xiedaimala.com/courses/b8b4c00c-6798-4caf-8bfe-ba9fbb4c6d3d/tasks/ffbb7825-1793-4793-9477-ee5a34614210](https://xiedaimala.com/courses/b8b4c00c-6798-4caf-8bfe-ba9fbb4c6d3d/tasks/ffbb7825-1793-4793-9477-ee5a34614210)</div><div class="line"></div><div class="line">&amp;emsp;&amp;emsp;测试题1：</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="keyword">var</span> name = <span class="string">'hunger'</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">   <span class="attr">name</span>: <span class="string">'valley'</span>,</div><div class="line">   <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">       <span class="keyword">this</span>.name = <span class="string">'jirengu'</span>;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">       <span class="keyword">var</span> name = <span class="string">'world'</span></div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">           <span class="keyword">var</span> name = <span class="string">'hello'</span></div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> fn2</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'oh my god'</span></div><div class="line">&#125;</div><div class="line">obj2.fn = obj.fn()</div><div class="line">obj2.fn()</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;测试题2：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'hunger'</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">   <span class="attr">name</span>: <span class="string">'valley'</span>,</div><div class="line">   <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = <span class="string">'jirengu'</span></div><div class="line">       <span class="keyword">var</span> name = <span class="string">'world'</span></div><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="string">'hello'</span></div><div class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">       &#125;</div><div class="line">       fn2()</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">obj.fn()</div></pre></td></tr></table></figure></p>
<ul>
<li><p>继承</p>
<ul>
<li>套路<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">target</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.target = target</div><div class="line">&#125;</div><div class="line">Dialog.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.target + <span class="string">' show'</span>)</div><div class="line">&#125;</div><div class="line">Dialog.prototype.hide = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.target + <span class="string">' hide'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> dialog = <span class="keyword">new</span> Dialog(<span class="string">'body'</span>)</div><div class="line">dialog.show()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Message</span>(<span class="params">target, name</span>) </span>&#123;</div><div class="line">    Dialog.call(<span class="keyword">this</span>, target)     <span class="comment">//这句很重要</span></div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line">Message.prototype = <span class="built_in">Object</span>.create(Dialog.prototype);  <span class="comment">//这句更重要</span></div><div class="line">Message.prototype.success = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' success'</span> )</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">* function fn()&#123;&#125;</div><div class="line">* fn.prototype = Dialog.prototype;</div><div class="line">* Message.prototype = new fn();</div><div class="line">* */</div><div class="line"></div><div class="line"><span class="keyword">var</span> msgBox = <span class="keyword">new</span> Message(<span class="string">'main'</span>, <span class="string">'msg'</span>)</div><div class="line">msgBox.show()</div><div class="line">msgBox.success()</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>画成原型图</p>
<p><img src="/2018/03/08/js知识点复习/继承-原型图.jpg" alt="原型图"></p>
<ul>
<li><ul>
<li><p><code>Dialog.call(this, target)</code>的作用：执行函数Dialog(target)，执行时遇到this换成当前传递的this。</p>
</li>
<li><p><code>Object.create(Dialog.prototype)</code>的作用：创建一个空对象，空对象的<strong>proto</strong>等于Dialog.prototype。</p>
</li>
<li><p>理解new的时候发生了什么</p>
<ul>
<li>创建一个空对象</li>
<li>执行函数，(Message.bind({})())遇到this就认为空对象是this，赋值后会将空对象return出来。（基本类型值时会被忽略，引用类型时就return对象）</li>
<li>这个对象会有一个<strong>proto</strong>隐藏属性，它指向Function的原型prototype。（原型的特点就是对象在查找属性和方式时从自身开始找起，找不到就到原型中去找，构成了原型链）</li>
</ul>
</li>
<li><p>Dialog.call可以用bind代替实现，Dialog.bind(this)(target);Object.create()可以自己实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> F();</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Object.create()的内部实现</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过Object.create()构建的对象不能指向构建这个对象的函数的原型。</p>
</li>
<li><p>cookie和session</p>
<ul>
<li><p>cookie是用来记录当页面关闭后仍然要记录的信息，使用<code>document.cookie</code>查看cookie。可以使用js在浏览器中设置，也可以在服务器端使用set-cookie让浏览器种下。</p>
<ul>
<li><p>每次网络请求Request headers会带上cookie，所以对传输效率有影响。</p>
</li>
<li><p>特征：只要cookie已经存在，那么以后每次发送请求时，都会自动带上这个cookie信息。</p>
</li>
<li><p>测试：很多网站的静态资源使用CDN地址而是使用当前网站域名，从cookie的角度说说这对性能有何影响?</p>
<ul>
<li>假如页面下有很多cookie，如果静态资源是同样的域名，发送请求的时候会带上这些cookie。</li>
<li>如果域名换掉了，那么cookie只对之前的域名生效，请求时就不会带上cookie。</li>
<li>发的东西体积变小了，速度变快一点</li>
</ul>
</li>
<li><p>localStorage的信息不会附在请求中</p>
</li>
</ul>
</li>
<li><p>session</p>
<ul>
<li><p>让服务器识别用户的一个机制</p>
</li>
<li><p>保存状态，可以用来判断用户是不是刚刚登录过的用户。服务器会在验证通过之后创建一个session对象，放入当前用户信息。</p>
</li>
<li><p>创建session后，会把session_id通过setcookie放到用户的cookie中，下次请求会带上这个session_id。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安全</p>
<ul>
<li><p>传输安全，体现在</p>
<ul>
<li>我发的数据，不该看的人看不懂</li>
<li>不该看的人不能伪造或修改</li>
<li>过期后不该看的人不能拿来继续用</li>
</ul>
</li>
<li><p>浏览器安全机制</p>
</li>
<li>常见攻击</li>
</ul>
</li>
<li><p>协议</p>
<ul>
<li><p>TCP/IP是协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。</p>
<ul>
<li>网络层有IP协议；</li>
<li>传输层有TCP协议、UDP协议；</li>
<li>应用层有HTTP、FTP、DNS等协议；</li>
</ul>
</li>
<li><p>Http</p>
<ul>
<li>特点是客户端发送每次请求都需要服务器回送响应，请求结束后主动释放连接，从建立连接到关闭连接的过程称为一次连接。</li>
<li>明文传输</li>
<li>端口80</li>
<li>连接无状态</li>
<li>三次握手四次挥手</li>
<li>报文,构成<ul>
<li>URI</li>
<li>URL：定位资源</li>
</ul>
</li>
<li>状态码<ul>
<li>1xx：</li>
</ul>
</li>
<li><p>缓存处理</p>
<ul>
<li>二级缓存机制：第一次请求后，服务器发送expires、Cache-Control字段。Cache-Control字段的几个值Public、Private、no-cache、no-store、max-age。当设置为no-cache时，意味着使用Etag或Last-Modified字段控制缓存。只设置Cache-Control的max-age时，请求在这个时间内，直接使用本地缓存。超过max-age，则重新发起请求，这是强缓存。如果设置了Last-Modified值（浏览器携带If-Modified-Since），就是根据服务器时间返回的header判断缓存，如果发现缓存是新的，从客户端缓存加载，返回HTTP 304。当服务器上资源有变化，但最后修改时间没有变化时，使用ETag（浏览器携带If-None-Match）判断缓存的新旧。没有替代Last-Modified的原因是分布式系统会尽量关掉Etag，因为每台机器生成的ETag都会不一样。</li>
<li>无缓存：每次请求查找返回文件，浪费带宽–》有缓存无更新：服务器内容变化，浏览器无法获知新文件–》缓存+更新（Expires）：时间格式容易写错–》缓存+更新机制升级版：设置Cache-Control，没有修改的文件再后续请求时返回文件，浪费带宽。–》缓存+更新机制终极版：二级缓存。</li>
</ul>
</li>
</ul>
</li>
<li><p>http2</p>
<ul>
<li>采用二进制格式传输数据</li>
<li>对消息头采用HPACK压缩传输</li>
<li>多路复用，通过一个连接完成并发请求</li>
<li>server push，服务器可以推送资源给客户端</li>
</ul>
</li>
<li><p>Https</p>
<ul>
<li>http，不安全，中间任何环节都可能是危险的</li>
<li>原理：在对称加密、非对称加密、hash等加密方法+有效的认证基础上实现安全数据的传输。</li>
<li>在http和tcp（传输控制协议）/udp（用户数据报协议）之间有一层安全套接层ssl/tls</li>
<li>需要申请到ca证书</li>
<li>端口443</li>
</ul>
</li>
<li><p>socket</p>
<ul>
<li>通信管道，是一种连接模式，不是协议</li>
<li>优点：1.传输数据字节级；2.传输数据时间短、性能高；3.可加密，数据安全性高</li>
<li>缺点：1.需解析；2.对开发人员要求高；3.增加了开发量</li>
</ul>
</li>
</ul>
</li>
<li><p>XSS</p>
<ul>
<li>XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</li>
<li>所有用户输入的地方都不安全</li>
<li>所有展示用户输入的地方都不安全，不能做成html放到页面上，防止恶意代码</li>
<li>不用eval()，全局环境</li>
<li>不用innerHTML</li>
<li>预防：<ul>
<li>不使用innerHTML，改用innerText</li>
<li>如果用innerHTML，字符过滤<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str = <span class="string">'hello&lt;/div&gt;&lt;script&gt;alert(1)&lt;/script&gt;'</span><span class="comment">//构造XSS攻击</span></div><div class="line"><span class="comment">//不要把用户请求的东西当成html运行，可以创建dom节点，用DOM节点的innerText把用户输入放进去。被当成字符串展示在页面上。</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CSRF</p>
<ul>
<li><p>跨站请求伪造。其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用POST方式提交参数的页面.</p>
</li>
<li><p>解决：</p>
<ul>
<li>服务器收到路由器请求时生成一个随机数并埋入页面和设置在setCookie中</li>
<li>用户发送GET或POST请求时会带上csrf_token参数</li>
<li>后台检查这个值做比较</li>
</ul>
</li>
</ul>
</li>
<li><p>性能优化</p>
<ul>
<li><p>加载优化</p>
<ul>
<li>网络越快越好：静态资源放到cdn上，节点在用户周围；服务器网速、贷款、节点多</li>
<li>东西体积越小越好：服务端开启压缩，前端压缩（图片、html、css）</li>
<li>数量越少越好：资源打包合并</li>
<li>服务器的处理速度越来越好：后端接口速度、中专速度</li>
<li>能重复利用的最好重复利用</li>
</ul>
</li>
<li><p>体验优化</p>
<ul>
<li>做好首页的静态化，服务器端的静态页面可以直接给用户</li>
<li>只给用户暂时需要的东西，轮播+按需加载</li>
<li>别让用户感觉卡顿，代码的性能优化，处理循环和DOM，检测用户滚动时</li>
<li>动画不要卡，css3的动画的性能优化（设置translate+3d可以使用GPU做渲染，transform，不要使用margin），再考虑js动画，自己实现不用setTmeout</li>
</ul>
</li>
</ul>
</li>
<li><p>尺寸和坐标</p>
</li>
<li><p>void</p>
<ul>
<li><code>void(expression)</code>执行这个表达式，返回undefined，括号可以省略。</li>
<li>主要用处是a标签。<code>&lt;a href = &quot;javascript:void(0)&quot;&gt;</code>让点击后不执行任何操作也不会刷新页面，填充<code>&lt;image&gt;</code>的src，确保不会向服务器发出垃圾请求。</li>
<li>通过采用<code>void 0</code>取undefined比采用字面上的undefined更靠谱更安全，应该有限采用void 0这种方式</li>
<li><a href="http://blog.csdn.net/u014267183/article/details/52998642" target="_blank" rel="noopener">http://blog.csdn.net/u014267183/article/details/52998642</a></li>
<li><a href="https://segmentfault.com/a/1190000000474941" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000474941</a></li>
</ul>
</li>
<li><p>js中的onload与readyState===4</p>
<ul>
<li>在浏览器支持的情况下，onload和onerror可以搭配使用，出现在XMLHttpRequest2中</li>
<li>onreadystatechange一开始就有，所有浏览器都支持</li>
<li>实际上不一样，当onreadystatechange的readyState为4时，可能对应于onload、onerror、onabort三种状态。所以onload与onerror对应使用，因为onerror也可能触发readyState===4</li>
<li><a href="https://stackoverflow.com/questions/9181090/is-onload-equal-to-readystate-4-in-xmlhttprequest" target="_blank" rel="noopener">https://stackoverflow.com/questions/9181090/is-onload-equal-to-readystate-4-in-xmlhttprequest</a></li>
</ul>
</li>
<li><p>JQuery ajax,fetch,axios</p>
<ul>
<li><p>jQuery ajax</p>
<ul>
<li>缺点：<ul>
<li>基于原生的XHR开发，XHR本身架构不清晰</li>
<li>jQuery整个项目太大，单纯使用ajax却要引入整个jQuery不合理</li>
</ul>
</li>
</ul>
</li>
<li><p>Axios</p>
<ul>
<li>优点：<ul>
<li>从node.js创建http请求</li>
<li>支持Promise API</li>
<li>客户端支持防止CSRF</li>
<li>提供了一些并发请求的接口</li>
</ul>
</li>
</ul>
</li>
<li><p>Fetch</p>
<ul>
<li>优点：<ul>
<li>更加底层，提供的API丰富</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
</ul>
</li>
<li>缺点：<ul>
<li>只对网络请求报错，对400，500都当作成功的请求，需要封装</li>
<li>fetch默认不带cookie，需要添加配置项</li>
<li>fetch不支持abort，不支持超时控制</li>
<li>fetch没有办法原生检测请求的进度，XHR可以</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://segmentfault.com/a/1190000012836882" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012836882</a></li>
</ul>
</li>
<li><p>浏览器取消默认动作</p>
<ul>
<li>默认动作是浏览器所执行的用户没有明确指定的操作。</li>
<li>点击a标签会转向目标页面、点击提交按钮提交表单、点击重置按钮重置表单、鼠标移动到带有title属性的元素上出现提示等。</li>
<li>如不希望执行这种默认操作，在事件对象上调用.stopPropagation()也无济于事，因为默认操作不是在正常的事件传播流中发生的。处理办法：<ul>
<li>W3C:e.preventDefault()</li>
<li>IE:e.returnValue = false </li>
<li>是事件对象的一个方法，作用是取消一个目标元素的默认行为，前提是有默认行为才能被取消。有默认行为的元素<code>&lt;a&gt;</code>和<code>&lt;input type=&quot;submit&quot;&gt;</code>等。当Event对象的cancelable为false时，表示没有默认行为。</li>
<li>JavaScript的return false只会阻止默认行为（仅在HTML事件属性和DOM0级事件处理方法中，才能使用），jQuery中则既阻止默认行为又防止对象冒泡。</li>
<li>firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。 </li>
<li><a href="https://www.cnblogs.com/yycode/articles/5499234.html" target="_blank" rel="noopener">https://www.cnblogs.com/yycode/articles/5499234.html</a></li>
<li><a href="https://www.cnblogs.com/yycode/articles/5499234.html" target="_blank" rel="noopener">https://www.cnblogs.com/yycode/articles/5499234.html</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*组织默认行为*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopDefault</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(e &amp;&amp; e.preventDefault)&#123;</div><div class="line">        e.preventDefault();<span class="comment">//W3C</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;<span class="comment">//IE</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*阻止冒泡行为*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(e &amp;&amp; e.stopPropagation)&#123;</div><div class="line">        e.stopPropagation();<span class="comment">//W3C</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;<span class="comment">//IE</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>纯函数（函数式编程的核心概念）</p>
<ul>
<li><p>定义有三点：</p>
<ul>
<li>对于同一参数，返回同一结果</li>
<li>完全取决于传入的参数</li>
<li>不会产生副作用</li>
</ul>
</li>
<li><p>副作用是指：</p>
<ul>
<li>发出 HTTP 调用</li>
<li>改变外部状态</li>
<li>检索今天的日期</li>
<li>Math.random()</li>
<li>向控制台输出消息</li>
<li>向数据库中添加数据</li>
</ul>
</li>
</ul>
</li>
<li><p>函数式编程</p>
<ul>
<li>定义：”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。</li>
<li>主要思想：它属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。</li>
<li><p>特点：</p>
<ul>
<li>函数是”第一等公民”</li>
<li>只用”表达式”，不用”语句”，每一个表达式都有返回值</li>
<li>没有”副作用”</li>
<li>不修改状态</li>
<li>引用透明，只依赖输入的参数</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>代码简洁，开发快速</li>
<li>接近自然语言，易于理解</li>
<li>更方便的代码管理</li>
<li>易于”并发编程”</li>
</ul>
</li>
<li>材料：<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a></li>
</ul>
</li>
<li><p>柯里化：指向需要额外数据的函数提供部分输入的流程。偏函数应用。</p>
</li>
<li><p>forin、Object.keys和Object.getOwnPropertyNames的区别。</p>
</li>
<li><p>argument，有length和callee属性。<br><a href="https://blog.csdn.net/qq_16339527/article/details/53231725" target="_blank" rel="noopener">https://blog.csdn.net/qq_16339527/article/details/53231725</a></p>
</li>
<li><p>同步、异步、事件循环：<a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004322358</a></p>
</li>
<li><p>jquery中的$有几种重载方法？（可以接受几种数据类型）</p>
<ul>
<li>jquery(expression,[context])根据css选择器字符串在页面中匹配一组元素，或者利用context参数指定匹配的范围。</li>
<li>jquery(html)根据html标记字符串，动态创建由jQuery对象包装的DOM元素。</li>
<li>jquery(elements)将一个或多个DOM对象转化为jquery对象。</li>
<li>jquery(callback)类型函数可以在页面加载完毕时执行包含的函数。$(document).ready(function(){})，简写为$(function(){})</li>
<li><a href="https://blog.csdn.net/jingcairensheng/article/details/68923478" target="_blank" rel="noopener">https://blog.csdn.net/jingcairensheng/article/details/68923478</a></li>
</ul>
</li>
<li><p>jquery九大选择器</p>
<ul>
<li>基本选择器（元素）</li>
<li>层次选择器，可以链式操作</li>
<li>过滤选择器（:/[]），又有：<ul>
<li>基础过滤选择器:first\:last\:not\:even\:odd\:eq\:gt\:lt\:header\:animated</li>
<li>内容过滤选择器:contains(text)\:empty\:has\:parent</li>
<li>可见度过滤选择器:hidden\:visible</li>
<li>属性过滤选择器[attribute][attribute=vlue][attribute!=value][attribute^=value][attribute$=vale]</li>
<li>子元素过滤选择器:nth-child()\:first-child\:last-child\:only-child</li>
<li>表单对象过滤选择器:enabled\:disabled\:checked\:selected</li>
<li>表单选择器:input\:text\:password\:radio\:checkbox\:submit\:image\:reset\:button\:file\input:hidden</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/pseudonym_/article/details/76093261" target="_blank" rel="noopener">https://blog.csdn.net/pseudonym_/article/details/76093261</a></li>
</ul>
</li>
<li><p>setTimeout与promise执行顺序</p>
<ul>
<li><a href="https://www.tuicool.com/articles/MnY7N3a" target="_blank" rel="noopener">https://www.tuicool.com/articles/MnY7N3a</a></li>
</ul>
</li>
<li><p>使用for in循环数组中的元素会枚举原型链上的所有属性，过滤这些属性的方式是使用hasOwnProperty函数。</p>
</li>
<li><p>相关博文：</p>
<ul>
<li><a href="http://blog.csdn.net/blueblueskyhua/article/details/73135938" target="_blank" rel="noopener">http://blog.csdn.net/blueblueskyhua/article/details/73135938</a></li>
<li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746</a></li>
<li><a href="http://book.jirengu.com/fe/" target="_blank" rel="noopener">http://book.jirengu.com/fe/</a></li>
<li><a href="http://blog.csdn.net/ghsau/article/details/17027893" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/17027893</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22521378</a></li>
<li><a href="https://www.cnblogs.com/wqhwe/p/5407468.html" target="_blank" rel="noopener">https://www.cnblogs.com/wqhwe/p/5407468.html</a></li>
<li><a href="http://blog.csdn.net/whb20081815/article/details/67640804" target="_blank" rel="noopener">http://blog.csdn.net/whb20081815/article/details/67640804</a></li>
<li><a href="https://www.tuicool.com/articles/mq2qm26" target="_blank" rel="noopener">https://www.tuicool.com/articles/mq2qm26</a></li>
<li><a href="http://www.cnblogs.com/strick/p/4826273.html" target="_blank" rel="noopener">http://www.cnblogs.com/strick/p/4826273.html</a></li>
<li><a href="http://blog.csdn.net/qq_36947128/article/details/72879382" target="_blank" rel="noopener">http://blog.csdn.net/qq_36947128/article/details/72879382</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/06/JS模块化编程之模块规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/06/JS模块化编程之模块规范/" itemprop="url">JS模块化编程之模块规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T21:06:46+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill-calculate/" itemprop="url" rel="index">
                    <span itemprop="name">skill calculate</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>背景</strong>：在街区地图项目中，配置webpack的时候，用到import、require、exports。比较茫然。。。</p>
<p>&emsp;&emsp;为什么模块很重要？可以方便的调用不同功能的模块并按需加载，减少命名冲突和文件依赖数量与顺序的问题。</p>
<p>&emsp;&emsp;但是如果没有规范，使用起来就很麻烦，所以产生了规范。JS的模块规范有CommonJS，AMD，CMD。</p>
<ul>
<li><strong>CommonJS</strong></li>
</ul>
<p>&emsp;&emsp;CommonJS要构建一个类似python、Java的标准库。当Ryan Dahl创造node.js项目将之用于服务器开发时，就需要模块化编程了。NodeJS是CommonJS规范的实现，webpack也是以CommonJS的形式书写的。</p>
<p>&emsp;&emsp;CommonJS定义的模块分为</p>
<ul>
<li><p>require: 模块引用，引入外部模块</p>
</li>
<li><p>exports: 模块定义，导出当前模块的方法或变量，唯一的导出口</p>
</li>
<li><p>module: 模块标识，模块本身。</p>
</li>
</ul>
<p>&emsp;&emsp;主文件直接写代码。浏览器想要兼容CommonJS，就要有四个NodeJS环境变量：1.module；2.exports；3.require；4.global</p>
<p>&emsp;&emsp;示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* module add.js*/</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/* main.js */</span></div><div class="line"><span class="keyword">var</span> &#123;add&#125; = <span class="built_in">require</span>(<span class="string">'./math'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'1 + 2 = '</span> + add(<span class="number">1</span>,<span class="number">2</span>));</div><div class="line"></div><div class="line"><span class="comment">/*自己实现模块的导出*/</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</div><div class="line">    <span class="attr">exports</span>: &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</div><div class="line">    exports.multiply = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123; <span class="keyword">return</span> n * <span class="number">1000</span> &#125;;</div><div class="line">&#125;(<span class="built_in">module</span>, <span class="built_in">module</span>.exports));</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = <span class="built_in">module</span>.exports.multiply;</div><div class="line">f(<span class="number">5</span>) <span class="comment">/* 5000 */</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;Browserify是常用的CommonJS格式转化工具(不能在浏览器中操作)，可将CommonJS转化为浏览器可用的格式。通过将模块放入一个数组，每个模块对象里，有模块编号id，模块源码source，模块依赖deps。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"id"</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">"source"</span>:<span class="string">"module.exports = function(x) &#123;\n  console.log(x);\n&#125;;"</span>,</div><div class="line">        <span class="attr">"deps"</span>:&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"id"</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">"source"</span>:<span class="string">"var foo = require(\"./foo\");\nfoo(\"Hi\");"</span>,</div><div class="line">        <span class="attr">"deps"</span>:&#123;<span class="attr">"./foo"</span>:<span class="number">1</span>&#125;,</div><div class="line">        <span class="attr">"entry"</span>:<span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<ul>
<li><strong>AMD</strong></li>
</ul>
<p>&emsp;&emsp;CommonJS规范不适用于浏览器环境，并且require是同步的。所以如果加载模块的时间很长，整个应用就会停在那里。因为模块都在服务器端（不像服务器端，模块都在本地硬盘，读取速度是硬盘的读取速度），等待时间取决于网速的快慢。所以，浏览器端的模块不能采用同步加载（synchronous），只能异步加载（asynchronous），所以出现了AMD，为前端JS的表现制定规范。</p>
<p>&emsp;&emsp;采用require()语句加载模块，要求两个参数，加载模块的数组和加载成功的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;  </div><div class="line">        <span class="comment">// 依赖必须一开始就写好   </span></div><div class="line">        a.add1() </div><div class="line">        ...  </div><div class="line">        b.add2() </div><div class="line">        ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;AMD比较适合浏览器环境，有两个JavaScript库实现AMD规范：require.js和curl.js。</p>
<p>&emsp;&emsp;原来多个文件按照顺序加载的时候会停止渲染或者依赖关系复杂，代码维护和编写困难。require.js就是为了解决这两个问题。实现js文件的异步加载，和管理模块之间的依赖性。</p>
<p>&emsp;&emsp;加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"true"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/main"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'underscore'</span>, <span class="string">'backbone'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, _, Backbone</span>)</span>&#123;</div><div class="line">　　      </div><div class="line">　　 &#125;);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<p>&emsp;&emsp;使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径(逐一加载，基于基目录加载，或网址加载)。require还提供了优化工具，把多个模块合并到一个文件中以减少http请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">require</span>.config(&#123;</div><div class="line">        <span class="attr">paths</span>: &#123;</div><div class="line">            <span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,</div><div class="line">　　　　  <span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</div><div class="line">　　　　　<span class="string">"backbone"</span>: <span class="string">"backbone.min"</span></div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;要采用define()声明和定义模块，如果需要依赖其他模块，则第一个参数为数组，并把依赖当作形参传到函数中。加载方式需要require()，参数是依赖模块数组和函数。</p>
<p>&emsp;&emsp;很多库不符合AMD规范，require.js也可以加载。但是要先定义它们的特征。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">shim</span>: &#123;</div><div class="line">        <span class="string">'underscore'</span>:&#123;</div><div class="line">            <span class="attr">exports</span>: <span class="string">'_'</span></div><div class="line">　　　　　&#125;,</div><div class="line">　　　　　<span class="string">'backbone'</span>: &#123;</div><div class="line">　　　　　　　<span class="attr">deps</span>: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</div><div class="line">　　　　　　　<span class="attr">exports</span>: <span class="string">'Backbone'</span></div><div class="line">　　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;exports值是输出变量名（外部调用的名称），deps是模块的依赖性。</p>
<p>&emsp;&emsp;提供插件实现特定功能。如domready插件，让回调函数在DOM加载完成后运行；text和image插件，允许加载文本和图片；json和mdown插件，允许加载json文件和markdown文件。</p>
<p>如何解决RequireJS模块的循环依赖问题？</p>
<p>&emsp;&emsp;循环依赖就是模块a依赖b，b依赖a，当b模块被调用时，传递给它的a是undefined。b可以在a模块被引入之后通过require(a)来获取a。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*Inside b.js:*/</span></div><div class="line">define([<span class="string">"require"</span>, <span class="string">"a"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require, a</span>) </span>&#123;</div><div class="line">    <span class="comment">/*"a" in this case will be null if a also asked for b, a circular dependency.*/</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">title</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">"a"</span>).doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;或者使用CommonJS模块的写法，使用exports创建一个空对象导出模块，可以立即被其他模块使用。适合用于导出的模块是对象而不是一个函数。</p>
<p>&emsp;&emsp;用依赖数组的时候，将export当作依赖模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*Inside b.js:*/</span></div><div class="line">define([<span class="string">'a'</span>, <span class="string">'exports'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, exports</span>) </span>&#123;</div><div class="line">     <span class="comment">//If "a" has used exports, then we have a real object reference here. However, we cannot use any of a's properties until after b returns a value.</span></div><div class="line">     exports.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="keyword">return</span> a.bar();</div><div class="line">     &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><p>CMD</p>
<p>  &emsp;&emsp;CMD的语法和AMD差不多，也是异步加载模块，seajs用这个规范写的。写起来是这样的：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123; </div><div class="line">    <span class="comment">//依赖可以就近书写 </span></div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>); </div><div class="line">    a.add1(); </div><div class="line">    ... </div><div class="line">    if (status) &#123; </div><div class="line">        <span class="keyword">var</span> b = requie(<span class="string">'./b'</span>); </div><div class="line">        b.add2(); </div><div class="line">    &#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><p>AMD与CMD最大的区别是对依赖模块的执行时机处理不同，AMD依赖前置，js可以方便的知道依赖模块是谁，立即加载；CMD就近依赖；</p>
</li>
<li><p>ES6中的module</p>
<p>  &emsp;&emsp;用export导出模块接口。写法是export {b}，不可以只写export 1/a。</p>
<p>  &emsp;&emsp;用import导入模块，必须放在文件的最开始。</p>
<p>  &emsp;&emsp;require是运行时的，import是编译时的，只选择import的接口进行编译，在性能上比require好很多；require是赋值过程，import是结构过程。import语法会被转码为require去执行。</p>
</li>
<li><p>参考博客<br><a href="https://www.cnblogs.com/terrylin/p/3347073.html" target="_blank" rel="noopener">https://www.cnblogs.com/terrylin/p/3347073.html</a><br><a href="https://www.cnblogs.com/chenguangliang/p/5856701.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenguangliang/p/5856701.html</a><br><a href="https://www.jianshu.com/p/09ffac7a3b2c" target="_blank" rel="noopener">https://www.jianshu.com/p/09ffac7a3b2c</a><br><a href="https://blog.csdn.net/u014168594/article/details/77099315" target="_blank" rel="noopener">https://blog.csdn.net/u014168594/article/details/77099315</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/js异步处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/js异步处理/" itemprop="url">js异步处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T14:20:20+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;背景：在做街区地图的项目时，我在map地图中需要通过ajax调用第三方的数据，并根据调用结果求得图片地址返回给map作为参数显示。当时没有注意到我是在做异步处理，在ajax函数里用return返回一个字符串。但是在map里调用ajax的时候，没法把ajax赋值给一个变量，导致没有正常取到需要的参数。</p>
<p>&emsp;&emsp;经过论坛里老师的指导，现在处理成在ajax函数里传入回调函数，需要处理的结果返回给回调函数。在map函数里调用ajax的时候传给ajax函数处理返回结果处理正确的函数和处理错误的函数。也就是ajax里留了“口”，返回的数据怎么处理可以交给map。而ajax函数中涉及到了异步调用，就引发了对这个问题的关注。</p>
<p>&emsp;&emsp;异步处理要解决的问题是为防止js单线程的工作模式导致页面卡死在某个地方。</p>
<p>&emsp;&emsp;常用的解决办法：</p>
<ul>
<li>setTimeout函数实现</li>
<li>script属性实现异步<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>js常用的异步处理方法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"test1.js"</span> defer&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="comment">/*当页面加载完毕后才执行代码*/</span></div><div class="line">&lt;script src=<span class="string">"test2.js"</span> <span class="keyword">async</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><span class="comment">/*异步执行script代码*/</span></div><div class="line">&lt;script src=<span class="string">"test3.js"</span>&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;执行结果的顺序是3、1、2</p>
<ul>
<li>动态创建script标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var head = document.getElementsByTagName(&apos;head&apos;)[0];</div><div class="line">var script = document.createElement(&apos;script&apos;);</div><div class="line">script.src = &apos;test1.js&apos;;</div><div class="line">head.appendChild(script);</div><div class="line">console.log(&quot;--------------------&quot;);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行结果的顺序是—-，然后是test1.js</p>
<ul>
<li>回调函数</li>
</ul>
<p>&emsp;&emsp;利用了setTimeout函数实现，把耗时的操作推迟执行。优点是简单、容易理解和部署，缺点是不利于代码阅读和维护，各个部分之间高度耦合，流程会很乱，每个任务只能指定一个回调函数。</p>
<ul>
<li><p>事件监听</p>
</li>
<li><p>发布/订阅</p>
</li>
<li><p>Promises对象</p>
</li>
</ul>
<p>参考文章：</p>
<ol>
<li><a href="https://jingyan.baidu.com/article/eae07827473f801fec5485ba.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/eae07827473f801fec5485ba.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/04/不好区分的数组方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/不好区分的数组方法/" itemprop="url">不好区分的数组方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T14:44:33+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>背景</strong>：对这篇知识点进行总结的原因是在MyReads项目里，用<code>.map()</code>进行循环的时候，控制台会给我这样的警告：<br><img src="/2018/03/04/不好区分的数组方法/map警告.png" alt="map警告"></p>
<p>一、原生JS forEach()、map()、jQuery中的$.each()、$.map()</p>
<p>前提：它们都是数组方法。</p>
<ul>
<li><strong>forEach()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*forEach*/</span></div><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    <span class="comment">/*do something*/</span></div><div class="line">&#125;, <span class="keyword">this</span>)</div><div class="line"> </div><div class="line"><span class="comment">/*或者*/</span></div><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    <span class="comment">/*do something*/</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;forEach是ECMA5新引入的，IE6-8下都不兼容（Array.prototype上没有这个方法，需要自己封装）。仅仅循环遍历数组中的每一项，不对原来数组进行修改，但是可以通过索引修改原来的数组。参数是函数，（函数的参数是当前项，索引，数组），返回值是<code>undefined</code>，不可以链式调用，没有办法终止或跳出循环，除非抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 自定义forEach</span></div><div class="line">* forEach遍历数组 </div><div class="line">* @param callback [function] 回调函数； </div><div class="line">* @param context [object] 上下文； </div><div class="line">*/  </div><div class="line"><span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> <span class="title">myForEach</span>(<span class="params">callback, context</span>)</span>&#123;</div><div class="line">	context = context || <span class="built_in">window</span>;</div><div class="line">	<span class="keyword">if</span>(<span class="string">'forEach'</span> <span class="keyword">in</span> <span class="built_in">Array</span>.prototype)&#123;</div><div class="line">		<span class="keyword">this</span>.forEach(callback, context);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i&lt; len; i++)&#123;</div><div class="line">		callback &amp;&amp; callback.call(context, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>map()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*map:*/</span></div><div class="line"><span class="keyword">var</span> new_array = arr.map(callback[, thisArg])</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;map是ECMA5新引入的，IE6-8下都不兼容（Array.prototype上没有这个方法，需要自己封装）。参数是函数，（函数的参数是当前项，索引，数组），有返回值，可以return。拷贝一份原数组，对其进行改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 自定义map</span></div><div class="line">* map遍历数组 </div><div class="line">* @param callback [function] 回调函数； </div><div class="line">* @param context [object] 上下文； </div><div class="line">*/  </div><div class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span> <span class="title">myMap</span>(<span class="params">callback,context</span>)</span>&#123;  </div><div class="line">    context = context || <span class="built_in">window</span>;  </div><div class="line">    <span class="keyword">if</span>(<span class="string">'map'</span> <span class="keyword">in</span> <span class="built_in">Array</span>.prototye) &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.map(callback,context);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">/*IE6-8下自己编写回调函数执行的逻辑*/</span>  </div><div class="line">    <span class="keyword">var</span> newAry = [];  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = <span class="keyword">this</span>.length; i &lt; len;i++) &#123;  </div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span>  callback === <span class="string">'function'</span>) &#123;  </div><div class="line">            <span class="keyword">var</span> val = callback.call(context,<span class="keyword">this</span>[i],i,<span class="keyword">this</span>);  </div><div class="line">            newAry[newAry.length] = val;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> newAry;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>$.each()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*$.each()*/</span></div><div class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>))</span>&#123;</div><div class="line">&#125;  <span class="comment">/*注意参数的顺序,在dom处理上用的较多*/</span></div><div class="line"><span class="comment">/*或者*/</span></div><div class="line">$.each(arr, <span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>))</span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;$.each()方法规定为每个匹配元素规定运行的函数，可以返回 false 可用于及早停止循环。没有返回值，匿名函数里支持2个参数：索引和当前项。</p>
<ul>
<li><strong>$.map()</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*$.map()*/</span></div><div class="line">$.map(arr, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>)</span>&#123;</div><div class="line">	<span class="comment">/*do something*/</span></div><div class="line">	<span class="keyword">return</span> xxx</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;有返回值，可以return出来。$.map()里面的匿名函数支持2个参数和$.each()里的参数位置相反：数组中的当前项v，当前项的索引 i。如果遍历的是对象，k 是键，v 是值。如果是$(“span”).map()形式，参数顺序和$.each()  $(“span”).each()一样。</p>
<ul>
<li><p><strong>经典例子</strong></p>
<ul>
<li><strong>反转字符串</strong></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'12345'</span>;</div><div class="line"><span class="built_in">Array</span>.prototype.map.call(str, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;   <span class="comment">/*同时利用了call()方法*/</span></div><div class="line">  <span class="keyword">return</span> x;</div><div class="line">&#125;).reverse().join(<span class="string">''</span>);</div></pre></td></tr></table></figure>
<ul>
<li><ul>
<li><strong>笔试题</strong></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(<span class="built_in">parseInt</span>);  <span class="comment">/*结果  [1, NaN, NaN]*/</span>　</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnInt</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(element, <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(returnInt);　<span class="comment">/*结果 [1,2,3]*/</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;parseInt()默认有两个参数，第二个参数是进制数。当parsrInt没有传入参数的时候，而map()中的回调函数时候，会给它传三个参数，第二个参数就是索引，明显不正确，所以返回NaN了。</p>
<p><strong>联想</strong>：</p>
<p>&emsp;&emsp;我在项目中，想将类数组转换为数组来调用forEach方法，则给类数组添加一个自定义方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HTMLCollection.prototype.toArray = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> [].slice.call(<span class="keyword">this</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> renderNode = <span class="built_in">document</span>.getElementsByClassName(className);</div><div class="line"></div><div class="line">renderNode[<span class="number">0</span>].children.toArray().forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="js中数组方法总结"><a href="#js中数组方法总结" class="headerlink" title="js中数组方法总结"></a>js中数组方法总结</h5><ul>
<li><p>转换方法</p>
<ul>
<li>toLocaleString()</li>
<li>toString()</li>
<li>valueOf()</li>
</ul>
</li>
<li><p>栈方法：改变原来的数组</p>
<ul>
<li>push()，返回值是添加的元素</li>
<li>pop()，返回值是被删除的元素</li>
</ul>
</li>
<li><p>队列方法：改变原来的数组</p>
<ul>
<li>shift()从前端取得项，并返回该项。结合push()是队列操作。</li>
<li>unshift()在前端增加项并返回新数组的长度。结合pop()是队列操作。</li>
</ul>
</li>
<li><p>重排序方法：改变了原来的数组</p>
<ul>
<li>reverse()</li>
<li>sort()</li>
</ul>
</li>
<li><p>操作方法</p>
<ul>
<li>concat():创建一个新数组</li>
<li>slice()：基于当前数组中的一个或多个项创建一个新数组，盖房吧的第一个参数start是必须的。（字符串也有该方法，第一个参数同样必需。）</li>
<li>splice()：可删除、插入、替换数组，会修改原来的数组。该函数的前两个参数，从何处添加/删除元素和删除多少元素是必需的。</li>
</ul>
</li>
<li><p>位置方法：接受两个参数（要查找的项和查找起点位置的索引）</p>
<ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul>
</li>
<li><p>迭代方法：接受两个参数（每一项上运行的函数和运行该函数的作用域对象-this，函数又接收三个参数【数组项的值、该项在数组中的位置、数组对象本身】）</p>
<ul>
<li>every()：每一项都返回true，则返回true</li>
<li>filter()：返回该函数会返回true的项组成的数组</li>
<li>forEach()：没有返回值</li>
<li>map()：返回每次函数调用的结果组成的数组</li>
<li>some()：任一项返回true，返回true</li>
</ul>
</li>
<li><p>归并方法：迭代数组的所有项，构建一个最终返回的值，接收两个参数：在每一项上调用的函数【前一个值、当前值、项的索引、数组对象】和作为归并基础的初始值</p>
<ul>
<li>reduce()</li>
<li>reduceRight()<br>相关博文：<br>1.<a href="https://www.cnblogs.com/leaf930814/p/6667011.html" target="_blank" rel="noopener">https://www.cnblogs.com/leaf930814/p/6667011.html</a><br>2.<a href="https://www.cnblogs.com/liuruyi/p/6483526.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuruyi/p/6483526.html</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/02/hexo方法弃用问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/hexo方法弃用问题/" itemprop="url">hexo问题集锦</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T17:09:43+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在跟新博文的时候遇到了问题，一脸茫然，解决完之后依旧一脸茫然。。。</p>
<p>不过一开始在hexo出现的警告是没了的，问题源自于不能连接到github相应的库了。</p>
<p>首先我查了在hexo上显示的错误是啥意思，报错样子：<br><a href="hexo方法弃用问题/warning.png">warning</a></p>
<p>这个方法被禁用了，也就是内部有更新了，而hexo的某些插件还引用了这个方法。所以第一，要先更新相关的插件，然后去掉对这个方法的引用。怎么知道要更新的插件是谁，这是原来遇到相似问题的人在hexo作者github上翻到的相关问题中找到了，对应了一个<code>hexo-fs</code>插件。所以先更新<code>npm install hexo-fs --save</code>.<br>第二，找到引用了这个方法的位置。<br><code>hexo clean --debug</code>这个命令可以帮助我们定位问题所在。样子：<br><a href="hexo方法弃用问题/hexo_debug.png">hexo clean –debug</a></p>
<p>所以是错误出现的上一行有问题，是引用了这个方法的所在。在<code>node_modules/hexo-deploye-git/node_modules/hexo-fs/lib/fs.js</code>中，注释掉它，这个问题就不会出现了。</p>
<p>贴出这个讲的很明白的博客：<a href="http://rangerzhou.top/2017/07/27/Hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" target="_blank" rel="noopener">RangerZhou</a></p>
<p>然后错误没有解决，我尝试<code>ping github.com</code>发现总是请求超时。等我再次使用git和hexo的时候已经好了，一脸茫然。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/02/hexo问题集锦/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/hexo问题集锦/" itemprop="url">hexo问题集锦</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T17:09:43+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在跟新博文的时候遇到了问题，一脸茫然，解决完之后依旧一脸茫然。。。</p>
<p>不过一开始在hexo出现的警告是没了的，问题源自于不能连接到github相应的库了。</p>
<p>首先我查了在hexo上显示的错误是啥意思，报错样子：<br><a href="hexo问题集锦/warning.png">warning</a></p>
<p>这个方法被禁用了，也就是内部有更新了，而hexo的某些插件还引用了这个方法。所以第一，要先更新相关的插件，然后去掉对这个方法的引用。怎么知道要更新的插件是谁，这是原来遇到相似问题的人在hexo作者github上翻到的相关问题中找到了，对应了一个<code>hexo-fs</code>插件。所以先更新<code>npm install hexo-fs --save</code>.<br>第二，找到引用了这个方法的位置。<br><code>hexo clean --debug</code>这个命令可以帮助我们定位问题所在。样子：<br><a href="hexo问题集锦/hexo_debug.png">hexo clean –debug</a></p>
<p>所以是错误出现的上一行有问题，是引用了这个方法的所在。在<code>node_modules/hexo-deploye-git/node_modules/hexo-fs/lib/fs.js</code>中，注释掉它，这个问题就不会出现了。</p>
<p>贴出这个讲的很明白的博客：<a href="http://rangerzhou.top/2017/07/27/Hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" target="_blank" rel="noopener">RangerZhou</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/24/前端框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/前端框架/" itemprop="url">前端框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T09:20:48+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>背景</strong>：比较几款前端框架，包括Backbone、AngularJS等。不讨论React。React可用于快速更新DOM，但它实际上只能处理视图，而非整个应用。这篇文章关注的是这个应用框架。</p>
<p><strong>练习</strong>：TodoMVC网站，有一个相同的TODO应用，使用不同的框架与技术编写，不过功能都一样。它的主要功能：</p>
<ul>
<li>维护大量的HTML，因为不同的HTML内容在不同的时间显示</li>
<li>DOM操作，因为经常会插入和删除视图</li>
<li>数据处理，因为能够过滤数据</li>
<li>处理用户交互，因为可以点击和输入数据并获得相应</li>
</ul>
<p><strong>问题</strong>：我们为什么要首先使用这些框架之一？为什么不坚持使用传统的服务器端应用程序？</p>
<ul>
<li>非常简短的答案是它们提供了更具响应性的用户体验。例如，当用户点击一个按钮，而不是像传统的服务器端Web应用程序一样等待整个页面重新加载时，JavaScript框架只会在用户与它们交互时加载页面的某些部分，从而加快响​​应速度的用户界面。它可以创建一个与原生移动应用程序一样快速的UI。</li>
<li>当然，你可以用传统的应用程序和一些jQuery来做类似的事情，但如果你曾经尝试过，那么你就知道你有多快就会遇到麻烦。除非你正在处理简单的事情，否则使用jQuery进行代码管理很快就会成为一种挑战，通常会导致“意大利面条”代码。</li>
<li>现代JavaScript框架通过提供明确定义的应用程序体系结构（通常使用jQuery缺乏的MVC设计模式）来提供解决代码管理问题的方法，这可以极大地简化开发。因此，在使用这些框架之一时，我们得到高度响应的用户界面以及良好结构化和可维护的代码，从长远来看这可能是一个巨大的节省时间。</li>
</ul>
<p>具体来看：</p>
<h3 id="Backbone-js"><a href="#Backbone-js" class="headerlink" title="Backbone.js"></a><strong>Backbone.js</strong></h3><p><strong>简介</strong>：Backbone在2010年首次发布，是轻量级的。在缩小和压缩以用于生产并且仅具有一个依赖项（Underscore.js）时，它只有6.3KB，它是一个高度通用且简约的MVC（模型 - 视图 - 控制器）框架，可为这些站点提供支持： Twitter，Hulu，Pinterest和潘多拉电台。将<code>Underscore</code>用作模板，并由自己的事件管理和路由系统。</p>
<p><code>&lt;%= %&gt;</code>是定界符，为一个或多个用于形成边界的字符，区分HTML与将来的JavaScript变量。</p>
<p>底层模板函数其实调用了JavaScript的构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;&#125;; <span class="xml"><span class="tag">&lt;<span class="name">----</span>&gt;</span> var obj2 = new Object();</span></div><div class="line">var arr1 = []; <span class="tag">&lt;<span class="name">----</span>&gt;</span> var arr2 = new Array();</div><div class="line">var func1 = function()&#123;&#125;; <span class="tag">&lt;<span class="name">----</span>&gt;</span> var func2 = new Function();</div></pre></td></tr></table></figure></p>
<p>并不建议使用构造函数格式，因为它不可读，更难处理，而且速度更慢。但是构造函数相比函数自变量有一个优点，它可以在运行时动态创建函数。<code>Underscore</code>的template函数的作用是构造函数，而它通过使用构造函数格式来实现这一点。最后返回一个模板函数等待被调用。</p>
<p><strong>tips</strong>：<code>ctrl+g</code>在控制台的<code>source</code>页面根据行查找；<code>ctrl+r</code>刷新页面；</p>
<p>浏览器的事件系统：告知我们网页上执行的所有操作，是DOM API极为重要的组成部分，使我们能够监听浏览器的事件系统。target可以是实现EventTarget界面的任何内容，包括网页元素、文档对象、窗口对象、甚至XHR对象。方法可传递一个事件对象。</p>
<p>on事件：<code>object.on(event, callback, [context])</code><br>大家可能只注意到了event,callback,其实这里有一个很重要的参数就是context就是事件执行的上下文环境，如果这里不指定context，则执行的函数中则无法使用this以及调用本对象中的函数.</p>
<p><strong>优点</strong>：</p>
<ul>
<li>文件小，具有多功能性。与其他框架不同，Backbone没有高度评价。例如，它不包含它自己的模板引擎（除了包含在Underscore中的基本模板），让开发人员在给定的项目中选择最适合他们的任何模板。</li>
<li>适合用于单页面应用程序（Twitter，Pinterest）或属于传统Web应用程序的小部件。</li>
</ul>
<p><strong>担心</strong>：</p>
<ul>
<li>可能更适合更高级的JavaScript开发人员。在构建Backbone应用程序时，有许多不同的库和插件可以混合使用，并且很多开发人员都喜欢这种可扩展性，但对于新手来说，这可能很具挑战性。</li>
<li>也有人担心需要过多的“样板”代码才能在项目中成功使用框架。这些抱怨往往被更有经验的开发人员所否认，他们建议那些在每个项目上编写大量样板的人都没有正确使用Backbone。</li>
<li>另一个值得关注的问题：缺少服务器端渲染。为了更深入地讨论这个问题，建议阅读Tim Kadlec关于这个话题的出色<a href="https://timkadlec.com/2015/02/client-side-templatings-major-bug/" target="_blank" rel="noopener">文章</a>。他写道，“如果你的客户端MVC框架不支持服务器端渲染，那就是一个错误。它削弱了性能。“</li>
<li>另一个关于缺乏服务器端渲染的问题是SEO。大多数搜索引擎机器人无法解析JavaScript，当它们发生在使用不支持服务器端呈现的框架的网站上时，它们不会收到内容。解决问题的方法有很多，但绝对要记住:很少有项目可以承受失去大量有机搜索流量。</li>
</ul>
<p><em>题外话：<em>*SEO(Search Engine Friendly)</em></em></p>
<ul>
<li>通俗理解是：通过总结搜索引擎的排名规律，对网站进行合理优化，使你的网站在百度和Google的排名提高，让搜索引擎给你带来客户。</li>
<li>深刻理解是：通过SEO这样一套基于搜索引擎的营销思路，为网站提供生态式的自我营销解决方案，让网站在行业内占据领先地位，从而获得品牌收益。</li>
</ul>
<p><em>题外话：<em>*服务器端（后端）渲染与浏览器端（前端）渲染</em></em></p>
<ul>
<li>服务器端渲染：服务器经过解析存放在服务器端的模板文件来计算出最终的HTML字符串，浏览器只进行HTML解析和显示。<ul>
<li>优势：前端耗时少，利于SEO</li>
<li>劣势：网络传输数据量大，占用服务器运算资源，前后端联动修改。</li>
</ul>
</li>
<li>浏览器端渲染：实现前后端分离，前端只专注于UI开发，后端只专注于逻辑的开发，前后端交互只通过约定好的API来交互，后端提供json数据，前端循环json生成DOM插入到页面中去。<ul>
<li>优势：网络传输数据量小</li>
<li>劣势：前端耗时较多，不利于SEO。</li>
</ul>
</li>
<li><strong>选择</strong>：看业务场景。注重SEO的新闻站点，非强交互的页面可以用server端渲染；像后台管理页面，或QQ空间这类强交互的网页应用，可以选择浏览器端渲染。浏览器端渲染时，如数据量不大，没有大改变，用原生的DOM API操作绰绰有余；如果是复杂页面应用，还是使用框架完成。</li>
<li>参考博文：<a href="https://www.manster.me/?p=473" target="_blank" rel="noopener">manster</a></li>
</ul>
<p><em>题外话：<em>*SPA(Single Page Application)</em></em></p>
<p><strong>总结</strong>：Backbone适合于经验丰富的开发人员构建单页面应用程序（SPA）和小部件的框架。</p>
<h3 id="AngularJS"><a href="#AngularJS" class="headerlink" title="AngularJS"></a><strong>AngularJS</strong></h3><p><small>first released in 2009 by Brat Tech LLC</small></p>
<p><strong>简介</strong>：在缩小和压缩生产时，以36KB的速度推出，Angular经常被称为Model-View-Whatever框架，因为它不符合典型的MVC设计模式。它比Backbone更强大，但是您还可以获得更多内置功能，如下所示。使用AngularJS构建的一些著名网站包括：VEVO，The Weather Channel和MSNBC。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>双向数据绑定是AngularJS最受欢迎的功能，它描述了数据绑定到视图中的HTML元素的情况，并且该元素具有更新和显示数据的能力。在Angular中，Model和View都可以更新数据，因此是“双向”描述符。 Angular实现这种形式的数据绑定可以减少创建动态视图所需的代码量。</li>
<li>另一个受欢迎的功能是指令，它允许开发人员通过将特殊行为附加到DOM的某些部分来扩展HTML。例如，ng-repeat是一个指令，它允许开发人员重复一个元素，使得它可以非常方便地执行诸如向页面打印项目数组等操作。除了Angular附带的指令外，还可以创建自己的指令，从而为UI制定行为提供了极大的灵活性。</li>
<li>依赖注入是Angular的另一个强大功能，它允许开发人员轻松地将服务包含在其模块中。例如，如果开发人员正在编写函数并希望使用$ location服务（一种在浏览器地址栏中解析URL的服务），那么所需的就是将其包含为函数的参数，并且Angular将确保该服务的一个实例可用于该功能。这对于将模拟数据注入到组件中也很有用，这是使Angular具有高度可测性的一项功能。</li>
</ul>
<p><strong>担心</strong>：</p>
<ul>
<li>双向数据绑定。虽然它使得使用Angular更容易构建，但它会使调试变得复杂并且损害性能。</li>
<li>Angular速度很慢，尤其是在更大，更复杂的应用程序中，这首先破坏了使用JavaScript框架的主要原因。当应用程序实现复杂的用户界面时，通常会看到性能不佳的情况。</li>
<li>另外值得关注的是，即将发布的Angular 2将完全重写框架：无向后兼容性。许多人认为这是Angular团队默认的初始方法有缺陷。它也可能破坏了企业之间项目的稳定性。</li>
<li>像Backbone一样，Angular缺乏服务器端渲染，尽管存在解决方法。</li>
</ul>
<p><strong>总结</strong>：Angular适用于从小型项目到企业应用程序的广泛用例。不过，如果您计划一个庞大而复杂的应用程序，那么拥有熟练的开发人员可以解决任何出现的性能问题，这一点至关重要。<br>鉴于从版本1到版本2的过渡，Angular在这个时间点似乎不是一个好选择。学习当前版本的Angular可能只会让开发人员对传统应用程序进行工作，并且仍然需要学习即将推出的版本。艰巨的任务！采用Angular 2是否是一个不错的选择还有待观察。</p>
<h3 id="Ember"><a href="#Ember" class="headerlink" title="Ember"></a><strong>Ember</strong></h3><p><small>它是由Yehuda Katz在2011年末创建的，他也是jQuery和Ruby on Rails核心团队的成员。</small><br><strong>简介</strong>：在95KB的缩小版和压缩版中，它是正在讨论的四个框架中最重要的一个（jQuery和Handlebars是必需的依赖关系，将增加这个总数）。但随着额外的大小，你会得到很多内置的功能。用Ember建立的网站包括：Qualcomm，Chicago.com，Nest，Vine和NBC News。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>Ember社区有一个通用原则：“约定而不是配置”。在与Ember合作时，您应该按照“Ember方式”进行操作。几乎所有需要编写Web应用程序的内容都是内置的，其中包括模板库，路由以及大量其他内容，旨在使开发人员免于日常和平凡的重新创建任务，让他们专注于他们的项目所特有的更大的问题。</li>
<li>Ember的一个有趣之处在于Ember CLI。尽管为了与Ember一起工作并不是必需的，但它是一个非常有用的命令行工具，可以处理许多人们通常使用Grunt或Gulp所做的事情，例如编译Sass和缩小CSS和JS。也许你不想混淆你当前的构建系统，但是如果你没有一个适合的构建系统，这是一个可以让你以最小的麻烦开始的工具。</li>
</ul>
<p><strong>担忧</strong>：</p>
<ul>
<li>Ember最大的担忧是需要以“Ember方式”做事。现在，在某种程度上，这与Angular类似，但Ember更进一步。 Ember渴望提供一个完整的解决方案，坚果汤。这当然与Backbone有明显的对比，它可以让你根据自己的喜好来混合和匹配事物。</li>
<li>这种方法也有很多生成的代码，可能会导致开发人员难以准确理解发生了什么。当你有一个庞大的框架，有很多内置功能时，学习曲线非常陡峭。</li>
<li>Ember也使用双向数据绑定，尽管它使用与Angular不同的实现。也许是为了回应社区的担忧，Ember团队已经宣布他们将来将不再使用双向数据绑定。</li>
</ul>
<p><strong>总结</strong>：Angular适用于从小型项目到企业应用程序的广泛用例。不过，如果您计划一个庞大而复杂的应用程序，那么拥有熟练的开发人员可以解决任何出现的性能问题，这一点至关重要。<br>Ember是一个很好的框架，在弱点方面，似乎有很多努力需要改进。例如，像Angular和Backbone一样，它不支持服务器端渲染，但已经宣布很快就会有这种支持，这非常棒。总体而言，我认为Ember可能最适合从事大中型项目的团队。它非常有见地，所以如果你喜欢自己推出，它可能不适合你。</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a><strong>React</strong></h3><p><small>由Facebook在2013年发布</small><br><strong>简介</strong>：Backbone，Angular和Ember通常被称为客户端MVC框架。但是，这并不能准确描述React。 Facebook说，React更多的是MVC中的V–视图部分。 React模式的其余部分很灵活，但Facebook使用Flux架构来填充它，这是一种最适合大型应用程序的模式。实际上，普通的旧React对很多应用程序来说都会很好。<br>它在被缩小和压缩以供生产时以120KB进入，使其成为文件大小最大的框架，尽管它没有任何所需的依赖关系。使用React的站点包括：Facebook，Instagram（基本上是一个大型的React应用程序），Flipboard，BBC和Netflix。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>它速度非常快。</li>
<li>它很容易学习。Angular和Ember都有很多所谓的“领域特定语言”。这是为这些框架创建相对陡峭的学习曲线的一部分。React的显著减少，使具有JavaScript体验的开发人员更容易掌握。</li>
<li>一个基于组件的方法，对于那些熟悉创建CommonJS模块的人来说很自然。每个React组件代表UI的一部分，一个表单元素，一个页面标题等。这些组件可以被混合和匹配，从而允许最大程度地重用代码。</li>
<li>React的一个非常酷的好处是您可以使用它来创建移动应用程序。没错，React Native允许开发人员学习一次React，并使用它来编写Web和iOS应用程序（Android即将推出）。</li>
<li>React也支持服务器端渲染。这对解决自开始以来困扰客户端框架的性能和搜索引擎优化问题有很长的路要走。一旦服务器呈现内容发生初始页面加载，客户端的React就会根据用户交互接管并更新UI。在服务器上完成第一次渲染消除了搜索引擎无法为网站编制索引并提供更快页面加载的风险。</li>
</ul>
<p><strong>担忧</strong>：</p>
<ul>
<li>React最具争议的方面是缺少模板和使用组件来生成UI。这基本上意味着你的HTML存在于你的JavaScript中。</li>
<li>对于很多开发者来说，这似乎是错误的。当他们意识到与特定组件有关的所有内容都位于同一个位置时，许多人就会到场。这些优势变得清晰 - 调试更容易，代码重用和关注点分离。</li>
</ul>
<p><strong>总结</strong>：React在炒作中发布。几乎任何规模的项目都可以成功地使用React，并且在解决最频繁的批评时，它擅长交付我们在框架中寻找的所有关键事项。 React Native也看起来像是游戏改变者。</p>
<p>翻译自：<a href="https://www.lullabot.com/articles/choosing-the-right-javascript-framework-for-the-job" target="_blank" rel="noopener">https://www.lullabot.com/articles/choosing-the-right-javascript-framework-for-the-job</a></p>
<p>背景知识：如今，我们使用的是 JavaScript 框架和单页面应用，但是我们来看看发展历史。</p>
<p>在传统的服务器渲染网络应用中，客户端计算机向网页发出请求。服务器创建一个网页并返回给客户端。最后，客户端加载新的网页并显示信息。如果用户与网页互动，例如通过提交表格添加或删除内容，整个过程又循环一遍。客户端将发出另一个请求，服务器返回全新的网页，客户端加载网页并再次呈现给用户。</p>
<p>在 2000 年代中期，这基本是互联网通信的唯一方式。信息存储在服务器上，客户端请求数据并刷新和显示页面。每个新的页面请求都会重复这一过程。</p>
<p>在上世纪 90 年代末，Microsoft Outlook 团队向 Internet Explorer 添加了 XMLHTTP 组件，并构建了网络版 Outlook 邮箱客户端。之后，其他浏览器利用这些代码并创建了 XMLHttpRequest。这使得浏览器能够从 Javascript 发出 HTTP 请求，并更新当前网页的某个部分，而不用从服务器上获取整个网页。在用户继续操作时，用户界面可以异步更新，而不用采用同步模式并等待获取整个页面。交换的大部分数据采用的都是 XML 格式。</p>
<p>创建框架是因为项目需要相同的初始组件，以前开发者总是执行相同的任务。框架能通过提供模板、URL管理和事件处理来控制应用程序的数据，它们代表了MVC中的视图和控制器。有些框架可以自定义元素（Angular和Ember）；在内存中创建一个Virtual DOM，并对此内存结构执行所有必要的更新和操作，再将VirtualDOM转换为真实的DOM并替换现有内容；有些是同时存在于客户端和服务器的全栈框架，能够处理数据流式传输等操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/13/hexo插入图片解决方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/13/hexo插入图片解决方法/" itemprop="url">hexo插入图片解决方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-13T22:04:51+08:00">
                2018-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong> 背景 </strong> ： 上传到hexo搭建的博客里的图片显示不出来，看着太难过了。想找配置文件修改一下，还真是看不懂。。。还好没费太多劲就找到了别人分享的解决办法。解决之后，想每一篇都用些图片呢。。。</p>
<p><strong> 步骤 </strong> ：</p>
<ul>
<li><p>修改主页配置文件<code>_config.yml</code>中的<code>post_asset_folder</code>这个选项的值为<code>true</code>。<br><img src="/2018/02/13/hexo插入图片解决方法/catalog.png" alt="hexo目录"></p>
</li>
<li><p>在<code>hexo</code>目录下（上图）执行命令<code>npm install hexo-asset-image --save</code>，目的：下载安装一个可以上传本地图片的插件。该插件源自于某位大牛：<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">github</a></p>
</li>
<li><p>安装后，运行<code>hexo new &quot;new-poster-name&quot;生成博文时，</code>/source/_posts<code>文件夹内除了</code>new-poster-name.md`文件还有一个同名的文件夹</p>
</li>
<li><p>想要上传的图片复制到这个<code>new-poster-name</code>文件夹中，然后在<code>new-poster-name.md</code>中引入图片：<code>![你想要输入的替代文字](new-poster-name/图片名.jpg)</code>。将<code>new-poster-name</code>替换为你要创建的博文的名字。</p>
</li>
</ul>
<p>&emsp;&emsp;在添加图片成功的页面中打开开发者模式，找到相应的图片代码，发现他的来源地址包含github、日期和路径。（之前是本地的地址）<br>&emsp;&emsp;转载自：<a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="noopener">Nuub的博文</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/13/MyRead-application-loading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/13/MyRead-application-loading/" itemprop="url">MyRead loading</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-13T11:05:06+08:00">
                2018-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理论知识：React"><a href="#理论知识：React" class="headerlink" title="理论知识：React"></a>理论知识：React</h2><ul>
<li><p><strong>React的重要特征</strong> ： 组合式模型，声明式特征，数据流经组件的方式。</p>
<ul>
<li><p><em>命令式代码</em> ： 通过不断控制旋钮来调节温度和告诉汽车我希望达到的温度，由它来为我调节。即我们明确的告诉Javascript做什么，如何做；</p>
</li>
<li><p><em>声明式代码</em> ： 不编写所有步骤获得结果，而是声明要完成的操作，JavaScript帮我们执行他。</p>
</li>
</ul>
</li>
<li><p><strong>React本质</strong> : 只需声明状态和标记，React会执行命令式工作，使DOM与应用同步，React是声明式的。</p>
<p>  <small>&emsp;&emsp;之前有用于管理应用状态变化的技术，是使用数据绑定。当应用某处的数据发生变化时，这些变化也会自动反应在应用中的其他方面。但是，应用中拥有该数据的任何部分，都可以更改该数据。随着应用规模增长，这种技术让人很难确定某个位置的数据变更是如何自动而隐式地影响着应用的其他部分。相比之下，React使用更明确的数据管理方式：在组件间向下传递数据，这使跟踪状态变更以及理解它对应用中其他部分造成的影响变得十分容易。称为单向数据流：数据单向从父组件流向子组件。</small></p>
<p>  &emsp;&emsp;其他框架中的数据绑定：Angular 和 Ember 等前端框架使用双向数据绑定。在双向数据绑定中，数据在整个应用中保持同步，无论是在何处更新的。如果模型更改了数据，数据会在视图中更新。如果用户在视图中更改了数据，数据会在模型中更新。双向数据绑定听起来非常强大，但是会让应用很难判断数据实际上是否更新了，以及是在何处更新的。</p>
</li>
</ul>
<p><img src="/2018/02/13/MyRead-application-loading/react.png" alt="框架图"></p>
<ul>
<li><p><strong> 工作原理 </strong> ： 数据位于父组件中，并向下传递给子组件。虽然数据位于父组件中，但是父组件和子组件都可以使用数据。然而，如果必须更新数据的话，则只有父组件应该进行更新。如果子组件需要更改数据，它会将更新的数据发送给父组件，由父组件完成更改。父组件执行更改后，会将更新的数据传递给子组件。</p>
</li>
<li><p><strong> 题外话：函数式编程</strong></p>
<blockquote>
<p>概念：以函数作为主要载体的编程方式，用函数去拆解、抽象一般的表达式。</p>
</blockquote>
<ul>
<li><p>典型的函数式编程有闭包（保留局部变量不被释放）、高阶函数（函数既可以作为参数又可以作为另一个函数的返回值使用）、柯里化（给定函数的部分参数，生成一个接受其他参数的新函数）、组合（合并多个函数，创造一个新函数）。</p>
</li>
<li><p>相关博文：</p>
<ol>
<li><a href="http://developer.51cto.com/art/201703/535299.htm" target="_blank" rel="noopener">51CTO</a>;</li>
<li><a href="https://zhuanlan.zhihu.com/p/21714695" target="_blank" rel="noopener">Starkwang</a>(<small></small></li>
<li>第二篇博文中涉及知识点<code>slice</code>，<code>splice</code>和<code>split</code>的区分。<a href="https://www.cnblogs.com/mangoWeb/p/3517801.html" target="_blank" rel="noopener">博客园-芒果干</a>)</li>
</ol>
</li>
<li><p>React基于的是大量的函数式编程的技巧。重要的函数式编程有<code>.map()</code>和<code>.filter()</code>方法。</p>
<ol>
<li><code>.map()</code>适用于数组，该方法返回新的数组，它没有修改原始数组。</li>
<li><code>.filter()</code>适用于数组，该方法也返回新的数组，返回通过检验的项目。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>与其他框架的根本区别</strong> ：</p>
<p>  &emsp;&emsp;React没有使用字符串模板，而是使用JavaScript对象来构建用户界面。React元素是轻量级JavaScript对象，而非实际的DOM节点。使用元素描述页面应该是什么样子，然后交给React来实际操作DOM，甚至可以创建自定义元素，也就是“组件”，利用它们来整齐地封装元素和行为。这些组件（可以重复利用的代码段，最终负责返回要渲染到网页上的HTML）是React的基本单位。</p>
</li>
<li><p><strong>ReactDOM</strong> : </p>
<p>  &emsp;&emsp;React是JavaScript的扩展（即JavaScript库），没有内置在浏览器中。<code>ReactDOM</code>只是使用<code>react</code>库的一种方式。在<code>react</code>中，决定要渲染什么的过程与实际渲染完全脱钩。这种脱钩使我们可以在本地设备的服务器上甚至是在VR环境中渲染事物。</p>
<ul>
<li><p><small>Class是HTML属性的名称，一旦浏览器解析完毕，并将其转换为真正的DOM，节点DOM属性名称就是className。而创建React元素时，是在描述DOM节点，而非HTML字符串。</small></p>
</li>
<li><p><small>VirtualDOM：创建的不是真正的DOM元素，而只是描述真正DOM节点的对象。在调用<code>React.createElement</code>时，没有在DOM中创建任何东西。只有执行render后，浏览器才会创建真正的DOM元素。</small></p>
</li>
<li><p>JSX是JavaScript的语法扩展，它的源代码本质上调用了<code>createElement</code>函数。JSX只能返回一个元素。</p>
</li>
</ul>
</li>
<li><p><strong> React应用构建步骤 </strong>：</p>
<ol>
<li><p><code>npm install -g create-react-app</code>；</p>
</li>
<li><p><code>create-react-app contacts</code>(contacts是react应用的名称)；</p>
</li>
</ol>
</li>
</ul>
<p><img src="/2018/02/13/MyRead-application-loading/webpack.png" alt="react安装包"></p>
<pre><code>&lt;small&gt;&amp;emsp;&amp;emsp;react应用创建过程中安装了三个包：`react`、`reactDOM`、`react-scripts`，其中`react-scripts`安装了Babel使我们可以使用最新的JavaScript语法以及JSX。安装webpack进行生成和构建。安装webpack-dev-server，使其具有自动重新加载行为&lt;/small&gt;
</code></pre><ul>
<li><p><strong>无状态函数式组件</strong> ： </p>
<p>  &emsp;&emsp;当所有组件都拥有一个<code>render</code>方法，实际上可以使用常规的旧函数来创建组件，但是不使用this访问组件的props，而是将props作为函数的第一个参数。也省去了render函数，直接使用return。</p>
<p>  &emsp;&emsp;好处是：</p>
<pre><code>- 接收props作为参数；

- 返回UI的描述；

- 不存在this关键字，不担心这个函数会被什么环境所调用。
</code></pre></li>
<li><p><strong>状态管理</strong> ： </p>
<p>  &emsp;&emsp;添加状态就是向组件中添加状态属性，其值是一个对象，表示组件的状态。每个键和值表示该组件的一部分特定状态。它能让大脑分开两个重要又复杂的概念：一是组件看起来是什么样，第二，应用当前的状态是什么。由于这种区分UI或应用的外观，只是一个关于应用状态的函数。借助React，只需考虑的是应用的状态是什么，以及UI如何根据状态做出改变。</p>
<p>  &emsp;&emsp;state放在constructor()外面意味着它是类字段，是对语言做出新更改的提议，暂时不受JavaScript支持，但是在Babel的强大转译功能下，可以使用。</p>
<p>  &emsp;&emsp;使用React构建UI组件的关键优势之一：如果要重新渲染页面，我们只需考虑更新状态。每次有更新时，我们不需要知道到底是页面的哪个部分变化了。不需要判断如何有效地重新渲染页面。React会对比之前的输出和新的输出，判断哪些改变了，并为我们做出决策。这种判断之前的输出和新的输出之间哪些变化了的流程称为<strong>一致性比较</strong>。</p>
<p>  &emsp;&emsp;不能直接更新状态，如果直接改变状态的话，React无法知道你的组件状态实际发生了变化。所以用setState方法，可传递一个函数或对象。</p>
</li>
<li><p><strong>PropTypes</strong> ： </p>
<p>  &emsp;&emsp;是一个软件包，使我们能够在一开始就定义想要看到的数据类型，如果不是我们预期的类型，PropTypes将提醒我们。</p>
</li>
<li><p><strong>受控组件</strong> ： </p>
<p>  &emsp;&emsp;React的表单通过React的受控组件来管理，受控组件是渲染表单的组件。表单状态的来源位于组件状态内，而非DOM内。</p>
<p>  &emsp;&emsp;优势：</p>
<ul>
<li><p>支持即时输入验证；</p>
</li>
<li><p>它们允许你有条件地禁用或启用表单按钮；</p>
</li>
<li><p>它们限制了输入的格式；</p>
</li>
</ul>
</li>
<li><p><strong>对象解构</strong> ：</p>
<p>  &emsp;&emsp;render方法经常访问状态对象和属性对象。因为属性和状态只是JavaScript对象，可以用ES6功能将它们拆分为单个变量，而不是每次都将他们当作<code>this.state.query</code>和<code>this.props.contacts</code>，这种拆分流程叫做对象解构。</p>
</li>
<li><p><strong>获取或管理数据库中的数据</strong> </p>
<p>  &emsp;&emsp;不能在render方法中发送AJAX请求，因为render方法不能有副作用。它仅用于渲染，不应在render方法中获取数据。它不能发出AJAX请求或执行具有异步性质的任何操作，只能接收props并返回对此UI的描述。所以有了生命周期事件（lifecycle events）的概念，是每个组件具有的特殊方法。允许我们在组件生命的某些时间运行自定义行为。</p>
<ul>
<li><p><code>componentWillMount</code> ：在DOM插入之前立即调用；</p>
</li>
<li><p><code>componentDidMount</code>：在DOM插入之后立即调用；</p>
</li>
<li><p><code>componentWillUnmount</code>: 在组件从DOM移除之前立即调用；</p>
</li>
<li><p><code>componentWillReceiveProps</code>： 在组件从即将接收全新的props时调用。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/02/13/MyRead-application-loading/生命周期函数.png" alt="生命周期事件"></p>
<p><img src="/2018/02/13/MyRead-application-loading/react生命周期.png" alt="位于组件生命周期不同阶段的React生命周期事件列表"></p>
<ul>
<li><p><strong>单页面应用(SPA)</strong>：</p>
<p>  &emsp;&emsp;浏览器不需要向服务器请求新页面，而由JavaScript处理页面之间的转换。所以服务器只发送一个初始页面。React Router是使用React构建单页面应用的一个工具，是React库。</p>
<p>  &emsp;&emsp;单页面应用可以有多种工作方式。单页面应用的一种加载方式是一次性下载整个网站的内容。这样，当你浏览网站时，一切内容已经出现在浏览器中，不需要刷新页面。单页面应用的另一种工作方式是下载渲染用户请求的页面所需的所有内容。当用户浏览到新页面时，仅对请求的内容发出异步 JavaScript 请求。</p>
<p>  &emsp;&emsp;优质单页面应用的另一个关键因素是由 URL 控制页面内容。单页面应用互动性非常高，用户希望能够仅使用 URL 就能回到特定的状态。为何这一点很重要？Bookmarkability（书签功能，很确定的是这还不是一个单词）！当你将网站添加到书签中，该书签仅仅是 URL，并没有记录该页面的状态。</p>
<p>  &emsp;&emsp;安装命令<code>npm install --save react-router-dom</code></p>
<p>  &emsp;&emsp;需要组件：</p>
<ul>
<li><p><strong>BrowserRouter</strong>：监听URL的变化，当URL变更时，它使浏览器显示相应的页面。将<code>&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;</code>包裹上整个应用。</p>
<p>&emsp;&emsp;React Router的源码：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> propTypes = &#123;</div><div class="line">		<span class="attr">basename</span>: PropTypes.string,</div><div class="line">		<span class="attr">forceRefresh</span>: PropTypes.bool,</div><div class="line">		<span class="attr">getUserConfirmation</span>: PropTypes.func,</div><div class="line">		<span class="attr">keyLength</span>: PropTypes.number,</div><div class="line">		<span class="attr">children</span>: PropTypes.node</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	history = createHistory(<span class="keyword">this</span>.props)</div><div class="line"></div><div class="line">	render() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span>  /&gt;</span></span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>&amp;emsp;&amp;emsp;当你使用 BrowserRouter 时，其实真正的是在渲染 Router 组件并将向其传递 history 属性。history 来自 [history 库](https://github.com/ReactTraining/history)（也是由 React Training 构建的）。该库的整个目标是抽象化不同环境中的区别，并提供最少的 API 来使你管理历史记录堆、导航、确认导航，并在会话之间保持状态。


&amp;emsp;&amp;emsp;简而言之，当你使用 BrowserRouter 时，你是在创建 history 对象，该对象将监听 URL 中的变化，并使你的应用知道这些变化。


- **Link**: 使用户能够在应用中进行导航。当用户点击[Link](https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/Link.js)组件时，它会通知BrowserRouter，使它更新URL，它还具备可访问性。使用键盘在应用中导航，仍可以正常工作。右键打开新窗口的功能也仍然有用。需要一个to属性，使用真实的URL。to属性可以是简单的字符串，如
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=<span class="string">"/about"</span>&gt;About&lt;<span class="regexp">/Link&gt;</span></div></pre></td></tr></table></figure>
<pre><code>&amp;emsp;&amp;emsp;链接有时候需要稍微复杂下，而不仅仅只是个字符串。例如，可以传递查询参数或链接到页面的特定部分。如果要将状态传递给新的路由，该怎么办？要考虑这些情形，你可以向 Link 的 to 属性传递对象，而不是字符串，如：
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=&#123;&#123;</div><div class="line"><span class="attr">pathname</span>: <span class="string">'/courses'</span>,</div><div class="line"><span class="attr">search</span>: <span class="string">'?sort=name'</span>,</div><div class="line"><span class="attr">hash</span>: <span class="string">'#the-hash'</span>,</div><div class="line"><span class="attr">state</span>: &#123; <span class="attr">fromDashboard</span>: <span class="literal">true</span> &#125;</div><div class="line">&#125;&#125;&gt;</div><div class="line">Courses</div><div class="line">&lt;<span class="regexp">/Link&gt;</span></div></pre></td></tr></table></figure>
<pre><code>- **Route**： 接受一个路径，匹配（也可能不匹配）当前的URL，如果匹配则Route渲染一些UI，不匹配则不渲染。属性path、render（给组件添加属性）或component。完全路径匹配在path前加exact，否则是不完全匹配。

- SPA架构总结：[戴嘉华](https://segmentfault.com/a/1190000000607661)
</code></pre><h4 id="实践应用：图书跟踪应用，代码。"><a href="#实践应用：图书跟踪应用，代码。" class="headerlink" title="实践应用：图书跟踪应用，代码。"></a>实践应用：图书跟踪应用，<a href="https://github.com/yangyunhan/Myreads" target="_blank" rel="noopener">代码</a>。</h4><ul>
<li><p><strong>export</strong> : 导出函数、模块语法。</p>
<p>  &emsp;&emsp;相关博客：<a href="https://www.cnblogs.com/libin-1/p/7127481.html" target="_blank" rel="noopener">最骚的就是你</a></p>
</li>
<li><p><strong>Array.prototype.slice.call(arguments)</strong>:</p>
<p>  &emsp;&emsp;将具有length属性的对象转化成数组，除了IE下的节点集合。</p>
<p>  &emsp;&emsp;相关博文<a href="https://www.cnblogs.com/littledu/archive/2012/05/19/2508672.html" target="_blank" rel="noopener">肥杜</a></p>
</li>
<li><p><strong>js中的prototype</strong>：</p>
<p>  &emsp;&emsp;返回对象类型原型的引用。相关博文：<a href="http://www.cnblogs.com/yjf512/archive/2011/06/03/2071914.html" target="_blank" rel="noopener">叶剑峰</a></p>
</li>
<li><p><strong>call、apply、bind用法</strong>：</p>
<p>  &emsp;&emsp;用来重定义this这个对象。bind返回的是一个新的函数，必须调用它才会被执行。三个函数的第一个参数都是this，后面的参数：call直接放进去，用逗号隔开；apply所有参数放到一个数组里；bind除了返回的是函数外，其他和call一样。</p>
<p>  &emsp;&emsp;相关博文：<a href="https://www.cnblogs.com/Shd-Study/archive/2017/03/16/6560808.html" target="_blank" rel="noopener">小莫_yu</a></p>
</li>
<li><p><strong>React无状态组件</strong>：</p>
<p>  &emsp;&emsp;没有状态的时候，使用无状态组件更好。这篇博文<a href="https://www.jianshu.com/p/bf643a328e10" target="_blank" rel="noopener">继续海阔天空</a>中提到了具体的好处：class并无必要；没有this关键字；被迫使用最好的方法；高信噪比；代码自动补全；很容易找出臃肿的组件和低劣的数据结构；便于理解；便于测试；优秀的性能表现。</p>
</li>
<li><p><strong>设计react组件样式的四种方式</strong>：</p>
<ul>
<li>inline styling：当只是添加一小部分样式属性</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> divStyle = &#123;</div><div class="line">	<span class="attr">margin</span>: <span class="string">'40px'</span>,</div><div class="line">	<span class="attr">border</span>: <span class="string">'5px solid pink'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> pStyle = &#123;</div><div class="line">	<span class="attr">fontSize</span>: <span class="string">'15px'</span>,</div><div class="line">	<span class="attr">textAlign</span>: <span class="string">'center'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Box = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;divStyle&#125;</span>&gt;</span></span></div><div class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;pStyle&#125;</span>&gt;</span>Get started with inline style<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Box;</div></pre></td></tr></table></figure>
<pre><code>- [style-component](https://github.com/styled-components/styled-components)：是一个库，当在同一个文件中要重用样式属性的时候。使用前，需要先安装依赖包。
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Div = styled.div<span class="string">`</span></div><div class="line">	margin: 40px;</div><div class="line">	border: 5px outset pink;</div><div class="line">	&amp;:hover &#123;</div><div class="line">		background-color: yellow;</div><div class="line">	&#125;</div><div class="line">`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Paragraph = styled.p<span class="string">`</span></div><div class="line">	font-size: 15px;</div><div class="line">	text-align: center;</div><div class="line">`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> OutsetBox = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Div</span>&gt;</span></span></div><div class="line">		<span class="tag">&lt;<span class="name">Paragraph</span>&gt;</span>Get started with styled-components 💅<span class="tag">&lt;/<span class="name">Paragraph</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">Div</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> OutsetBox;</div></pre></td></tr></table></figure>
<pre><code>- CSS Modules：当应用更复杂时，与CSS Stylesheet相似，这样更像组件的形式。
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./DashedBox.css'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> DashedBox = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></div><div class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#123;styles.content&#125;</span>&gt;</span>Get started with CSS Modules style<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> DashedBox;</div></pre></td></tr></table></figure>
<pre><code>- CSS Stylesheet：当应用更复杂时，不能使用简单的方式，比如存在媒体查询时。
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./DottedBox.css'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> DottedBox = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"DottedBox"</span>&gt;</span></span></div><div class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">"DottedBox_content"</span>&gt;</span>Get started with CSS styling<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> DottedBox;</div></pre></td></tr></table></figure>
<pre><code>&amp;emsp;&amp;emsp;参考博文[Agata Krzywda](https://codeburst.io/4-four-ways-to-style-react-components-ac6f323da822)
</code></pre><ul>
<li><p><code>noscript</code>标签：在不支持JavaScript的浏览器中显示替代的内容。Facebook通过此达到更好的用户体验。</p>
<p>  &emsp;&emsp;博文<a href="https://www.cnblogs.com/iamkun/p/6534447.html" target="_blank" rel="noopener">朱昆的博客</a></p>
</li>
<li><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;</code></p>
<p>  &emsp;&emsp;<code>shrink-to-fit=no</code>是为了让网页的宽度自动适应手机屏幕的宽度，并在iOS9中起作用。</p>
<p>  &emsp;&emsp;<code>&lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt;</code>设置状态栏的颜色，可使Android版Chrome在访问状态栏时自动变色。</p>
<p>  &emsp;&emsp;相关博文：<a href="https://www.jianshu.com/p/3ef0124e02e0" target="_blank" rel="noopener">饥人谷_Bayes</a></p>
</li>
<li><p><code>&lt;link rel=&quot;shortcut icon&quot;&gt;</code>:规定当前文档与被链接文档之间的关系，只有<code>stylesheet</code>得到了所有浏览器的支持。</p>
</li>
<li><p>在获取DOM或HTML元素的时候，常常会碰到取元素或者属性的时候。看到了Attribute和Property的不同和用法。Attribute是DOM节点自带的属性，如id，class，title，align等等。Property是DOM元素作为对象所附加的内容。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/13/值得记住的那些markdown语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/值得记住的那些markdown语法/" itemprop="url">值得记住的那些markdown语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T23:06:45+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;对于90后来说，已经进入中年状态很久了，症状就越来越明显。。。不得不把小事情记下来，以后我会感谢现在的自己居然有这种超前意识！毕竟我的记忆和金鱼不相上下。。。这段前言真可怕</p>
<ul>
<li><p>首行空两格(分号不可落):</p>
<ul>
<li>半方大的空白：&ensp;||&#8194;</li>
<li>全方大的空白：&emsp;||&#8195;</li>
<li>不断行的空白：&nbsp;||&#160;</li>
</ul>
</li>
<li><p>小字体：<small></small>包裹起要变小的文字</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/Block-map-loading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/Block-map-loading/" itemprop="url">Block map loading...</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T11:17:08+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="闭包和事件侦听程序"><a href="#闭包和事件侦听程序" class="headerlink" title="闭包和事件侦听程序"></a>闭包和事件侦听程序</h3><p>&emsp;&emsp;<strong>问题</strong>：</p>
<p>&emsp;&emsp;假如我们要为数组中的每个元素分别创建一个dom元素。单击任一个dom元素，它会使用alert()提示其对应数字。简单的方法是使用 for 循环遍历列表元素。单击时，会提示我们在迭代数组每个元素时的 num 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清屏</span></div><div class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</div><div class="line"><span class="built_in">document</span>.body.style.background=<span class="string">"white"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="comment">// 让我们循环遍历数组中的所有数字</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">	<span class="comment">// 这是循环中当前的数字</span></div><div class="line">	<span class="keyword">var</span> num = nums[i];</div><div class="line">	<span class="comment">// 我们为这个数字创建一个DOM元素</span></div><div class="line">	<span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">	elem.textContent = num;</div><div class="line">	<span class="comment">// ... 然后当点击 (click) 的时候，使用 alert() 提示这个数字</span></div><div class="line">	elem.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		alert(num);</div><div class="line">	&#125;);</div><div class="line">	<span class="comment">// 最后，我们把这个 dom 元素插入到 document 中去。</span></div><div class="line">	<span class="built_in">document</span>.body.appendChild(elem);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;实际上发生了什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 这个变量在我们进行迭代时 一直在改变 !</span></div><div class="line"><span class="comment">//  第一个值是1，接着是2，最后是3</span></div><div class="line"><span class="keyword">var</span> num = nums[i];</div><div class="line"></div><div class="line"><span class="comment">// 点击时...</span></div><div class="line">elem.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 在点击的时候提示num的值!</span></div><div class="line">    alert(num);</div><div class="line"></div><div class="line">    <span class="comment">// 很明显，我们提示 num 变量的值</span></div><div class="line">    <span class="comment">// 它在内部函数(指的是 addEventListener 中的匿名函数)的外面被定义。</span></div><div class="line">    <span class="comment">// 每个内部函数都指向同一个 'num' 变量… 而 'num' 变量在每一次的迭代中都发生了变化，</span></div><div class="line">    <span class="comment">// 在循环的最后它被定义为3。无论何时，点击事件调用的匿名函数都会引用同一个 'num' 变量(现在它等于3)</span></div><div class="line"></div><div class="line">&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;解决方案就是使用闭包。我们将创建一个内部作用域，以便在我们添加事件监听的时候存住num的值。其实有很多种方法可以实现这个效果 – 闭包是其中很好的一种。</p>
<p><strong>闭包的用处</strong>：</p>
<ul>
<li><p>可以在函数外部读取函数内部的变量</p>
</li>
<li><p>可以将这些变量的值在内存中持久化</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</div><div class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="comment">// 循环遍历数组中的每一个数</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line"><span class="comment">// 这是数组循环中当前的数值...</span></div><div class="line"><span class="keyword">var</span> num = nums[i];</div><div class="line"><span class="comment">// 我们为这个数创建了一个 DOM 元素</span></div><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">elem.textContent = num;</div><div class="line"><span class="comment">// ... 然后当我们点击 (click) 的时候，提示这个数字</span></div><div class="line">elem.addEventListener(<span class="string">'click'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">numCopy</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(numCopy);</div><div class="line">    &#125;;</div><div class="line">&#125;)(num));</div><div class="line"><span class="built_in">document</span>.body.appendChild(elem);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>讲闭包较好的一篇博客：<a href="http://lipeng1667.github.io/2016/12/20/closure-in-js/" target="_blank" rel="noopener">Michael Lee</a></p>
</li>
<li><p>个人理解出现上述问题是因为函数只是定义了，并没有被调用。当它调用时，内部循环已经完成了，所以一直出现循环中最后的值。为解决上述问题，就是要函数立马被执行，所以出现了立即执行函数。</p>
</li>
<li><p>相关博文：<a href="http://lipeng1667.github.io/2016/12/20/IIFE-in-js/" target="_blank" rel="noopener">Michael Lee</a></p>
</li>
</ul>
<h3 id="面条式代码"><a href="#面条式代码" class="headerlink" title="面条式代码"></a>面条式代码</h3><p>&emsp;&emsp;将事物连接到一起时，很容易杂乱。应用最终就是将一段段代码连接到一起。当将一段段代码与其他代码连到一起后，就没法移动任何代码了。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li><p>MVC/MVVM/MVP/MV*等等解决的是同一个问题，即将我们的模型与视图分开来。</p>
</li>
<li><p>MVC较深入的博文</p>
<ul>
<li><p><a href="https://www.cnblogs.com/Hackson/p/7055695.html" target="_blank" rel="noopener">cnblogs-Hackson</a></p>
</li>
<li><p><a href="http://backbonejs.org/" target="_blank" rel="noopener">Backbone</a></p>
</li>
<li><p>在jquery函数中分别定义变量data、view和octopus。其中，M指Model模型，view内部又有init设置内容和render函数更新视图。render内部用到了script模板。octopus负责将模型和视图联系在一起，模型和视图从来没有相互直接沟通，octopus是它们之间的唯一连接桥梁。整个代码的入口就是octopus，从octopus的init函数接入view的init。在octopus中的函数在对视图进行改变后需调用视图的render函数，如果是调用了模型，则直接返回数据。</p>
</li>
<li><p>路由器：可以跟踪URL的状态，在某种程度上像视图一样，用户可以看到URL并与其进行交互。路由器通常用于跟踪应用的状态。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Knockout-js"><a href="#Knockout-js" class="headerlink" title="Knockout.js"></a>Knockout.js</h3><ul>
<li><p>Model；View；ViewModel；声明式绑定：与MVC的区别就是它没有在章鱼模式或ViewModel中编写大量代码以抓取部分视图，而是采用了相反的方式，以绑定的形式将逻辑写入DOM中，实现视图和ViewModel之间的连接，而无须手动编写；自动UI刷新：Knockout会检测模型数据，发生更改时，Knockout会自动刷新视图，被称为双向绑定；依赖项跟踪：有时，模型数据取决于其他模型数据（模型之间的依赖关系），并自动跟踪这些依赖项进行相应的更新。</p>
</li>
<li><p>VM是入口，可以使用with确定范围，$.parent重新找到VM中的属性或方法。</p>
</li>
<li><p>监控对象：只是包含特殊函数的对象而已，和监控数组都是带有很多键值和方法的函数。计算监控对象。方法中的this指的是绑定上下文</p>
</li>
</ul>
<p><strong>题外话</strong>：<code>console.dir()</code>显示一个对象所有的属性和方法。</p>
<p><strong>库与组织库</strong>：其他人或其他团队编写、打包和分发的一堆JavaScript，我们可以拿来直接使用。它也可能是你编写和打包的JavaScript。比如jQuery库。本课程中谈到的库和框架，指的是组织库和框架，jQuery并不是一个组织库，它提供了很多好的方法，但并不能为我们提供资源来帮助我们组织代码。而组织库就是像jQuery等库一样，只不过它们并不针对AJAX和DOM操作，而是针对应用组织MVC或MVVM，我们所知道的模型视图章鱼模式，以及一些其他东西。</p>
<p><strong>框架</strong>：对框架的理解有很多种不同的解释。有些人说框架就是库的集合，也有人说框架调用视图呈现方式，而库需要你来调用它们。组织库和框架都能解决相同的问题，而且是以相似的方式。重要的是，不管它们如何定义，我们都可以使用他们来解决问题。</p>
<p><strong>题外话</strong>：on事件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绑定单个事件</span></div><div class="line">    $(<span class="string">":button"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"on"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 传递数据</span></div><div class="line">    $(<span class="string">":button"</span>).on(<span class="string">"click"</span>,&#123;<span class="attr">name</span>:<span class="string">"tom"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        alert(e.data.name);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 绑定多个事件</span></div><div class="line">    $(<span class="string">":button"</span>).on(<span class="string">"mouseover mouseout"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        alert(<span class="string">"移入移出"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 使用对象绑定多个事件</span></div><div class="line">    $(<span class="string">":button"</span>).on(&#123;</div><div class="line">        <span class="attr">mouseover</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="string">"移入"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">mouseout</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="string">"移出"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 阻止冒泡和默认行为</span></div><div class="line">    $(<span class="string">":submit"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        e.preventDefault();</div><div class="line">        e.stopPropagation();</div><div class="line">        alert(<span class="string">"取消默认行为和冒泡"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;与bind事件相比，on事件多了一个参数<code>select</code>，可以筛选出调用on方法的dom元素的指定子元素。on事件可以利用事件冒泡原理进行事件委托，子元素把事件委托给父元素进行事件处理。这样的好处：</p>
<ul>
<li><p>子元素很多的时候，给每个子元素都添加一个事件，会影响到性能；</p>
</li>
<li><p>为动态添加的元素绑定上指定事件。</p>
</li>
</ul>
<p><strong>题外话：JavaScript模板引擎</strong>：</p>
<ul>
<li><p>简介：将HTML结构从包含它们的内容中分离的方法，这样就可以把大段的HTML操作从JS里分离开了。在html文件中<code>&lt;script&gt;</code>标签中使用。<code>&lt;script type=&quot;text/template&quot;&gt;&lt;/script&gt;</code>。通俗理解是一个放置模板的地方，并不显示在页面上，可以看作一个容器。之后用js取模板的内容，正则匹配出所有内容，用其他东西替换，再放置到另一个容器中。</p>
</li>
<li><p>相关博文：</p>
<ul>
<li><a href="http://blog.csdn.net/thirteenfloor/article/details/55097802" target="_blank" rel="noopener">萧十三楼</a>；</li>
<li><a href="https://www.cnblogs.com/huansky/p/6073104.html" target="_blank" rel="noopener">huansky</a></li>
</ul>
</li>
<li><p>近年来，js模板引擎出现很多种类，如：baiduTemplate(百度)、artTemplate（腾讯）、juicer（淘宝）、doT、tmpl、handlebars、easyTemplate(Freemarker模板风格)、underscoretemplate、mustache、kissytemplate、jTemplates、EJS、laytpl、Jade templating、最简单的模板引擎等等。（来自博文：<a href="https://www.cnblogs.com/EasonJim/p/6228034.html" target="_blank" rel="noopener">Jim</a>）。</p>
</li>
<li><p>关于他们之间的差别和比较可参考博文</p>
<ul>
<li><a href="http://web.jobbole.com/84420/#" target="_blank" rel="noopener">伯乐在线</a>；</li>
<li><a href="https://www.cnblogs.com/52fhy/p/5393673.html" target="_blank" rel="noopener">飞鸿影</a>；<a href="http://blog.csdn.net/meikidd/article/details/8931904" target="_blank" rel="noopener">CSDN-meikidd</a></li>
</ul>
</li>
</ul>
<p><strong>题外话</strong>：localStorage.clear可以清除浏览器本地中的数据</p>
<p><strong>Side Navigation</strong> <a href="https://www.w3schools.com/howto/howto_js_sidenav.asp" target="_blank" rel="noopener">参考博文</a></p>
<p><strong>取得元素计算过后的样式</strong>：<code>window.getComputedStyle()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleBar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> nav = <span class="built_in">document</span>.getElementById(<span class="string">'options-box'</span>);</div><div class="line">        <span class="keyword">let</span> navStyle = <span class="built_in">window</span>.getComputedStyle(nav, <span class="literal">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> mapLeft = <span class="built_in">document</span>.getElementById(<span class="string">'map'</span>);</div><div class="line">        <span class="keyword">let</span> currentMapLeft = <span class="built_in">window</span>.getComputedStyle(mapLeft, <span class="literal">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> mapLeftCon = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</div><div class="line">        <span class="keyword">let</span> currentMapLeftCon = <span class="built_in">window</span>.getComputedStyle(mapLeftCon, <span class="literal">null</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="built_in">window</span>.screen.width &lt; <span class="number">576</span>)&#123;</div><div class="line">            <span class="keyword">if</span> (navStyle.display === <span class="string">'none'</span>)&#123;</div><div class="line">                nav.style.cssText = <span class="string">"display: block"</span></div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                nav.style.cssText = <span class="string">"display: none"</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (currentMapLeft.marginLeft === <span class="string">'302px'</span> &amp;&amp;</div><div class="line">                currentMapLeftCon.marginLeft === <span class="string">'302px'</span>)&#123;</div><div class="line">                mapLeft.style.cssText = <span class="string">"margin-left: 0px"</span>;</div><div class="line">                mapLeftCon.style.cssText = <span class="string">"margin-left: 0px"</span>;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentMapLeft.marginLeft === <span class="string">'0'</span> &amp;&amp;</div><div class="line">                currentMapLeftCon.marginLeft === <span class="string">'0'</span>)&#123;</div><div class="line">                mapLeft.style.cssText = <span class="string">"margin-left: 302px"</span>;</div><div class="line">                mapLeftCon.style.cssText = <span class="string">"margin-left: 302px"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            nav.style.cssText = <span class="string">"display: block"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/记忆游戏loading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/记忆游戏loading/" itemprop="url">记忆游戏loading...</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T19:26:06+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次将项目里的问题发布在群里、小团队里，并在论坛里发帖求助。收到了积极的帮助与莫大的关怀！让我感觉很温暖并且有点想继续挑战。。</p>
<ul>
<li><p><strong>setTimeout</strong></p>
<ul>
<li>遇到的第一个自己没法解决的问题是setTimeout函数，这又涉及到了JavaScript的运行机制，群里的monter还给了例子来帮助理解。简单的我认为还过得去，不知道以后情况复杂了又会怎样。</li>
<li>反正！当需要实时反馈的操作，如渲染等，就可以尝试使用setTimeout！</li>
<li>js引擎是单线程的，浏览器是多线程的，js引擎只是浏览器的一个线程而已。定时器计时、网络请求、浏览器渲染等等，都是由不同的线程完成的。js引擎与GUI引擎是互斥的。DOM操作是异步的。异步操作会被延迟到同步计算之后执行。异步代码放到一起也会造成丢帧，无法实施的反应。</li>
<li>放两篇我觉得写的还不错的博客：<ul>
<li><a href="http://blog.csdn.net/kobejayandy/article/details/17539753" target="_blank" rel="noopener">同步与异步</a></li>
<li><a href="http://www.cnblogs.com/yelongsan/p/6296700.html" target="_blank" rel="noopener">setTimeout</a></li>
<li><a href="www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html">立即调用的函数表达式</a></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>.prototype与.<strong>proto</strong></strong></p>
<ul>
<li>在掘金上遇到的一篇文章，提到的原型，狠狠的读了几遍并找书，找博客。有理解了一些，但是还没有应用到。先把整理的贴上来。<br><img src="/2017/10/31/记忆游戏loading/prototype与__proto__.jpg" alt="原型理解"></li>
<li>好的博客：<ul>
<li><a href="www.cnblogs.com/snandy/archive/2012/09/01/2664134.html">www.cnblogs.com/snandy/archive/2012/09/01/2664134.html</a></li>
<li><a href="http://www.cnblogs.com/yjf512/archive/2011/06/03/2071914.html" target="_blank" rel="noopener">http://www.cnblogs.com/yjf512/archive/2011/06/03/2071914.html</a></li>
<li><a href="http://www.cnblogs.com/haodawang/articles/5814966.html" target="_blank" rel="noopener">http://www.cnblogs.com/haodawang/articles/5814966.html</a></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>$.each()</strong></p>
<ul>
<li>因为逻辑混乱，助教建议我用jqury写，于是我又开始复习jquery（没救了，老忘。。。）。然后一开始就碰到了循环迭代的问题（也是见有人发贴才发现的，不然不知道要用什么笨方法了）。</li>
<li><p>然后某位不知其名的大神又用立即执行函数解决了问题，在我刚要放弃的时候，发现了自己试出来的方法好像也可行。所以一定要记录下来，因为下次用的时候估计是会忘的。</p>
</li>
<li><p><em>citation context</em>:洗牌。li元素对象数组，牌标字符串数组。要同时遍历li元素和字符串数组，为每个li元素添加每个字符串数组中的类名。定义了一个<code>cards_all</code>全局变量，调用了洗牌的函数<code>cards_all = shuffle(cards_all);</code>。基于此：</p>
</li>
<li><p>可能的错误：1. 一股脑的加到了一个li元素上。结果是每一个li元素上都加了所有的字符串数组，共迭代了16遍。代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;cards_all.length;i++)&#123;</div><div class="line">	$(<span class="string">".deck .fa"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		$(<span class="keyword">this</span>).addClass(cards_all[i]);</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>大神的立即调用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">       $(<span class="string">".deck .fa"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           $(<span class="keyword">this</span>).addClass(cards_all[i++]);</div><div class="line">       &#125;)</div><div class="line">   &#125;)(<span class="number">0</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>自己摸索出来的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.deck li'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">       $(<span class="keyword">this</span>).find(<span class="string">'.fa'</span>).addClass(cards_all[i]);</div><div class="line">   &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>总结来说，就是$().each()方法的理解，通常用来遍历数组和对象。对于同时遍历多个数组很方便，<code>each(i,data)</code>参数i是索引，<code>data</code>是数值，如果打印<code>data[0]</code>，出来的是两个数组的第一项。</p>
</li>
<li>如果操作DOM，看节点的内容，用<code>text()</code>和<code>html()</code>居然都不起作用。在控制台点开对象，才知道要用<code>.context</code>（Firefox、Chrome和IE都这样）。</li>
<li>说<code>$().each()</code>与<code>$.each()</code>的区别是<code>$().each()</code>用来处理DOM，<code>$.each()</code>用来处理数组。本质上都是由js的<code>call()</code>实现的。</li>
<li><code>.each()</code>与<code>.map()</code>,<code>.map()</code>是遍历某个数组，然后按照某种功能函数求得结果返回。</li>
</ul>
</li>
<li><p><em>浏览器的加载、解析、渲染过程</em></p>
</li>
</ul>
<p>&emsp;&emsp;遇到这个问题是因为我在修改审阅意见中的代码时，把jquery文件错误的放在了交互js代码的后面，导致错误<code>$未被定义</code>，把它放在head标签里就好了。所以是我浏览器的工作原理及过程没有搞清楚。找了篇文章，讲的还算是可以理解，并发现一篇有名的文章。然而不能一次看完。。先贴下</p>
<pre><code>- 了解浏览器加载、解析、渲染过程的目的：
    - 了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。
    - 了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。
    - 了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少”reflow“”repaint“的消耗。
- 相关博客：
    - [](http://blog.csdn.net/xiaozhuxmen/article/details/52014901)
    - [](http://www.codeweblog.com/how-browsers-work-%E4%B8%AD%E6%96%87%E7%89%88/)
</code></pre><ul>
<li><p><strong>用gulp搭建es6环境</strong></p>
<ul>
<li><p>gulp.src(globs[,options])匹配文件源</p>
</li>
<li><p>gulp.dest(path[,options])写文件，输出文件，如果文件不存在，则自动创建</p>
</li>
<li><p>gulp.task(name[,deps],fn)定义一个任务</p>
</li>
<li><p>gulp.watch(glob[,opts],tasks)监控文件变化</p>
</li>
<li><p>gulp文档：<a href="https://www.gulpjs.com.cn/docs/writing-a-plugin/" target="_blank" rel="noopener">https://www.gulpjs.com.cn/docs/writing-a-plugin/</a></p>
</li>
</ul>
</li>
<li><p>js刷新页面的几种方法（亲测有效）</p>
<ul>
<li><p>reload方法，强迫浏览器刷新当前页面，从客户端缓存里取当前页面</p>
<ul>
<li>window.location.reload();</li>
<li>window.location.reload(true);</li>
</ul>
</li>
<li><p>location = location;这个可以刷新页面，等同于location=location.href</p>
</li>
<li><p>assign方法，加载新的文档</p>
<ul>
<li>location.assign(location);</li>
</ul>
</li>
<li><p>replace方法，指定URL替换当前缓存在历史里的项目，使用后不能通过前进、后退来访问已经被替换的url。</p>
<ul>
<li>location.replace(location);</li>
</ul>
</li>
<li><p>幼稚的我以为location可以分为三种，其实有535种。。</p>
<ul>
<li><p><a href="http://www.phpied.com/files/location-location/location-location.html" target="_blank" rel="noopener">http://www.phpied.com/files/location-location/location-location.html</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>引用类型的值，如数组和对象，不能用<code>==</code>或<code>===</code>进行比较，得到的结果都是false。应转化为基本类型值再进行比较，如引用.toString()方法。</li>
<li><p>js数组强大的功能：splice，可以删除，添加和替换。</p>
<ul>
<li><p>删除，指明两个参数：要删除的位置和项数</p>
</li>
<li><p>添加，指明三个参数：要添加的位置，0，要添加的内容</p>
</li>
<li><p>替换，指明三个参数：要添加的位置，要删除的项数，要添加上的项数</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>最终效果：<a href="https://github.com/yangyunhan/memory-game" target="_blank" rel="noopener">https://github.com/yangyunhan/memory-game</a></p>
</li>
<li><p>待修改：动画效果插件：sweetalert 这个插件使用了最新的css特性和js特性，一般需要webpack做编译，在这个项目里使用gulp构建的前端工作自动流，暂时放弃引入。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/23/UI面试引发的血案。。。/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/23/UI面试引发的血案。。。/" itemprop="url">UI面试引发的血案。。。</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T20:36:31+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写在前面：在前端群里，某同学发了一张UI笔试题目，瞬间就不淡定了。。我要找工作\大哭\大哭\大哭<br>先上图<br><img src="/2017/10/23/UI面试引发的血案。。。/D:/软件/blog/source/_posts/UI笔试题1.jpg" alt="UI笔试题1"></p>
<p><img src="/2017/10/23/UI面试引发的血案。。。/D:/软件/blog/source/_posts/UI笔试题2.png" alt="UI笔试题2"></p>
<p>第8题</p>
<h1 id="this、作用域链、闭包、setTimeout函数"><a href="#this、作用域链、闭包、setTimeout函数" class="headerlink" title="this、作用域链、闭包、setTimeout函数"></a>this、作用域链、闭包、setTimeout函数</h1><ol>
<li>this<blockquote>
<p>函数内部的特殊对象this，引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是 window）。<br>程序例子：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//"red"</span></div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor(); <span class="comment">//"blue"</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<blockquote>
<p>上面这个函数 sayColor()是在全局作用域中定义的，它引用了 this 对象。由于在调用函数之前，this 的值并不确定，因此 this 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时， this 引用的是全局对象 window；换句话说，对 this.color 求值会转换成对window.color 求值，于是结果就返回了”red”。而当把这个函数赋给对象 o 并调用 o.sayColor()时，this 引用的是对象 o，因此对 this.color 求值会转换成对 o.color 求值，结果就返回了”blue”。<br>在闭包中使用this对象可能会导致一些问题。我们知道， this 对象是在运行时基于函数的执行环境绑定的：在全局函数中， this 等于 window，而当函数被作为某个对象的方法调用时， this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p>
</blockquote>
<p>在闭包中使用 this 对象也可能会导致一些问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">	<span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上代码先创建了一个全局变量 name，又创建了一个包含 name 属性的对象。这个对象还包含一个方法——getNameFunc()，它返回一个匿名函数，而匿名函数又返回 this.name。由于 getNameFunc()返回一个函数，因此调用 object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串。然而，这个例子返回的字符串是”The Window”，即全局 name 变量的值。为什么匿名函数没有取得其包含作用域（或外部作用域）的 this 对象呢？前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量： this 和 arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量（这一点通过图 7-2 可以看得更清楚）。不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了，如下所示。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">	<span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> that.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">alert(object.getNameFunc()()); <span class="comment">//"My Object"</span></div></pre></td></tr></table></figure></p>
<p>代码中突出的行展示了这个例子与前一个例子之间的不同之处。在定义匿名函数之前，我们把 this对象赋值给了一个名叫 that 的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。即使在函数返回之后， that 也仍然引用着 object，所以调用object.getNameFunc()()就返回了”My Object”。</p>
</blockquote>
<p>特殊情况下， this 的值可能会意外地改变。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">	<span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">object.getName(); <span class="comment">//"My Object"</span></div><div class="line">(object.getName)(); <span class="comment">//"My Object"</span></div><div class="line">(object.getName = object.getName)(); <span class="comment">//"The Window"，在非严格模式下</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>第一行代码跟平常一样调用了 object.getName()，返回的是”My Object”，因为 this.name就是 object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只是在引用一个函数，但 this 的值得到了维持，因为 object.getName 和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 this 的值不能得到维持，结果就返回了”The Window”。</p>
</blockquote>
<ol>
<li>作用域链<blockquote>
<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 ECMAScript 程序中的执行流正是由这个方便的机制控制着。<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。<br>代码：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">		anotherColor = color;</div><div class="line">		color = tempColor;</div><div class="line">		<span class="comment">// 这里可以访问 color、 anotherColor 和 tempColor</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 这里可以访问 color 和 anotherColor，但不能访问 tempColor</span></div><div class="line">	swapColors();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这里只能访问 color</span></div><div class="line">changeColor();</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<blockquote>
<p>以上代码共涉及 3 个执行环境：全局环境、 changeColor()的局部环境和 swapColors()的局部环境。全局环境中有一个变量 color 和一个函数 changeColor()。 changeColor()的局部环境中有一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变量 color。 swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。</p>
<ol>
<li>闭包<br>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。<br>代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以上代码先定义了 compare()函数，然后又在全局作用域中调用了它。当调用 compare()时，会创建一个包含 arguments、 value1 和 value2 的活动对象。全局执行环境的变量对象（包含 result和 compare）在 compare()执行环境的作用域链中则处于第二位。<br>后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建 compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用 compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中 compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。<br>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。<br>代码：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">		<span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在 createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 createComparisonFunction()的活动对象。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> compare = createComparisonFunction(<span class="string">"name"</span>);</div><div class="line"><span class="keyword">var</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>在匿名函数从 createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当 createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后， createComparisonFunction()的活动对象才会被销毁。<br>闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。<br>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说明这个问题。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值，即位置 0 的函数返回 0，位置 1 的函数返回 1，以此类推。但实际上，每个函数都返回 10。因为每个函数的作用域链中都 保 存 着 createFunctions() 函 数 的 活 动 对 象 ， 所 以 它 们 引 用 的 都 是 同 一 个 变 量 i 。 当createFunctions()函数返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是 10。<br>可以通过创建另一个匿名函数强制让闭包的行为符合预期.<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> num;</div><div class="line">			&#125;;</div><div class="line">		&#125;(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在重写了前面的 createFunctions()函数后，每个函数就会返回各自不同的索引值了。在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数 num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量 i。由于函数参数是按值传递的，所以就会将变量 i 的当前值复制给参数 num。而在这个匿名函数内部，又创建并返回了一个访问 num 的闭包。这样一来， result 数组中的每个函数都有自己num 变量的一个副本，因此就可以返回各自不同的数值了。</p>
</blockquote>
<ol>
<li>setTimeout()<br>对第8题的解答：setTimeout里的函数，会被放到调用栈的尾部，意思呢就是说for循环执行完了，才会开始打印i，这个i在for循环结束时已经是5了。所以打印5个5。<br>对setTimeout()函数的重新认识</li>
</ol>
<ul>
<li>定时器：参数func要么是函数名，要么是字符串，因为引擎内部使用eval函数，将字符串转为代码。还可传递更多的参数，绑定在回调函数上。</li>
<li>setTimeout()中回调函数中的this：如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。</li>
<li>运行机制是必须等到当前脚本的同步任务和“任务队列”中已有的事件全部处理完以后，才会执行setTimeout指定的任务。</li>
<li>应用：<ul>
<li>调整事件的发生顺序，特别是onkeypress、onkeydown等事件；</li>
<li>分割耗时：单线程容易出现阻塞，递归调用</li>
<li>但耗费CPU<br>一个讲的更详细的<a href="http://caibaojian.com/about-settimeout.html" target="_blank" rel="noopener">博客</a></li>
</ul>
</li>
</ul>
<p>另附一个概念说明，关于js的 <a href="https://segmentfault.com/a/1190000009041008" target="_blank" rel="noopener">执行上下文、函数堆栈、提升</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/28/tips-of-irlab-s-website/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/tips-of-irlab-s-website/" itemprop="url">tips of irlab's website</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-28T10:05:14+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、<link>标签的rel属性规定当前文档与被链接文档之间的关系，只有”stylesheet”值得到了所有浏览器的支持，其他值只得到了部分的支持。没有”stylesheet”的指明，样式表不起作用。”stylesheet”表示外部样式表。</p>
<p>2、animation与关键帧</p>
<p>3、”ch”表示一个0字符的宽度，000000是6ch。</p>
<p>4、text-align:justify实现两端对齐文本效果，前提是文本多于两行，如果文本只有一行或者是最后一行，则强行变成两行并隐藏，这样第一行才会有效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;p class=&quot;center&quot;&gt;我是两端对齐文字两端对齐文字&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</div><div class="line"></div><div class="line">.center&#123;</div><div class="line">text-align:justify;</div><div class="line">&#125;</div><div class="line"></div><div class="line">span&#123;</div><div class="line">display:inline-block;</div><div class="line">width:100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、text-overflow:ellipsis当对象内文本溢出时显示省略标记</p>
<p>6、line-height与verticla-align<br>vertical-align对块状元素不起作用？<br><a href="http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/</a></p>
<p>7、cursor:pointer规定设定网页浏览时用户鼠标指针的样式为一只伸出食指的手。</p>
<p>8、版权符号：alt键+169，松开alt键</p>
<p>9、<code>&lt;meta http-equiv=&quot;X-UA-COMPATIBLE&quot; content=&quot;IE=Edge&quot;&gt;</code><br>强制IE8采用低版本方式渲染，<code>IE=edge</code>告诉IE使用最新的引擎渲染网页</p>
<p>10、<a>标签的target属性规定打开链接时用什么目标打开，在新窗口中打开是target=_blank，在父窗口中打开是target=_parent，在当前窗口中打开是target=_self，在顶层窗口中打开是target=_top。</a></p>
<p>11、word-wrap与word-break<br>word-wrap:break-word.是否允许浏览器在单词内进行断句，为防止当一个字符串太长而找不到自然断句点时产生溢出现象。<br>他会先尝试挪到下一行，看下一行的宽度够不够，不够的话就进行单词内断句。<br>word-break:break-all.怎么样进行单词内的断句。<br>断句方式粗暴，不会尝试把长单词挪到下一行，而是直接进行单词内的断句，更省空间。</p>
<p>12、盒子左边向左指的三角形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.ir-paper-item::after&#123;</div><div class="line">	color: #8e8e8e;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	border-with: 8px 12px;</div><div class="line">	border-style: solid;</div><div class="line">	border-color: transparent #fff transparent transparent;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>13、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ScrollChange.prototype.init = function () &#123;</div><div class="line">        this.contentHeight = (function () &#123;</div><div class="line">            var heightArr = [];</div><div class="line">            for(var i=0;i&lt;this.contentList.length;i++)&#123;</div><div class="line">                heightArr.push($(this.contentList[i]).offset().top);</div><div class="line">            &#125;</div><div class="line">            return heightArr;</div><div class="line">        &#125;.bind(this))();</div><div class="line">        this.bindEvents();//???</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>14、javascript逻辑运算符”||”和”&amp;&amp;”:<br>“||”：只要”||”前面为false，不管”||”后面是true还是false，都返回”||”后面的值；只要”||”前面为true，不管”||”后面是true还是false，都返回”||”前面的值。<br>“&amp;&amp;”：只要”&amp;&amp;”前面是false，无论”&amp;&amp;”后面是true还是false，结果都将返回”&amp;&amp;”前面的值；只要”&amp;&amp;”前面是true，无论”&amp;&amp;”后面是true还是false，结果都将返回”&amp;&amp;”后面的值。</p>
<p>15、<ins>与<u>的差别不知道是啥<br><ins>定义了文档的其余部分之外的插入文本；<br><u>代表有下划线<br>两个效果一样哇</u></ins></u></ins></p>
<p>16、<address>标签在每行结尾添加<br>可以保留需要的样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;address&gt;</div><div class="line">	&lt;strong&gt;Twitter, Inc.&lt;/strong&gt;&lt;br&gt;</div><div class="line">	1300 Market Street, Suite 900&lt;br&gt;</div><div class="line">	San Francisco, CA 94103&lt;br&gt;</div><div class="line">	&lt;abbr title=&quot;Phone&quot;&gt;P:&lt;/abbr&gt; (123) 456-7890</div><div class="line">&lt;/address&gt;</div><div class="line"></div><div class="line">&lt;address&gt;</div><div class="line">	&lt;strong&gt;Full Name&lt;/strong&gt;&lt;br&gt;</div><div class="line">	&lt;a href=&quot;mailto:#&quot;&gt;first.last@example.com&lt;/a&gt;</div><div class="line">&lt;/address&gt;</div></pre></td></tr></table></figure></address></p>
<p>17、代码块<br><code></code>包裹内联样式的代码片段<br>代码中的尖括号需要转义：<code>&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;</code><br><kbd></kbd>标记用户通过键盘输入的内容<code>&lt;kbd&gt;&lt;kbd&gt;ctrl&lt;/kbd&gt; + &lt;kbd&gt;,&lt;/kdb&gt;&lt;/kdb&gt;</code></p>
<p>18、bootstrap的栅格系统</p>
<p>IE6-8不支持，解决：</p>
<p>1、引用第三方js，一个叫respond.js的东西，<a href="https://github.com/FOmaerl/Respond.js" target="_blank" rel="noopener">github</a>上可以搜到</p>
<ul>
<li><p>注意事项：</p>
<ul>
<li>需要启动本地服务器（localhost），不能使用普通本地的url地址（file://开头）；</li>
<li>需要外部引入CSS文件，将CSS样式书写在style中是无效的；</li>
<li>由于respond插件是查找CSS文件，再进行处理，所以respond文件一定要放置在CSS文件的后面</li>
<li>另外，虽然把respond放置在head里还是在body后面都能够实现，但是建议放置在head中（具体原因在下面的文档提示中有提到）</li>
<li>最好不要为CSS设置utf-8的编码，使用默认（原因详见下面的文档提示部分）</li>
</ul>
</li>
</ul>
<p>2、由于IE8不支持媒体查询，所以对应不同分辨率的样式失效了，所以解决方法也很简单，都用col-xs的列布局来实现就好了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/小公举/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/18/小公举/" itemprop="url">小公举</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T23:37:43+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/accumulate/" itemprop="url" rel="index">
                    <span itemprop="name">accumulate</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>GooSeeker:集搜客GooSeeker网页抓取软件<br>网址：<a href="http://www.gooseeker.com/" target="_blank" rel="noopener">http://www.gooseeker.com/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/08/做网站的那些tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/08/做网站的那些tips/" itemprop="url">做网站的那些tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-08T23:34:32+08:00">
                2017-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>把《锋利的jQuery》第八章的实例做了一遍，感觉交互效果的逻辑需要锻炼，现在只有个大体的印象，出现问题还只能对照原代码，自己不好发现；很多细节的地方没用过，也不会用；知道的不多，不会利用更加便捷的方式；有一个地方是坑吧，jquery.js文件有不同的版本，所以支持的对象不一定一样；不同浏览器不同的效果，我觉得这个很难发现和总结。。下面是实践过程中自己遇到的明显不足的小知识点。。</p>
<p>1、css:white-space:如何处理元素内的空白<br>可能的值：<br>normal：默认，空白被忽略<br>pre：空白被保留<br>nowrap：文本不换行，在同一行继续，直到遇到<br>标签<br>pre-wrap：保留空白符序列，正常换行<br>pre-line：合并空白符序列，但保留换行符<br>inherit：从父元素继承white-space的值</p>
<p>应用：与width、text-overflow、overflow一起使文本在一行内显示，超出则加省略号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;如果描述超出100像素，则会隐藏，添加省略号&lt;/p&gt;</div><div class="line">p&#123;width: 100px;overflow: hidden;white-space: nowrap;text-overflow:ellopsis;&#125;</div></pre></td></tr></table></figure></p>
<p>支持低版本的opera的办法：o-text-overflow: ellipsis;</p>
<p>关联：word-wrap:允许长单词或URL地址换行到下一行<br>可能的值：<br>normal：只在允许的断字点换行（浏览器保持默认处理）<br>break-word：在长单词或URL地址内部进行换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.test&#123;word-wrap:break-word;&#125;</div></pre></td></tr></table></figure></p>
<p>注意点：</p>
<ul>
<li>（IE浏览器）连续的英文字符和阿拉伯数字,使用word-wrap : break-word;或者word-break:break-all;实现强制断行</li>
<li>（Firefox浏览器）连续的英文字符和阿拉伯数字的断行,Firefox的所有版本的没有解决这个问题,只有让超出边界的字符隐藏或者给容器添加滚动条 .a{word-break:break-all; width:200px; overflow:auto;}.(Firefox浏览器)使用 table-layout:fixed;强制table的宽度,内层td,th采用word- break : break-all;或者word-wrap : break-word ;换行，使用overflow:hidden;隐藏超出内容，这里overflow:auto;无法起作用</li>
</ul>
<p>2、transtision:过渡，复合属性,不需要javascript就可以实现简单的动画效果，包含：</p>
<ul>
<li>transition-property：过渡属性，默认为all</li>
<li>transition-duration：过渡持续时间，默认为0s，必需值不能为0，与delay一样是时间，只有一个时间时，是duration</li>
<li>transition-timing-function：过渡函数，默认为ease函数</li>
<li>transition-delay：过渡延迟时间，默认为0s<br>注：IE9不支持，safari3.1-6\IOS3.2-6.1\android2.1-4.3需要添加-webkit前缀<br>更多的设置和了解，参考博客：<a href="http://www.cnblogs.com/xiaohuochai/p/5347930.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/5347930.html</a></li>
</ul>
<p>3、z-index:元素的堆叠顺序，越高与用户越近，在定位元素上奏效（position:absolute）</p>
<p>4、标签<strike></strike>给文本加删除线,缩写为<s></s>，html5中已经不支持这个标签了。</p>
<p>5、图片不显示，可能是css文件中的路径出错了”../images/…”</p>
<p>6、css3:transform:改变，转换，有x、y之分。属性包含：</p>
<ul>
<li>transform:rotate()：旋转，单位是”deg”-度。</li>
<li>transform:skew()：倾斜，单位相同。</li>
<li>transform:scale()：正值放大，负值缩小，值是缩放比例值。</li>
<li>transform:translate()：位移，单位是px。</li>
</ul>
<p>7、数据类型</p>
<ul>
<li>null:只有一个值的数据类型，表示一个空对象指针。typeof(null):object.如果一个变量准备用于保存对象，那么该变量初始化为null。undefined值派生自null，所以<code>alert(null == undefined);</code>//true</li>
<li>undefined:只有一个值的数据类型，使用var声明变量但未对其加以初始化时，该变量的值是undefined。输出未初始化的变量，返回undefined，输出未声明的变量会产生错误。但对两种变量都可以做typeof()检验，且检验结果一样。</li>
</ul>
<p>8、mouseover:jQuery的事件，鼠标进入某个元素或其子元素时触发。<br>mouseout:jQuery事件，鼠标在离开某个元素或其子元素时触发。<br>onmouseover:html属性<br>hover:相当于mouseenter+mouseleave，鼠标只有进入到某个元素时才触发。</p>
<p>9、javaScript的setInterval():设定每隔指定的时间就执行对应的函数或代码，属于全局对象window。<br><code>setInterval(code,milliseconds[,args...])</code>参数：</p>
<ul>
<li>code:需要执行的函数或js代码</li>
<li>milliseconds:执行函数或代码的间隔时间，单位为毫秒</li>
<li>args:用于给被调用的函数传递参数，参数可以有多个<br>该函数将返回一个标识符ID，是唯一的。<br>参数code可以是1）一段js脚本；2）一个函数声明（可选择带或不带参数）。<br>该函数是在全局作用域下执行的，所以不能调用局部变量。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//错误用法，setInterval的定时代码无法调用局部变量site</div><div class="line">function foo()&#123;</div><div class="line">	var site = &quot;CodePlayer&quot;;</div><div class="line">	setInterval(&apos;alert(site);&apos;,5000);</div><div class="line">	&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line">var x = 15;</div><div class="line">function bar()&#123;</div><div class="line">	var x = 18;</div><div class="line">	setInterval(&apos;alert(x);&apos;,5000);//15</div><div class="line">	&#125;</div><div class="line">//由于setInterval的定时代码是在全局作用域下执行的，因此这里的x为15</div><div class="line">bar();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>但是可以通过一些方法解决上述作用域问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//省略var修饰符，使用全局变量代替局部变量</div><div class="line">function foo1()&#123;</div><div class="line">	site = &quot;CodePlayer 1&quot;;</div><div class="line">	setInterval(&apos;alert(site);&apos;,5000);</div><div class="line">	&#125;</div><div class="line">foo1();</div><div class="line"></div><div class="line">//不使用变量，直接传递变量的值</div><div class="line">function foo2()&#123;</div><div class="line">	var site = &quot;CodePlayer 2&quot;;</div><div class="line">	setInterval(&apos;alert(&quot;&apos; + site + &apos;&quot;);&apos;,5000);</div><div class="line">	&#125;</div><div class="line">foo2();</div><div class="line"></div><div class="line">//延长作用域链，使其能够访问到该函数作用域</div><div class="line">function foo3()&#123;</div><div class="line">	var site = &quot;CodePlayer 3&quot;;</div><div class="line">	setInterval(function()&#123;</div><div class="line">		alert(site);</div><div class="line">		&#125;,5000);</div><div class="line">		&#125;</div><div class="line">foo3();</div><div class="line"></div><div class="line">//调用指定的函数，并给函数传递相应的参数</div><div class="line">function callback(msg)&#123;</div><div class="line">	alert(msg);</div><div class="line">	&#125;</div><div class="line">function foo4()&#123;</div><div class="line">	var site = &quot;CodePlayer 4&quot;;</div><div class="line">	setInterval(callback, 5000, site);</div><div class="line">	&#125;</div><div class="line">foo4();</div></pre></td></tr></table></figure></p>
<p>即该函数的第一个参数不能是布局变量。</p>
<p>clearInterval()则是取消自动执行函数或代码，接收一个参数，是setInterval()返回的标识符ID，所以在设置setInterval时，可以指定一个变量来接受返回值（var int=self.setInterval(“clock()”,50)），该变量可直接作为clearInterval()的参数。<br>注：该知识点来自于：<a href="http://www.365mini.com/page/javascript-setinterval.htm" target="_blank" rel="noopener">http://www.365mini.com/page/javascript-setinterval.htm</a></p>
<p>10、<code>background:url(&quot;../images/hot.gif&quot;) no-repeat scroll 0 0 transparent</code><br>background-attachment:scroll|fixed|inherit<br>background-position:背景图片的移动方向，正值向右，负值向左，第一个数字是水平方向，第二个数字是垂直方向。</p>
<p>11、css的border与outline<br>border:元素主要的边框属性，包括border-width,border-style,border-color，统一设置各边框的格式。border-style的属性有soliddotted(实线)，dashed(点状)，double(双线)，默认值为none；border-width只有当border-style不为none时才有效，不能设置为负值，值可以是thin,medium,thick，也可以是数值，默认为medium；border-color只有当border-style的值不为none,hidden，默认值是transparent。<br>outline:轮廓。在元素边框外围绘制的一条包围元素的线，包括outline-color,outline-style,outline-width，不占页面空间，也不一定是矩形。除了IE以外的浏览器都直接支持outline。只有规定了!DOCUMENT之后的IE8以上版本的浏览器才支持outline。取值类型和默认值与border一致，outline-width与outline-color只有当outline-style不为none时才有效。<br>两者的区别：outline不占空间，不会增加额外的width或者height；outline有可能是非矩形的。</p>
<p>12、宽度值width:元素宽；innerWidth：包含padding的宽度；outerWidth：包含padding+border的宽度；outerWidth(true)包含padding+border+margin的宽度。</p>
<p>13、css:filter与css3:filter<br>css:filter滤镜效果，只能用在html控件元素上，不能使用div的id，class定义。IE4.0以上支持的滤镜效果属性有:Alpha,Blru,Chroma,DropShadow,FlipH,FlipV,Glow,Grayscale,Invert,Light,Mask,Shadow,Wave,Xray.部分浏览器不支持，使用时需查看。<br>css3:filter主要运用在图片上，实现一些特效。默认值是none，可选值有grayscale,sepia,saturate,hue-rotate,invert,opacity,brightness,contrast,blur,drop-shadow。只有webkit支持，且只有webkit nightly版本和Chrome 18.0.976以上的版本才支持。</p>
<p>14、浏览器内核种类整理：</p>
<ul>
<li>Trident代表产品是IE。Trident(又称为MSHTML)，是微软开发的一种排版引擎。使用Trident渲染引擎的浏览器包括：IE，遨游，世界之窗，Avant，Netscape 8，NetCaptor，Sleipnir，GOSURF，GreenBrowser和KKman等。</li>
<li>Gecko内核代表产品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。浏览器有Firefox,Netscape6至9。</li>
<li>Webkit内核代表产品Safari,Chrome.webkit是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。</li>
<li>Presto内核代表产品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0以上使用。</li>
</ul>
<p>15、jQuery中绑定事件有五种方法，以click事件为例<br>a)target.click(function(){});<br>b)target.bind(“click”,function(){});<br>c)target.live(“click”,function(){});<br>d)$(selector).delegate(childSelector,”click”,data,function(){});<br>e)$(selector).on(event,childSelector,data,function)<br>a方法和普通js的用法差不多，只是少了一个on。live的基本功能同bind一样，只是bind方法只能给当前存在的元素绑定事件，对于事后采用js等方式新生成的元素无效，live方法弥补了bind方法的缺陷，可以对后生成的元素也可以绑定相应的事件。live方法的原因归结在“事件委托”上，其处理机制是把时间绑定在DOM树的根节点上，而不是直接绑定在某个元素上。由于只有在事件发生的时候，live方法才会去检测绑定事件的对象是否存在，所以live方法可以实现后来新增的元素也可实现事件的绑定。相比之下，bind会在事件在绑定阶段就会判断绑定事件的元素是否存在，而且只针对当前元素进行绑定，而不是绑定到父节点上。<br>根据上面的分析，live的好处真是很大，那么为什么还要使用bind方法呢？之所以jquery要保留bind方法而不是采用live方法去替代bind，也是因为live在某些情况下是不能够完全替代bind的。主要的不同如下：<br>（1）bind方法可以绑定任何JavaScript的事件，而live方法在jQuery1.3的时候只支持click, dblclick, keydown, keypress, keyup,mousedown, mousemove, mouseout, mouseover, 和 mouseup.在jQuery 1.4.1中，甚至也支持 focus 和 blue 事件了（映射到更合适，并且可以冒泡的focusin和focusout上）。另外，在jQuery 1.4.1中，也能支持hover（映射到”mouseenter mouseleave”）。<br>（2）live()并不完全支持通过DOM遍历的方法找到的元素。取而代之的是，应当总是在一个选择器后面直接使用.live()方法。<br>（3）当一个元素采用live方法进行事件的绑定的时候，如果想阻止事件的传递或冒泡，就要在函数中return false,仅仅调用stopPropagation()是无法实现阻止事件的传递或者冒泡的<br>jQuery1.9版本以下支持live方法，jQuery1.9及其以上版本删除了此方法，用on()方法来代替。<br>d)delegate()为指定元素（被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事发生时运行的函数，使用delegate()方法的事件处理程序适用于当前或未来的元素。使用undelegate()函数删除通过delegate()绑定的事件，适用于jQuery1.4.2及其以上版本。<br>e)on()为指定的元素，添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。使用on()方法的事件处理程序适用于当前或未来的元素。适用于jquery1.7及其以上版本，jquery1.7版本出现之后用于替代bind(),live()绑定事件方式。</p>
<p>16、如果选择器的函数不支持，可能是一开始引入的jquery文件中不包含对函数的支持。</p>
<p>17、<a>标签的可选属性rel和rev表示源文件与目标文档之间正式的关系和方向。<br>rel:源文件到目标文件的关系<br>rev:目标文档到源文档的关系<br>可同时使用</a></p>
<p>18、clear：清除浮动，不允许元素某一侧或两侧有浮动对象。一般都写both，left,right值用来实现垂直环绕布局。更详细的解释和例子参考：<br><a href="http://www.zhangxinxu.com/wordpress/2014/06/understand-css-clear-left-right-and-use/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2014/06/understand-css-clear-left-right-and-use/</a></p>
<p>19、jQuery.stop():停止当前匹配元素上正在运行的动画，默认停止当前正在运行的动画。参数：<br>queueName:需要停止动画的队列名称，默认为”fx”；<br>clearQueue:是否清空队列中的所有动画，默认值为false;<br>jumpToEnd:指示是否直接完成当前动画，默认值为false。<br>详情参见：<a href="http://www.365mini.com/page/jquery-stop.htm" target="_blank" rel="noopener">http://www.365mini.com/page/jquery-stop.htm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/01/css的那些事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/css的那些事/" itemprop="url">css的那些事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T16:45:18+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="盒子大小"><a href="#盒子大小" class="headerlink" title="盒子大小"></a>盒子大小</h3><p>W3C模型中，width等于内容的width。有padding、box、margin的盒子的实际宽度就是<code>width + 2*(padding + border + margin)</code>；<br>IE模型中，width等于内容width+2<em>(border + padding)。有margin的盒子的实际宽度就是`width + 2</em>(margin)`。</p>
<h3 id="居中问题："><a href="#居中问题：" class="headerlink" title="居中问题："></a>居中问题：</h3><ul>
<li>水平居中<ul>
<li>内联模式的文本：<code>text-align: center</code>，适用于inline，inline-block，inline-table，inline-flex</li>
<li>块级别的元素：<code>margin: 0 auto</code></li>
<li>多个块级别的元素：<ul>
<li>多个块级别的元素在同一行：块级别元素间是inline-block，这一行的text-align设置为center。出现的效果是这一行水平居中，内容高度不一致；采用flex布局，<code>justify-content: center</code>可使这一行元素水平居中，内容高度一致。</li>
<li>多个块级别的元素垂直排列，使用<code>margin:0 auto</code>可使它们水平居中。</li>
</ul>
</li>
</ul>
</li>
<li>垂直居中<ul>
<li>内联元素：<ul>
<li>单行文本：<ul>
<li>高度不确定，设置<code>padding-top</code>与<code>padding-bottom</code>一致；</li>
<li>设置<code>line-height</code>等于盒子的高度</li>
</ul>
</li>
<li>多行文本：<ul>
<li>padding好用的情况下可使用；</li>
<li>不好用的原因可能文本是一个表格单元。这时可以使用<code>vertical-align: middle</code>设置。</li>
<li>flex布局，<code>justify-content: center</code>和<code>flex-direction: column</code>。</li>
<li>其他方法都不好用的情况下，在这个元素前面加一个<code>::before</code>，设置它的display与显示元素一致为inline-block，vertical-align为middle。</li>
</ul>
</li>
</ul>
</li>
<li>块级别的元素：<ul>
<li>如果知道高度：使用<code>position: absolute</code>设置高度。</li>
<li>未知高度：使用<code>position: absolute</code>、<code>top: 50%</code>和<code>transform: translateY(-50%);</code></li>
<li>使用弹性（flex）布局：<code>justify-content: center;flex-direction: column</code>。</li>
</ul>
</li>
</ul>
</li>
<li>水平垂直居中：<ul>
<li>知道宽度和高度：<code>position: absolute</code></li>
<li>未知宽度和高度：<code>position: absolute; top: 50%; left:50%;transform: translate(-50%,-50%);</code></li>
<li>使用flex布局：<code>justify-content: center;align-items: center</code></li>
<li>使用grid布局：<code>html{display: grid} span{margin: auto}</code><br>*<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$" target="_blank" rel="noopener">弹性布局</a>：Webkit内核的浏览器需<code>-webkit</code>前缀，<code>float</code>、<code>clear</code>、<code>vertical-align</code>属性失效。采用Flex布局的元素称为容器，子元素称为项目。</li>
</ul>
</li>
</ul>
<p><em>来自教程：<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">CSS-TRICKS</a>
</em><a href="https://jscode.me/t/topic/1936" target="_blank" rel="noopener">垂直居中的七种方法</a></p>
<p>&emsp;&emsp;在布局中遇到内联元素与嵌套元素有缝隙时，考虑vertical-align和line-height之间的关系。他们都基于HTML5。看了张鑫旭的文章用了很久，具体例子就不贴了，给出链接：<a href="www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/">张鑫旭-vertical-align与line-height</a>；<a href="http://www.zhangxinxu.com/wordpress/2009/11/css行高line-height的一些深入理解及应用/" target="_blank" rel="noopener">张鑫旭-对line-hight的理解</a></p>
<h3 id="左边栏固定，右边自适应"><a href="#左边栏固定，右边自适应" class="headerlink" title="左边栏固定，右边自适应"></a>左边栏固定，右边自适应</h3><ul>
<li><p>硬编码定高的情况下：</p>
<ul>
<li>左侧float，右侧margin-left/overflow(BFC)</li>
<li>左侧absolute，右侧margin-left</li>
<li>flex布局：父元素flex=1；子元素左侧定宽，右侧flex=1（左侧如果也是flex=1，会平分空间）</li>
<li>table布局：父元素display=table，子元素左侧、右侧都display=table-cell</li>
<li><p>左右两栏，右侧有子元素，左右两侧都是float=left布局，右侧宽度100%，右侧子元素margin-left是左侧宽度。现在效果是上下两栏，下面已经实现左侧定宽，右侧自适应。(不明白为什么要有这种实现，这种实现没有办法在左侧添加文字等内容)</p>
</li>
<li><p>相关材料：<a href="https://blog.csdn.net/sinat_31057219/article/details/79281864" target="_blank" rel="noopener">https://blog.csdn.net/sinat_31057219/article/details/79281864</a></p>
</li>
</ul>
</li>
<li><p>用css实现等高布局：</p>
<ul>
<li>假的等高，利用背景图在y轴上进行平铺，background: url() repeat-y</li>
<li>给容器div使用单独的背景色（固定布局）<ul>
<li>原理：给每一列的div元素增加一层div，背景设置在单独的div元素上，原则是任何div元素的最大高度来撑大其他div容器高度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="grid是网络布局"><a href="#grid是网络布局" class="headerlink" title="grid是网络布局"></a>grid是网络布局</h3><p>学习材料：</p>
<ul>
<li><a href="http://blog.csdn.net/hj7jay/article/details/70670467" target="_blank" rel="noopener">CSDN-Joker_Ye</a>;</li>
<li><a href="http://cssgridgarden.com/" target="_blank" rel="noopener">有趣的教程</a></li>
</ul>
<h3 id="瀑布流布局"><a href="#瀑布流布局" class="headerlink" title="瀑布流布局"></a>瀑布流布局</h3><p>用css3中的多列布局，可以方便实现瀑布流布局。在块中指定column-count是表示分成几列；column-width每一列的宽，如果不指定count，浏览器分成合适的列数；column-gap指定间隔宽度。为了让浏览器兼容，最好添加三种浏览器前缀：-webkit-/-moz-/-ms-。在程序练习目录有演示示例。该布局flex实现不了。</p>
<h3 id="outline-高亮元素，包括color，style，width"><a href="#outline-高亮元素，包括color，style，width" class="headerlink" title="outline:高亮元素，包括color，style，width"></a>outline:高亮元素，包括color，style，width</h3><h3 id="border-collapse：为表格设置合并边框模型。separate分开；collapse：合并；inherit：继承"><a href="#border-collapse：为表格设置合并边框模型。separate分开；collapse：合并；inherit：继承" class="headerlink" title="border-collapse：为表格设置合并边框模型。separate分开；collapse：合并；inherit：继承"></a>border-collapse：为表格设置合并边框模型。<code>separate</code>分开；<code>collapse</code>：合并；<code>inherit</code>：继承</h3><h3 id="字体：px、pt、em、rem"><a href="#字体：px、pt、em、rem" class="headerlink" title="字体：px、pt、em、rem"></a>字体：px、pt、em、rem</h3><p>&emsp;&emsp;1em = 16px; 1em = 12pt; 1pt = 4/3px;<br>&emsp;&emsp;浏览器默认字体大小：16px。chrome强制最小字体为12px。<br>&emsp;&emsp;区别：</p>
<ul>
<li>px：相对单位，相对于分辨率，所以分辨率越大字体越小。优点：稳定、精确；缺点：缩放影响文本可读性。</li>
<li>em：相对单位，相对于父级元素。优点：弥补了px的不足；缺点：过于依赖父级节点，容易出现字体大小重复声明。</li>
<li>rem：相对单位，相对于根节点html字体大小。缺点：避免了em依赖父级元素字体大小；优点：参考系只有一个，根节点字体大小。</li>
</ul>
<h3 id="html内部是float元素，外部div高度为0的解决办法"><a href="#html内部是float元素，外部div高度为0的解决办法" class="headerlink" title="html内部是float元素，外部div高度为0的解决办法"></a>html内部是float元素，外部div高度为0的解决办法</h3><p>&emsp;&emsp;外部div是block，内部元素是float，float的元素没有实际高度，所以设置了float元素的高度也不会撑开外部block元素的高度。</p>
<p>&emsp;&emsp;解决办法：</p>
<ul>
<li><p>知道高度：显示设置</p>
</li>
<li><p>不知道高度</p>
<ul>
<li><p>jq控制，优点是所有浏览器兼容，缺点是网络不好的时候加载不完，页面可能显示错乱</p>
</li>
<li><p>伪类after，在外部div设置<code>div:after{content: &quot;&quot;,display: block;clear: both;}</code>。IE6/7不支持这个伪类after，可以用hack对这两个浏览器私有的zoom属性，让div远离浮动塌陷问题：<code>div{*zoom:1}</code>。</p>
</li>
<li><p>设置外部元素<code>div{overflow:hidden}</code>，超出隐藏float的元素会自动有高度。</p>
</li>
</ul>
</li>
<li><p>清除浮动带来的影响</p>
</li>
</ul>
<p>&emsp;&emsp;一类是clear: both/left/right;一类是包裹清除。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background: #f0f3f9; padding: 20px"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"float: left;"</span> <span class="attr">src</span>=<span class="string">"http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">/*</div><div class="line">float:left||position:absolute||display:inline-block这些设置在IE、Chrome和火狐中显示正常，可以包含内部元素。</div><div class="line">overflow:hidden，三个浏览器可以包裹，但是是包裹整行，而不是只有这个元素</div><div class="line">zoom:1;为了兼容IE</div><div class="line">*/</div></pre></td></tr></table></figure>
<ul>
<li>通用的清除浮动：<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*写在爸爸身上*/</span></div><div class="line"><span class="selector-class">.clearfix</span>&#123;</div><div class="line">    <span class="attribute">zoom</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">    <span class="attribute">display</span>: table;<span class="comment">/*block*/</span></div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="父子margin合并"><a href="#父子margin合并" class="headerlink" title="父子margin合并"></a>父子margin合并</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">style</span>=<span class="string">"background-color: blue;height: 500px;padding-top: 0.1px"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">style</span>=<span class="string">"background-color: yellowgreen; height: 100px;margin-top: 50px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><p>现象是儿子设置margin-top后，父亲也有相同的margin-top。</p>
</li>
<li><p>解决：</p>
<ul>
<li>给父亲设置样式：overflow: hidden</li>
<li>给父亲设置样式：padding-top: 0.1px</li>
</ul>
</li>
</ul>
<h3 id="神秘的hasLayout"><a href="#神秘的hasLayout" class="headerlink" title="神秘的hasLayout"></a>神秘的hasLayout</h3><ul>
<li><p>IE5.5/6/7中的BFC(Block Formatting Context)，也就是一个元素要么自己对自身内容进行组织和尺寸计算（通过with/height设置自身宽高），要么由其containing block来组织和尺寸计算。</p>
</li>
<li><p>IFC（没有拥有布局），元素无法对自身内容进行组织和尺寸计算，而是由自身内容来决定其尺寸（仅能通过line-height设置内容行距，通过行距支撑元素高度，也无法通过with设置元素宽度，仅能由内容决定）。</p>
</li>
<li><p>默认hasLayout==true的元素</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>, <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>, <span class="tag">&lt;<span class="name">tr</span>&gt;</span>, <span class="tag">&lt;<span class="name">th</span>&gt;</span>, <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>,<span class="tag">&lt;<span class="name">hr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span>, <span class="tag">&lt;<span class="name">button</span>&gt;</span>, <span class="tag">&lt;<span class="name">select</span>&gt;</span>, <span class="tag">&lt;<span class="name">textarea</span>&gt;</span>, <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>, <span class="tag">&lt;<span class="name">legend</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, <span class="tag">&lt;<span class="name">embed</span>&gt;</span>, <span class="tag">&lt;<span class="name">object</span>&gt;</span>, <span class="tag">&lt;<span class="name">applet</span>&gt;</span>,<span class="tag">&lt;<span class="name">marquee</span>&gt;</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;触发hasLayout==true的方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">display: inline-block</div><div class="line">height: (除 auto 外任何值)</div><div class="line">width: (除 auto 外任何值)</div><div class="line">float: (left 或 right)</div><div class="line">position: absolute</div><div class="line">writing-mode: tb-rl</div><div class="line">zoom: (除 normal 外任意值)</div></pre></td></tr></table></figure>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><ul>
<li><p>Block Formatting Context块级格式化上下文，表现是内部元素再怎么折腾，都不会影响外部的元素，所以能够避免margin穿透，清除浮动。</p>
</li>
<li><p>触发BFC</p>
</li>
</ul>
<p><img src="/2017/06/01/css的那些事/bfc.png" alt="触发BFC"></p>
<ul>
<li>优势<ul>
<li>自适应内容由于封闭，更健壮，容错性强。比方说，内部clear:both不会与兄弟float产生矛盾。而纯流体布局，clear:both会让后面内容无法和float元素在一个水平上，产生布局问题。</li>
<li>自适应内容自动填满浮动以为区域，无需关心浮动元素宽度，可以整站大规模应用。而纯流体布局，需要大小不确定的margin/padding等值撑开合适间距，无法CSS组件化。</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.float-left</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left; <span class="attribute">margin-right</span>: <span class="number">20px</span>; </div><div class="line">&#125;</div><div class="line"><span class="selector-class">.bfc-content</span> &#123;</div><div class="line">    <span class="attribute">overflow</span>: hidden; <span class="attribute">background-color</span>: <span class="number">#beceeb</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可实现自适应布局</p>
<ul>
<li><p>没有广泛流行</p>
<ul>
<li>float：本身有破坏性和包裹性，失去了元素本身的流体自适应性</li>
<li>position：absolute脱离流有些严重</li>
<li>overflow：很多场景不能使用overflow:hidden，无法作为一个通用css类整站大规模使用，可以float+overflow局部使用。既可以BFC特性加身，又有流体特性保留。</li>
<li>display：inline-block 会让元素尺寸包裹收缩</li>
<li>display：table-cell IE8+以上的浏览器才支持，跟display：inline-block一样，跟随内容元素的宽度显示。但是单元格的宽度设置再大也不会超过表格容器的宽度。</li>
<li>display：table-row 对width无感，无法自适应剩余容器空间</li>
<li>display：table-caption</li>
</ul>
</li>
<li><p>可以做到自适应布局的有</p>
<ul>
<li>overflow: auto/hidden</li>
<li>display: inline-block</li>
<li>display: table-cell</li>
</ul>
</li>
<li><p>最新的实现方式：<code>display: flow-root</code>是css3中display的新属性，创建了一个BFC。目前主要是火狐和谷歌浏览器实现这个属性。</p>
<ul>
<li>一种兼容多浏览器的写法</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.floatElement</span>&#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">    <span class="attribute">display</span>: table;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">supports</span> (display: flow-root) &#123;</div><div class="line">    <span class="selector-class">.wrapper</span>&#123;</div><div class="line">        <span class="attribute">display</span>: flow-root;</div><div class="line">    &#125;</div><div class="line">    <span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">        <span class="attribute">content</span>: none;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>@supports是css3的条件判断，判断浏览器对某个属性的支持情况，可以配合not、and、or使用。目前只有火狐、Opear较新的属性支持。</li>
</ul>
</li>
<li><a href="http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25321647</a></li>
<li><a href="https://www.w3cplus.com/css3/css3-supports.html" target="_blank" rel="noopener">https://www.w3cplus.com/css3/css3-supports.html</a></li>
<li><a href="http://web.jobbole.com/91165/" target="_blank" rel="noopener">http://web.jobbole.com/91165/</a></li>
</ul>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><ul>
<li>伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；不存在于DOM树。功能一个是获取不存在于DOM树中的信息，如<code>&lt;a&gt;</code>标签中的:link,visited等；一个是获取不能被常规CSS选择器获取的信息，如:target。</li>
<li>伪元素本质上是创建了一个有内容的虚拟容器；一些抽象元素，不存在于文档语言中。</li>
<li>CSS3中伪类和伪元素的语法不同:伪类是一个冒号，伪元素是两个</li>
<li>可以同时使用多个伪类，而只能同时使用一个伪元素；</li>
<li>伪类的效果可以通过添加实际的类来实现，伪类的效果可以通过添加实际的类来实现，它们的本质区别就是是否抽象创造了新元素</li>
</ul>
<p>常见伪类选择器css3：</p>
<pre><code>- :link/:visited/:hover/:active
- :focus
- :checked/:enabled/:disabled
- :first-child/:last-child/:nth-child()/:nth-last-child()/:nth-of-type()/:nth-last-of-type()/:first-of-type/:last-of-type/:only-child/:only-of-type/:empty
- 效率比较：id选择器 》 类选择器 》标签选择器 》 相邻选择器 》 子选择器 》 后代选择器 》 通配符选择器 》 属性选择器 》 伪类选择器
</code></pre><h3 id="自动配置前缀的工具AutoPrefixer"><a href="#自动配置前缀的工具AutoPrefixer" class="headerlink" title="自动配置前缀的工具AutoPrefixer"></a>自动配置前缀的工具AutoPrefixer</h3><ul>
<li>自动为css文件添加各种浏览器前缀</li>
</ul>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><ul>
<li>规定可以由用户调整div元素的大小</li>
<li>resize: none|both|horizontal|vertical</li>
</ul>
<h3 id="css3与flash的优劣势"><a href="#css3与flash的优劣势" class="headerlink" title="css3与flash的优劣势"></a>css3与flash的优劣势</h3><ul>
<li>flash<ul>
<li>优势：<ul>
<li>复杂动画简单一些，接触代码更少，可以GUI搞定</li>
<li>pc兼容性好，IE6压力不大，全部浏览器效果一致</li>
</ul>
</li>
<li>劣势：<ul>
<li>ios不支持</li>
<li>要安装软件，浏览器不原生支持</li>
<li>seo比html+css+js麻烦</li>
</ul>
</li>
</ul>
</li>
<li>css3<ul>
<li>优势：<ul>
<li>新浏览器兼容性好，移动设备兼容性好</li>
<li>改动起来方便，不必启动软件</li>
</ul>
</li>
<li>劣势：<ul>
<li>对旧浏览器不兼容，IE6、7、8</li>
<li>不太友好，但有自动化工具可以帮助生成代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ajax与flash"><a href="#ajax与flash" class="headerlink" title="ajax与flash"></a>ajax与flash</h3><ul>
<li><p>共同点</p>
<ul>
<li>与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</li>
</ul>
</li>
<li><p>不同</p>
<ul>
<li>flash适合处理多媒体、矢量图、访问机器；对CSS、处理文本不足，不容易被搜索，二进制格式，格式私有，文件很大需要等待。</li>
<li>ajax对css、文本支持好，支持搜索，多媒体、矢量图形、机器访问不足，破坏浏览器的后退功能；使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中。</li>
</ul>
</li>
</ul>
<h3 id="position-sticky粘性布局"><a href="#position-sticky粘性布局" class="headerlink" title="position: sticky粘性布局"></a>position: sticky粘性布局</h3><p>是position:relative和fixed的结合。在设置了某一边（top、bottom、left、right）的值后，在没达到这个值时，是relative。达到之后是fixed。<br>position: static默认值，四个边界的定义是无效的。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul>
<li>BFC实现左侧宽度固定，右侧自适应宽度的两栏布局。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"gege"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">content</span>=<span class="string">"didi"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.gege</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid red;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.didi</span>&#123;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid green;</div><div class="line">    <span class="attribute">display</span>: flow-root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不常用table进行布局，因为table必须在页面完全加载完后才显示，没有加载完之前，table为一片空白。而div是逐行显示，不需要页面完全加载完毕，可以一边加载一边显示。</li>
<li><p>不要用tables布局的一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</p>
</li>
<li><p>属于css3的样式：</p>
<ul>
<li>:nth-child(n)是伪类选择器：做表格奇偶行样式变化的时候常用。意思是属于其父元素的第n个子元素，不论元素的类型。n可以是数字、关键字或公式。</li>
<li>:nth-of-type(n)也是伪类选择器。意思是规定属于其父元素的第n个某类型的元素。</li>
</ul>
</li>
<li><p>获取元素的样式：jQuery的css()方法、window.getComputedStyle()、document.defaultView.getComputedStyle()。</p>
<p>  首先，jQuery的css方法底层就应用了getComputedStyle以及getPropertyValue方法。getComputedStyle方法是一个可以获取当前元素所有最终使用的css属性值，返回的是一个css样式声明对象，只读。他与<code>element.style</code>方法不同的是getComputedStyle方法是只读的，只能获取样式，不能设置；而<code>element.style</code>则能读能写；其次，getComputedStyle方法获取的是最终应用在元素上所有CSS属性对象（IE中6-8不支持）；<code>element.style</code>只能获取元素style属性中的css样式；还有一个差别是通过<code>element.style</code>获取到的是样式的具体数值，不带单位；而<code>getComputedStyle</code>方法获取的是样式值的字符串，如果需要与其他样式值做比较，还需去掉单位并转换为数值再进行比较。</p>
<p>  IE中的currentStyle属性（不是方法）与getComputedStyle方法相似，只不过是返回了元素当前的最终CSS属性值。currentStyle不支持伪类样式获取。</p>
<p>  getPropertyValue方法可以获取CSS样式申明对象上的属性值。如<code>window.getComputedStyle(element, null).getPropertyValue(&#39;float&#39;)</code>，直接用键值访问也是可以的，只不过用键值访问可能需要判断浏览器，并使用<code>getComputedStyle(element, null).cssFloat/styleFloat</code>。</p>
<p>  setProperty()方法可以用来设置css样式：<code>element.style.setProperty(&#39;key&#39;,&#39;value&#39;)</code>。IE不支持，用getAttribute方法解决。</p>
</li>
<li><p>css权重等级：行内样式1000 》 ID选择器100 》 类、属性选择器和伪类选择器10 》 元素和伪元素1</p>
</li>
</ul>
<p>参考博文：</p>
<ul>
<li><a href="http://www.jb51.net/css/449969.html" target="_blank" rel="noopener">http://www.jb51.net/css/449969.html</a></li>
<li><a href="https://www.cnblogs.com/plants/p/4882361.html" target="_blank" rel="noopener">https://www.cnblogs.com/plants/p/4882361.html</a></li>
<li><a href="https://www.cnblogs.com/fsjohnhuang/p/5291166.html" target="_blank" rel="noopener">https://www.cnblogs.com/fsjohnhuang/p/5291166.html</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2010/01/对overflow与zoom清除浮动的一些认识/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2010/01/对overflow与zoom清除浮动的一些认识/</a></li>
<li><a href="https://www.cnblogs.com/ihardcoder/p/5294927.html" target="_blank" rel="noopener">https://www.cnblogs.com/ihardcoder/p/5294927.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/10/form的method-我该选谁？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/10/form的method-我该选谁？/" itemprop="url">form的method,我该选谁？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-10T16:33:07+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、是啥</p>
<p>form元素的method属性用来指定发送form的http方法。</p>
<p>使用get时，form数据集被附加到form元素的action属性所制定的url后面，生成url：user.do?loginId=abc，get仅仅是拼接一个URL，然后直接向服务区请求数据，需要提交给服务器的数据集包含在URL中。并且，如果在action的值中为url地址增加参数，后台无法接受这个参数，只能得到表单中的参数，所以可能会缺失数据；<br>使用post时，form数据集被包装在请求的body中并被发送，生成url: user.do，post会把form的数据集，即login=abc这个键值对包装在请求的body中，发给服务器，然后向服务器请求数据，在action的值中为url地址增加参数，后台可以接收，即post方法接收action参数和表单参数。</p>
<p>2、还有啥区别</p>
<ul>
<li>安全性</li>
</ul>
<p>get：提交信息显示在URL上，进而出现在浏览器的历史记录中，格式是<code>variable?value&amp;variable?value...</code>——更安全；</p>
<p>post: 将表单内容放置到HTML表头header中一起传送给服务器端交由action属性所指的程序处理，该程序会通过标准输入（stdin）方式，将表单数据读出处理；</p>
<ul>
<li>编码</li>
</ul>
<p>get: 只能向服务器发送ASCLL字符，post可以发送整个ISO 10646中的字符。</p>
<p>enctype属性有区别，该属性有两个值，默认为application/x-www-form-urlencoded（在发送前编码所有字符）；另一个是multipart/form-data（用于文件上传）只能用于post.</p>
<ul>
<li>提交数据的长度</li>
</ul>
<p>IE限制URL长度为2083个字符，超出限制，提交form不会有反应——get方式受限。</p>
<p>Get 方式传输的数据量非常小，一般限制在 2 KB 左右，但是执行效率却比 Post 方法好；而 Post 方式传递的数据量相对较大，它是等待服务器来读取数据，不过也有字节限制，这是为了避免对服务器用大量数据进行恶意攻击，根据微软方面的说法，微软对用 Request.Form() 可接收的最大数据有限制，IIS 4 中为 80 KB 字节，IIS 5 中为 100 KB 字节。</p>
<ul>
<li>引用</li>
</ul>
<p>可用URL引用一个get的结果页面，post的结果不能。</p>
<p>3、选谁</p>
<ul>
<li>当且仅当form是幂等的时候，使用get。（幂等：多次相同的请求产生的副作用，和一次请求的副作用相同。） </li>
</ul>
<ul>
<li>如果提交请求纯粹只是从服务器端获取数据而不是进行其他操作，并且多次提交不会有明显的副作用，应该使用get。比如：搜索引擎的查询(<a href="http://www.google.com/search?q=abc)和分页(user.do?page=1)；如果提交这个请求会产生其他操作和影响，就应该使用post。" target="_blank" rel="noopener">http://www.google.com/search?q=abc)和分页(user.do?page=1)；如果提交这个请求会产生其他操作和影响，就应该使用post。</a> </li>
</ul>
<p>比如：修改服务器上数据库中的数据；发送一封邮件；删除一个文件等</p>
<ul>
<li>若符合下列任一情况，则用post方法： </li>
</ul>
<p>a.请求的结果有持续性的副作用，例如：数据库内添加新的数据行。 </p>
<p>b.若使用get方法，则表单上收集的数据可能让URL过长。 </p>
<p>c.要传送的数据不是采用ASCII编码。</p>
<ul>
<li>若符合下列任一情况，则用get方法： </li>
</ul>
<p>a.请求是为了查找资源，html表单数据仅用来搜索。 </p>
<p>b.请求结果无持续性的副作用。 </p>
<p>c.收集的数据及html表单内的输入字段名称的总长不超过1024个字符。 </p>
<p>4、还有点小迷糊</p>
<ul>
<li>[浏览器差异] </li>
</ul>
<p>IE6:URL长度限制为2083个字符；post之后，刷新页面不会自动重新post数据，会出现警告。 </p>
<p>IE7和IE6相同。 </p>
<p>Firefox：刷新页面不会自动重新post数据会出现警告。</p>
<ul>
<li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。Request从几个集合取数据是有顺序的，从前到后的顺序依次是 QueryString,Form,最后是ServerVariables。Request对象按照这样的顺序依次搜索这几个集合中的变量，如果有符合的就中止，后面的就不管了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/16/A-citation-is-not-a-citation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/16/A-citation-is-not-a-citation/" itemprop="url">A citation is not a citation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-16T00:11:13+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/research/" itemprop="url" rel="index">
                    <span itemprop="name">research</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;师兄分享了一篇论文给我，让我见识到一个研究者的境界。他与其他学者共著的文章3年内有95篇文献，近一年有44篇引文。作者把这95篇文献一篇一篇读过来，发现引文的质量很差，并且改进了预估引文量的指标。</p>
<p>&emsp;&emsp;原来的评价指标类似h指数、影响因子等等，当作者仔细考虑到引用动机时，发现95篇引文中，只有三篇是有引用意义的。一篇应用了原始文献中的方法，另两篇将原文中的方法拿来做基准方法进行比较。即使只有三篇，他们所得到的结论也没有理解到原始文献中的用意。但是没有好坏或者正误之分。所以，作者通过读95篇文献，选出了真正有引用意义的文献，给原始指标加了一个惩罚项，只计算了被作者筛选出的文献。用原始评价标准如h-index计算原始文献作者的影响力得到的值为117，如果用该方法则是30。足以见到两种方法的差距。</p>
<p>&emsp;&emsp;这篇文献，我读了两遍，效率很低，不过也还是有思考的。最大的感悟是我不适合搞研究，不会将研究做到如此细致的程度。二是，直到现在，我也认为这样做的成本过大。在跟师兄讨论这个做法的意义时，也发现了两种思想的差异。一是以科研为目的的，那么精准性被看的很重要，成本次之。另外一种大概是这个社会的准则，达到主要目的，尽量少的消耗成本。</p>
<p>文章：<br><a href="https://liorpachter.wordpress.com/2017/01/18/a-citation-is-not-a-citation-is-not-a-citation/" target="_blank" rel="noopener">A citation is not a citation</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/三栏布局认识与感悟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/三栏布局认识与感悟/" itemprop="url">三栏布局认识与感悟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T00:00:03+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          两边栏宽度固定，中间栏宽度自适应，高度为最高的一栏。
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/14/三栏布局认识与感悟/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/12/margin理解与使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/12/margin理解与使用/" itemprop="url">margin理解与使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-12T23:56:13+08:00">
                2017-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          主要是负值情况下的使用感悟
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/12/margin理解与使用/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/git操作使用说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/10/git操作使用说明/" itemprop="url">git操作使用说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T21:04:07+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index">
                    <span itemprop="name">skill</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          express the semantic of the academic text
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/10/git操作使用说明/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/03/Introduction-to-ESA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yhuann">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="该叫什么好">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/03/Introduction-to-ESA/" itemprop="url">Introduction to ESA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-03T23:28:31+08:00">
                2017-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/research/" itemprop="url" rel="index">
                    <span itemprop="name">research</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          express the semantic of the academic text
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/03/Introduction-to-ESA/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="Yhuann" />
            
              <p class="site-author-name" itemprop="name">Yhuann</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yhuann</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
