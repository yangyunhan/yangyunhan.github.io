<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="框架," />










<meta name="description" content="前后端架构设计与框架对比首先，MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。前后端都有MVC架构模式的概念，前端的MVC是为了解决前端复杂JS模块化的问题，从后端MVC的V分出来的MVC，与后端MVC并没有直接的关系。前端的MVC中，M占的比例很低，只指代数据。而后端V的比例很低，只有模版的部分。 经典MVC模式下（并非一定在js中），涉及两种设计模式：view和model之间的">
<meta name="keywords" content="框架">
<meta property="og:type" content="article">
<meta property="og:title" content="前端框架vs前端框架vs后端框架">
<meta property="og:url" content="http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/index.html">
<meta property="og:site_name" content="寻 觅">
<meta property="og:description" content="前后端架构设计与框架对比首先，MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。前后端都有MVC架构模式的概念，前端的MVC是为了解决前端复杂JS模块化的问题，从后端MVC的V分出来的MVC，与后端MVC并没有直接的关系。前端的MVC中，M占的比例很低，只指代数据。而后端V的比例很低，只有模版的部分。 经典MVC模式下（并非一定在js中），涉及两种设计模式：view和model之间的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52">
<meta property="og:image" content="http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件/blog/source/_posts/前端框架vs前端框架vs后端框架/mvc.png">
<meta property="og:image" content="http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件/blog/source/_posts/前端框架vs前端框架vs后端框架/mvp.png">
<meta property="og:image" content="http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件/blog/source/_posts/前端框架vs前端框架vs后端框架/mvvm.png">
<meta property="og:updated_time" content="2018-09-22T08:30:51.839Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端框架vs前端框架vs后端框架">
<meta name="twitter:description" content="前后端架构设计与框架对比首先，MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。前后端都有MVC架构模式的概念，前端的MVC是为了解决前端复杂JS模块化的问题，从后端MVC的V分出来的MVC，与后端MVC并没有直接的关系。前端的MVC中，M占的比例很低，只指代数据。而后端V的比例很低，只有模版的部分。 经典MVC模式下（并非一定在js中），涉及两种设计模式：view和model之间的">
<meta name="twitter:image" content="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/"/>





  <title>前端框架vs前端框架vs后端框架 | 寻 觅</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">寻 觅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">活成什么样子才算是见过世面</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yingwan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatars.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寻 觅">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端框架vs前端框架vs后端框架</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-22T16:25:21+08:00">
                2018-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/summary/" itemprop="url" rel="index">
                    <span itemprop="name">summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/22/前端框架vs前端框架vs后端框架/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/22/前端框架vs前端框架vs后端框架/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="前后端架构设计与框架对比"><a href="#前后端架构设计与框架对比" class="headerlink" title="前后端架构设计与框架对比"></a>前后端架构设计与框架对比</h4><p>首先，MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。前后端都有MVC架构模式的概念，前端的MVC是为了解决前端复杂JS模块化的问题，从后端MVC的V分出来的MVC，与后端MVC并没有直接的关系。前端的MVC中，M占的比例很低，只指代数据。而后端V的比例很低，只有模版的部分。<br><img src="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52" alt="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52"></p>
<p>经典MVC模式下（并非一定在js中），涉及两种设计模式：view和model之间的观察者模式，view观察model，事先在此model上注册，以便view可以了解在数据model上发生的改变。和view和controller之间的策略模式，一个策略是一个表述算法的对象。MVC将响应机制封装在controller对象中。存在着一个controller的类层次结构，使得可以方便地对原有的controller做适当改变而创建新的controller。view使用controller子类的实例来实现一个特定的响应策略。要实现不同的响应的策略只要用不同种类的controller实例替换即可。</p>
<p>经典MVC到jsMVC可以实现1对1的转换，但controller的角色有些许改变。从原来派发用户输入给不同的view和改变model到用户和系统的连接。在js中，controller的职责已经被系统实现了。<br><img src="/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件\blog\source\_posts\前端框架vs前端框架vs后端框架\mvc.png" alt=""></p>
<p>MVP是想改变cotroller与view的捆绑关系，view有用户处理事件的能力。但是用户处理事件统一放到P中，如此，多个view可以公用一个controller。通过Presenter更新model，通过观察者模式更新view。更新方式与MVC一样，但是MVC的更新过程是一个圆，一个循环的过程。MVP依赖Presenter作为核心，负责从model中拿数据，填充到view中。常见的MVP的实现是被动视图，Presenter观察model，不再是view观察model，一旦model发生变化，就会更新view。Presenter有效地绑定了model到view。view暴露了setters接口以便Presenter可以设置数据。对于这种被动视图的结构，没有直接数据绑定的概念。但是他的好处是在view和model直接提供更清晰的分离。但是由于缺乏数据绑定支持，意味着不得不单独关注某个任务。在MVP里，应用程序的逻辑主要在Presenter来实现，其中的view是很薄的一层。<br><img src="/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件\blog\source\_posts\前端框架vs前端框架vs后端框架\mvp.png" alt=""></p>
<p>MVVM的特点是数据绑定，view和model是不知道彼此存在的，同MVP一样，将view和model清晰地分离开来。 其次，view是对viewmodel的外在显示，与viewmodel保持同步，viewmodel对象可以看作是view的上下文。view绑定到viewmodel的属性上，如果viewmodel中的属性值变化了，这些新值通过数据绑定会自动传递给view。反过来viewmodel会暴露model中的数据和特定状态给view。所以，view不知道model的存在，viewmodel和model也觉察不到view。<br><img src="/2018/09/22/前端框架vs前端框架vs后端框架/D:/软件\blog\source\_posts\前端框架vs前端框架vs后端框架\mvvm.png" alt=""></p>
<p>简单来说，<code>MV*</code>的区别在M与V的联系上，Controller负责监听view的用户事件，得到数据做处理，渲染view。由于各个模块耦合性强，无法单独验证应用逻辑正确性，不能判断出问题的模块。所以有MVP调用view层的接口渲染model。如此，P可以做单元测试，结构也更清楚。但是当view变的复杂之后，需要的接口变多，增加了开发调试的成本，所以有了MVVM。VM中构建一组状态数据（view层的抽象），通过双向数据绑定使VM中的状态数据与View中的显示状态保持一致。VM只适合复杂UI交互的项目。</p>
<p>参考：<br>​    - <a href="https://segmentfault.com/a/1190000015310674" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015310674</a><br>​    - <a href="http://efe.baidu.com/blog/mvc-deformation/" target="_blank" rel="noopener">http://efe.baidu.com/blog/mvc-deformation/</a></p>
<p>其次，React的定位是MVC框架中的V，Vue的定位是MVVM框架中的VM，Angular的定位是完整的MVVM框架。</p>
<ul>
<li>React-13：可以非常方便地构建大型网页应用。<ul>
<li>出现：为了降低操作DOM的代价</li>
<li>优点：<ul>
<li>速度快。提出了Virtual Dom这种新颖的思路，并且这种思路衍生出了React Native，有可能会统一Web/Native开发。在性能方面，由于运用了Virtual Dom技术，Reactjs只在调用setState的时候会更新dom，而且还是先更新Virtual Dom，然后和实际Dom比较，最后再更新实际Dom。一是更新dom的次数少，二是更新dom的内容少。</li>
<li>模块化。独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。组件通过组合、嵌套构成更复杂的UI界面。</li>
<li>ReactJS更关注数据的单向更新，但是它更简单直观，所有的状态改变只有一个入口this.setState()。/<em>它提出了FLUX架构的新概念，现在React可以直接用Js ES6语法了，然后通过webpack编译成浏览器兼容的ES5，开发效率上有些优势. </em>/</li>
<li>React Native生成的App不是运行在WebView上，而是系统原生的UI，React通过jsx生成系统原生的UI，iOS和Android的React UI组件还是比较相似的，大量代码可以复用。</li>
<li>同构的JavaScript: 单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</li>
<li>跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</li>
<li>灵活性、轻量级、开源、版本迁移容易</li>
</ul>
</li>
<li>缺点：<br>React是目标是UI组件，通常可以和其它框架组合使用，目前并不适合单独做一个完整的框架。React 即使配上 redux 的组合，也不能称之一个完整的框架，比如你想用Promise化的AJAX？要自己找现成的库。而且第三方组件远远不如Angular多。React本身只是一个V而已，所以如果是大型项目想要一套完整的框架的话，也许还需要引入Redux和route相关的东西。</li>
</ul>
</li>
<li>Vue-13：非常适合用于构架非常灵活的UI和复杂的单页面应用。<ul>
<li>是一个提供 MVVM 数据双向绑定的库，专注于UI 层面，核心思想是：数据驱动、组件系统。</li>
<li>数据观测原理在技术实现上，利用的是 ES5 Object.defineProperty 和存储器属性: getter 和 setter（所以只兼容 IE9 及以上版本）</li>
<li>Vue实现数据和视图保持一致性：每一个指令都会有一个对应的用来观测数据的对象，叫做 watcher，比如v-text=”msg”, ，即为两个 watcher，watcher对象中包含了待渲染的关联 DOM 元素。<ul>
<li>将原生的数据改造成 “可观察对象”，通常为调用 defineProperty 改变 data 对象中数据为存储器属性；一个可观察对象可以被取值 getter，也可以被赋值setter。</li>
<li>解析模板，也就是在 watcher 的求值过程中，每一个被取值的可观察对象都会将当前的 watcher 注册为自己的一个订阅者，并成为当前watcher的一个依赖。</li>
<li>当一个被依赖的可观察对象被赋值时，它会通知 notify 所有订阅自己的 watcher 重新求值，并触发相应的更新，即watcher对象中关联的 DOM 改变渲染。</li>
<li>使用 Virtual DOM；提供了响应式（Reactive）和组件化（Composable）的视图组件；将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库</li>
</ul>
</li>
<li>端对端的数据渲染，react是setState更新组件，父组件更新子组件重新渲染</li>
<li>继承方式不同，react面向对象继承，vue需要遵循很多规则</li>
<li>优点：<ul>
<li>轻便（20多kb），双向绑定</li>
<li>强化的HTML，像Angular</li>
<li>可适用性：可以很快地从其它框架转移到Vue.js</li>
<li>整合性：Vue.js可以同时用于单页面应用和更加复杂的网页应用。主要在于你可以用它编写很小的可交互部件，然后可以很容易地整合到现有的项目中而不会影响到整个系统；</li>
</ul>
</li>
<li>缺点：<ul>
<li>不支持ie8</li>
<li>在整个市场中只占有很小的比例，所以相应的资源、知识要少很多；</li>
<li>灵活性带来的风险：有时候，将其整合到大型项目的时候会有一些问题，但是不见得能够找到解法</li>
</ul>
</li>
</ul>
</li>
<li><p>Angular-09:对于构建高度可交互的网页应用非常方便。</p>
<ul>
<li>出现：AngularJS是为了克服HTML在构建应用上的不足而设计的。使用了不同的方法，它尝试去补足HTML本身在构建应用方面的缺陷。通过使用标识符(directives)的结构，让浏览器能够识别新的语法。例如使用双大括号语法进行数据绑定；使用ng-controller指定每个控制器负责监视视图中的哪一部分；使用ng-model，把输入数据绑定到模型中的一部分属性上。</li>
<li>优点：<ul>
<li>AngularJS是一套完整的框架，angular有自带的数据绑定、render渲染、angularUI库,过滤器,directive(模板),服务q(defer),http，inject(依赖注入),factory,provider……，等等一系列工具，基本上只要你在做web开发用过的东西，它都有一个。</li>
<li>新特性：RXJS，快速编译（3秒内），新的HttpClient；</li>
<li>详细的文档几乎涵盖了所有必须的信息</li>
<li>数据双向绑定，可以减少出错的风险</li>
<li>MVVM(Model-View-ViewModel)使得开发者可以针对同一个App模块同时开发</li>
<li>依赖注入使得模块化和模块中组件引入更加方便；</li>
</ul>
</li>
<li>缺点：<ul>
<li>性能：随着组件增加，项目越来越复杂，双向数据绑定带来性能问题。在JavaScript（ES5）中，并没有实现当变量或对象改变时发出通知的功能，Angular的实现方法被叫做“Dirty-checking（脏检查机制）”，通过跟踪数据的改变再动态更新用户界面（UI）。在Angular的作用域中任何操作的执行都会引发Dirty-checking，随着绑定数量的增加性能就会越低。</li>
<li>学习成本高</li>
<li>迁移问题：从低版本升级到新版本的时候，不兼容导致迁移成本高。</li>
</ul>
</li>
</ul>
</li>
<li><p>在react，angular，vue这三者中，Angular的适用领域相对窄一些，React可以拓展到服务端，移动端Native部分，而Vue因为比较轻量，还能用于业务场景非常轻的页面中。</p>
</li>
<li>在web应用中，要解决三个问题：状态、组织和效率<ul>
<li>状态：在一个业务界面中，可能根据数据生成界面，再通过操作改变数据，影响界面中另一些部分。其中有两种关系：从数据到界面和从界面到数据。能够描述界面当前状况的数据，可称为状态。不同框架采用不同方式做了处理：MVVM流的Angular和Vue，通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后，再根据配置好的规则去，从数据更新界面状态；React走的是另外一个流派，就是所谓的函数式，在这个里面，推崇的是单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）。</li>
<li>组织：模块关系和业务模型。模块关系就是模块化，业务模型指的是所处领域中的业务数据、规则、流程的集合。</li>
<li>效率：开发效率和运行效率。组件化提高开发效率；运行效率在于数据变更检测方式和创建和修改DOM</li>
</ul>
</li>
<li>参考材料：<ul>
<li><a href="https://www.w3cvip.org/topics/93" target="_blank" rel="noopener">https://www.w3cvip.org/topics/93</a></li>
<li><a href="https://segmentfault.com/a/1190000005159165" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005159165</a></li>
<li><a href="https://blog.csdn.net/u012125579/article/details/52744093" target="_blank" rel="noopener">https://blog.csdn.net/u012125579/article/details/52744093</a></li>
<li><a href="https://blog.fundebug.com/2018/07/09/react_vs_angular_vue/" target="_blank" rel="noopener">https://blog.fundebug.com/2018/07/09/react_vs_angular_vue/</a></li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/框架/" rel="tag"># 框架</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/04/React与类MVVM框架/" rel="next" title="React再整理">
                <i class="fa fa-chevron-left"></i> React再整理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/02/小鱼房子/" rel="prev" title="小鱼房子">
                小鱼房子 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatars.jpg"
                alt="Yingwan" />
            
              <p class="site-author-name" itemprop="name">Yingwan</p>
              <p class="site-description motion-element" itemprop="description">我还在认识自己的路上</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yangyunhan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="1205385190@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-yhuanny@gmail.com"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#前后端架构设计与框架对比"><span class="nav-number">1.</span> <span class="nav-text">前后端架构设计与框架对比</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yingwan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/09/22/前端框架vs前端框架vs后端框架/';
          this.page.identifier = '2018/09/22/前端框架vs前端框架vs后端框架/';
          this.page.title = '前端框架vs前端框架vs后端框架';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
