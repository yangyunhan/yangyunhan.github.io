






<!doctype html>
<html lang="zh-Hans">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Yhuann">
  
  
  
  
    <meta name="description" content="React与类MVVM框架React原理及diff理解
虚拟DOM+diff算法，虚拟DOM树像是客户端与DOM之间的代理对象，该对象是js的树形结构。将html、css、页面逻辑混合在一起生成一个js形式的浏览器可以直接识别的reactRenderTree，浏览器直接painting和显示，使DOM树构建的复杂度从O(n^3)转为O(n)，最小化DOM操作。
分别对tree、compone...">
  
  <title>React与类MVVM框架 [ 该叫什么好 ]</title>
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
  
    <div class="item next">
      <a href="/2018/06/16/跨域大法总结/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        跨域大法总结
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/uploads/avatar.jpg"/>
          <div id="homelink">该叫什么好</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/">Home</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">Archives</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">Tags</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">Categories</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">About</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/yangyunhan/yangyunhan.github.io">Github</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>React与类MVVM框架</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">Created at 2018-07-04</span>
      
        <span id = "post-title-updated">Updated at 2018-08-04</span>
      
      
      <span id = "post-title-categories">Category
      
      
        
        
        <a href="/categories/summary/">summary</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      Tag
      
      
        
        
        <a href="/tags/框架/">框架</a>
      
      </span>
      
    </p>
    
    <h2 id="React与类MVVM框架"><a href="#React与类MVVM框架" class="headerlink" title="React与类MVVM框架"></a>React与类MVVM框架</h2><h4 id="React原理及diff理解"><a href="#React原理及diff理解" class="headerlink" title="React原理及diff理解"></a>React原理及diff理解</h4><ul>
<li>虚拟DOM+diff算法，虚拟DOM树像是客户端与DOM之间的代理对象，该对象是js的树形结构。将html、css、页面逻辑混合在一起生成一个js形式的浏览器可以直接识别的reactRenderTree，浏览器直接painting和显示，使DOM树构建的复杂度从O(n^3)转为O(n)，最小化DOM操作。</li>
<li>分别对tree、component、element diff进行优化：<ul>
<li>tree：只对同一层次的节点进行比较，发现不同时，直接删除该节点及其子节点，再添加新的节点</li>
<li>component：统一类型的节点，继续比较；不同类型，dirty component，替换整个组件</li>
<li>element：添加唯一key区分同一层级的节点，当修改后的位移小于最右的位置时才会进行位移操作，更新完新集合，遍历老集合删去要删除的节点。</li>
</ul>
</li>
<li>应保持React结构的稳定，有助于性能提升；减少将最后一个节点移到列表首部的操作。节点数量过大和更新过频繁会影响性能。</li>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20346379</a><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4></li>
<li>注意不要使用push、pop、shift、unshift、splice等方法修改React中数组类型的状态，因为这些方法都是在原数组的基础上修改，而concat、slice、filter会返回一个新的数组。state应是不可变对象。</li>
<li><a href="https://juejin.im/entry/59522bdb6fb9a06b9a516113" target="_blank" rel="noopener">https://juejin.im/entry/59522bdb6fb9a06b9a516113</a></li>
</ul>
<h4 id="ref：在典型数据流外（props）强制修改子组件"><a href="#ref：在典型数据流外（props）强制修改子组件" class="headerlink" title="ref：在典型数据流外（props）强制修改子组件"></a>ref：在典型数据流外（props）强制修改子组件</h4><ul>
<li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回。</li>
<li>ref更新发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前。</li>
<li>可以通过这个属性获得Dom元素或者子组件的实例。在无状态组件和函数式组件中，则需要一个变量来保存组件或DOM元素实例（闭包）。因为无状态组件不会被实例化，在父组件中通过ref获取无状态子组件时，值为null。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div ref=&#123;(node) =&gt; refDom = node&#125;&gt;</div><div class="line">...</div><div class="line">&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><p>componentWillMount请求数据会执行两次：服务器端没有did方法，因为涉及到DOM渲染，只能在浏览器端。如果做服务器端渲染，则会执行两次，否则是一样的。</p>
<h4 id="React中的key"><a href="#React中的key" class="headerlink" title="React中的key"></a>React中的key</h4><p>React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。</p>
<h4 id="React事件处理"><a href="#React事件处理" class="headerlink" title="React事件处理"></a>React事件处理</h4><blockquote>
<p>为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。<br>SyntheticEvent 是浏览器原生事件跨浏览器的封装。SyntheticEvent 和浏览器原生事件一样有 stopPropagation()、preventDefault() 接口，而且这些接口夸浏览器兼容。<br>阻止冒泡事件有三种方式：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">handleClick(e)&#123;</div><div class="line">    <span class="comment">// 阻止合成事件间的冒泡</span></div><div class="line">    e.stopPropagation();</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">&#125;</div><div class="line">handleClick(e)&#123;</div><div class="line">    <span class="comment">// 阻止合成事件与最外层document上的事件间的冒泡</span></div><div class="line">    e.nativeEvent.stopImmediatePropagation();</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*阻止合成事件与除最外层document上的原生事件上的冒泡*/</span></div><div class="line">componentDidMount() &#123;</div><div class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,e=&gt;&#123;</div><div class="line">        <span class="comment">// 通过e.target判断阻止冒泡</span></div><div class="line">        <span class="keyword">if</span>(e.target&amp;&amp;e.target.matches(<span class="string">'a'</span>))&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'body'</span>);</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考材料：</p>
<ul>
<li><a href="https://html-js.site/2017/08/25/react%E4%BA%8B%E4%BB%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1/" target="_blank" rel="noopener">https://html-js.site/2017/08/25/react%E4%BA%8B%E4%BB%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1/</a></li>
</ul>
<h4 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h4><ul>
<li>组件的state中不能出现props</li>
<li>使用 PropTypes 和 getDefaultProps()：非预期情况下，获得警告</li>
<li><p>component –&gt; pureComponent</p>
<ul>
<li>在state和props真正改变的时候重新渲染，减少渲染次数（浅比较）</li>
<li>适合在展示组件，无状态组件中使用</li>
<li>每次更新state时，需返回一个新对象</li>
<li>当有常变化的部分（输入框的改变事件）和一般不变化的部分（列表）在一起时，可以将不变的列表部分抽出用pureComponent表示</li>
<li>使用匿名函数传递props会失去pureComponent的优势，因为每次渲染都会创建一个新的函数</li>
</ul>
</li>
<li><p>动态多个className：引入库classnames</p>
</li>
<li>参考：<ul>
<li><a href="https://segmentfault.com/a/1190000005013207" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005013207</a></li>
<li><a href="https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs-2344.html" target="_blank" rel="noopener">https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs-2344.html</a></li>
<li><a href="https://github.com/AnHongpeng/blog/issues/5" target="_blank" rel="noopener">https://github.com/AnHongpeng/blog/issues/5</a></li>
</ul>
</li>
</ul>
<p>其他参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/24856035?utm_medium=social&amp;utm_source=wechat_session" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24856035?utm_medium=social&amp;utm_source=wechat_session</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24781259?refer=wxyyxc1992" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24781259?refer=wxyyxc1992</a></li>
<li><a href="https://juejin.im/entry/5a0eb032f265da43294da014" target="_blank" rel="noopener">React模式-https://juejin.im/entry/5a0eb032f265da43294da014</a></li>
<li><a href="https://knownsec-fed.com/2018-01-28-fan-yi-react-zu-jian-mo-shi/" target="_blank" rel="noopener">https://knownsec-fed.com/2018-01-28-fan-yi-react-zu-jian-mo-shi/</a></li>
<li><a href="https://tyrmars.gitbooks.io/react-steppitguide/content/React-01" target="_blank" rel="noopener">https://tyrmars.gitbooks.io/react-steppitguide/content/React-01</a></li>
</ul>
<h4 id="前后端架构设计与框架对比"><a href="#前后端架构设计与框架对比" class="headerlink" title="前后端架构设计与框架对比"></a>前后端架构设计与框架对比</h4><p>首先，MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。前后端都有MVC架构模式的概念，前端的MVC是为了解决前端复杂JS模块化的问题，从后端MVC的V分出来的MVC，与后端MVC并没有直接的关系。前端的MVC中，M占的比例很低，只指代数据。而后端V的比例很低，只有模版的部分。<br><img src="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52" alt="https://sfault-image.b0.upaiyun.com/356/500/3565004702-5b238bef92e52"></p>
<p>经典MVC模式下（并非一定在js中），涉及两种设计模式：view和model之间的观察者模式，view观察model，事先在此model上注册，以便view可以了解在数据model上发生的改变。和view和controller之间的策略模式，一个策略是一个表述算法的对象。MVC将响应机制封装在controller对象中。存在着一个controller的类层次结构，使得可以方便地对原有的controller做适当改变而创建新的controller。view使用controller子类的实例来实现一个特定的响应策略。要实现不同的响应的策略只要用不同种类的controller实例替换即可。</p>
<p>经典MVC到jsMVC可以实现1对1的转换，但controller的角色有些许改变。从原来派发用户输入给不同的view和改变model到用户和系统的连接。在js中，controller的职责已经被系统实现了。<br><img src="/2018/07/04/React与类MVVM框架/" alt=""></p>
<p>MVP是想改变cotroller与view的捆绑关系，view有用户处理事件的能力。但是用户处理事件统一放到P中，如此，多个view可以公用一个controller。通过Presenter更新model，通过观察者模式更新view。更新方式与MVC一样，但是MVC的更新过程是一个圆，一个循环的过程。MVP依赖Presenter作为核心，负责从model中拿数据，填充到view中。常见的MVP的实现是被动视图，Presenter观察model，不再是view观察model，一旦model发生变化，就会更新view。Presenter有效地绑定了model到view。view暴露了setters接口以便Presenter可以设置数据。对于这种被动视图的结构，没有直接数据绑定的概念。但是他的好处是在view和model直接提供更清晰的分离。但是由于缺乏数据绑定支持，意味着不得不单独关注某个任务。在MVP里，应用程序的逻辑主要在Presenter来实现，其中的view是很薄的一层。<br><img src="/2018/07/04/React与类MVVM框架/" alt=""></p>
<p>MVVM的特点是数据绑定，view和model是不知道彼此存在的，同MVP一样，将view和model清晰地分离开来。 其次，view是对viewmodel的外在显示，与viewmodel保持同步，viewmodel对象可以看作是view的上下文。view绑定到viewmodel的属性上，如果viewmodel中的属性值变化了，这些新值通过数据绑定会自动传递给view。反过来viewmodel会暴露model中的数据和特定状态给view。所以，view不知道model的存在，viewmodel和model也觉察不到view。<br><img src="/2018/07/04/React与类MVVM框架/" alt=""></p>
<p>简单来说，<code>MV*</code>的区别在M与V的联系上，Controller负责监听view的用户事件，得到数据做处理，渲染view。由于各个模块耦合性强，无法单独验证应用逻辑正确性，不能判断出问题的模块。所以有MVP调用view层的接口渲染model。如此，P可以做单元测试，结构也更清楚。但是当view变的复杂之后，需要的接口变多，增加了开发调试的成本，所以有了MVVM。VM中构建一组状态数据（view层的抽象），通过双向数据绑定使VM中的状态数据与View中的显示状态保持一致。VM只适合复杂UI交互的项目。</p>
<p>参考：</p>
<pre><code>- [https://segmentfault.com/a/1190000015310674](https://segmentfault.com/a/1190000015310674)
- [http://efe.baidu.com/blog/mvc-deformation/](http://efe.baidu.com/blog/mvc-deformation/)
</code></pre><p>其次，React的定位是MVC框架中的V，Vue的定位是MVVM框架中的VM，Angular的定位是完整的MVVM框架。</p>
<ul>
<li><p>React-13：可以非常方便地构建大型网页应用。</p>
<ul>
<li>出现：为了降低操作DOM的代价</li>
<li>优点：<ul>
<li>速度快。提出了Virtual Dom这种新颖的思路，并且这种思路衍生出了React Native，有可能会统一Web/Native开发。在性能方面，由于运用了Virtual Dom技术，Reactjs只在调用setState的时候会更新dom，而且还是先更新Virtual Dom，然后和实际Dom比较，最后再更新实际Dom。一是更新dom的次数少，二是更新dom的内容少。</li>
<li>模块化。独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。组件通过组合、嵌套构成更复杂的UI界面。</li>
<li>ReactJS更关注数据的单向更新，但是它更简单直观，所有的状态改变只有一个入口this.setState()。/<em>它提出了FLUX架构的新概念，现在React可以直接用Js ES6语法了，然后通过webpack编译成浏览器兼容的ES5，开发效率上有些优势. </em>/</li>
<li>React Native生成的App不是运行在WebView上，而是系统原生的UI，React通过jsx生成系统原生的UI，iOS和Android的React UI组件还是比较相似的，大量代码可以复用。</li>
<li>同构的JavaScript: 单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</li>
<li>跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</li>
<li>灵活性、轻量级、开源、版本迁移容易</li>
</ul>
</li>
<li>缺点：<br>  React是目标是UI组件，通常可以和其它框架组合使用，目前并不适合单独做一个完整的框架。React 即使配上 redux 的组合，也不能称之一个完整的框架，比如你想用Promise化的AJAX？要自己找现成的库。而且第三方组件远远不如Angular多。React本身只是一个V而已，所以如果是大型项目想要一套完整的框架的话，也许还需要引入Redux和route相关的东西。</li>
</ul>
</li>
<li><p>Vue-13：非常适合用于构架非常灵活的UI和复杂的单页面应用。</p>
<ul>
<li>是一个提供 MVVM 数据双向绑定的库，专注于UI 层面，核心思想是：数据驱动、组件系统。</li>
<li>数据观测原理在技术实现上，利用的是 ES5 Object.defineProperty 和存储器属性: getter 和 setter（所以只兼容 IE9 及以上版本）</li>
<li>Vue实现数据和视图保持一致性：每一个指令都会有一个对应的用来观测数据的对象，叫做 watcher，比如v-text=”msg”, ，即为两个 watcher，watcher对象中包含了待渲染的关联 DOM 元素。<ul>
<li>将原生的数据改造成 “可观察对象”，通常为调用 defineProperty 改变 data 对象中数据为存储器属性；一个可观察对象可以被取值 getter，也可以被赋值setter。</li>
<li>解析模板，也就是在 watcher 的求值过程中，每一个被取值的可观察对象都会将当前的 watcher 注册为自己的一个订阅者，并成为当前watcher的一个依赖。</li>
<li>当一个被依赖的可观察对象被赋值时，它会通知 notify 所有订阅自己的 watcher 重新求值，并触发相应的更新，即watcher对象中关联的 DOM 改变渲染。</li>
<li>使用 Virtual DOM；提供了响应式（Reactive）和组件化（Composable）的视图组件；将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库</li>
</ul>
</li>
<li>端对端的数据渲染，react是setState更新组件，父组件更新子组件重新渲染</li>
<li>继承方式不同，react面向对象继承，vue需要遵循很多规则</li>
<li>优点：<ul>
<li>轻便（20多kb），双向绑定</li>
<li>强化的HTML，像Angular</li>
<li>可适用性：可以很快地从其它框架转移到Vue.js</li>
<li>整合性：Vue.js可以同时用于单页面应用和更加复杂的网页应用。主要在于你可以用它编写很小的可交互部件，然后可以很容易地整合到现有的项目中而不会影响到整个系统；</li>
</ul>
</li>
<li>缺点：<ul>
<li>不支持ie8</li>
<li>在整个市场中只占有很小的比例，所以相应的资源、知识要少很多；</li>
<li>灵活性带来的风险：有时候，将其整合到大型项目的时候会有一些问题，但是不见得能够找到解法</li>
</ul>
</li>
</ul>
</li>
<li><p>Angular-09:对于构建高度可交互的网页应用非常方便。</p>
<ul>
<li>出现：AngularJS是为了克服HTML在构建应用上的不足而设计的。使用了不同的方法，它尝试去补足HTML本身在构建应用方面的缺陷。通过使用标识符(directives)的结构，让浏览器能够识别新的语法。例如使用双大括号语法进行数据绑定；使用ng-controller指定每个控制器负责监视视图中的哪一部分；使用ng-model，把输入数据绑定到模型中的一部分属性上。</li>
<li><p>优点：</p>
<ul>
<li>AngularJS是一套完整的框架，angular有自带的数据绑定、render渲染、angularUI库,过滤器,directive(模板),服务q(defer),http，inject(依赖注入),factory,provider……，等等一系列工具，基本上只要你在做web开发用过的东西，它都有一个。</li>
<li>新特性：RXJS，快速编译（3秒内），新的HttpClient；</li>
<li>详细的文档几乎涵盖了所有必须的信息</li>
<li>数据双向绑定，可以减少出错的风险</li>
<li>MVVM(Model-View-ViewModel)使得开发者可以针对同一个App模块同时开发</li>
<li>依赖注入使得模块化和模块中组件引入更加方便；</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>性能：随着组件增加，项目越来越复杂，双向数据绑定带来性能问题。在JavaScript（ES5）中，并没有实现当变量或对象改变时发出通知的功能，Angular的实现方法被叫做“Dirty-checking（脏检查机制）”，通过跟踪数据的改变再动态更新用户界面（UI）。在Angular的作用域中任何操作的执行都会引发Dirty-checking，随着绑定数量的增加性能就会越低。</li>
<li>学习成本高</li>
<li>迁移问题：从低版本升级到新版本的时候，不兼容导致迁移成本高。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>在react，angular，vue这三者中，Angular的适用领域相对窄一些，React可以拓展到服务端，移动端Native部分，而Vue因为比较轻量，还能用于业务场景非常轻的页面中。</li>
<li><p>在web应用中，要解决三个问题：状态、组织和效率</p>
<ul>
<li>状态：在一个业务界面中，可能根据数据生成界面，再通过操作改变数据，影响界面中另一些部分。其中有两种关系：从数据到界面和从界面到数据。能够描述界面当前状况的数据，可称为状态。不同框架采用不同方式做了处理：MVVM流的Angular和Vue，通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后，再根据配置好的规则去，从数据更新界面状态；React走的是另外一个流派，就是所谓的函数式，在这个里面，推崇的是单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）。</li>
<li>组织：模块关系和业务模型。模块关系就是模块化，业务模型指的是所处领域中的业务数据、规则、流程的集合。</li>
<li>效率：开发效率和运行效率。组件化提高开发效率；运行效率在于数据变更检测方式和创建和修改DOM</li>
</ul>
</li>
<li><p>参考材料：</p>
<ul>
<li><a href="https://www.w3cvip.org/topics/93" target="_blank" rel="noopener">https://www.w3cvip.org/topics/93</a></li>
<li><a href="https://segmentfault.com/a/1190000005159165" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005159165</a></li>
<li><a href="https://blog.csdn.net/u012125579/article/details/52744093" target="_blank" rel="noopener">https://blog.csdn.net/u012125579/article/details/52744093</a></li>
<li><a href="https://blog.fundebug.com/2018/07/09/react_vs_angular_vue/" target="_blank" rel="noopener">https://blog.fundebug.com/2018/07/09/react_vs_angular_vue/</a></li>
</ul>
</li>
</ul>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">Show TOC</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">Hide TOC</button>
  <div class="random-toc">
    <h2>Table of Content</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#React与类MVVM框架"><span class="toc-text">React与类MVVM框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React原理及diff理解"><span class="toc-text">React原理及diff理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#状态"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref：在典型数据流外（props）强制修改子组件"><span class="toc-text">ref：在典型数据流外（props）强制修改子组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生命周期函数"><span class="toc-text">生命周期函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React中的key"><span class="toc-text">React中的key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React事件处理"><span class="toc-text">React事件处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#项目优化"><span class="toc-text">项目优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前后端架构设计与框架对比"><span class="toc-text">前后端架构设计与框架对比</span></a></li></ol></li></ol></li></ol>
  </div>
</div>

  
<nav id="pagination">
  

  

  
    <a href="/2018/06/16/跨域大法总结/" class="next">Next post 跨域大法总结 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Yhuann using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>



<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/uploads/avatar.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/yangyunhan/yangyunhan.github.io">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://weibo.com/3817275592/profile?rightmod=1&wvr=6&mod=personinfo">
        
          <i class="icon iconfont weibo">&#xe602;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_1.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_2.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_3.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_4.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_5.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_6.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_7.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_8.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_10.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_11.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_12.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_14.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_25.jpg?imageView2/1/w/__width__/h/__height__');
    
      backgroundImages.push('http://7te9fe.com1.z0.glb.clouddn.com/bgimg_34.jpg?imageView2/1/w/__width__/h/__height__');
    
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"blur":true,"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

